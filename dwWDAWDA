local function startKatchiHub()
--[[
    Katchi Hub - Guts & BlackPowder
    Made by Yuki
    Professional WindUI Version
]]--
-- // Shared services (for all sections)
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService") 
local HttpService = game:GetService("HttpService")
local MarketplaceService = game:GetService("MarketplaceService")
local Workspace = game:GetService("Workspace")
local TeleportService = game:GetService("TeleportService")
local CollectionService = game:GetService("CollectionService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer

do -- // Loader + UI + Dashboard
    local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
    WindUI:SetNotificationLower(true)

-- after: local WindUI = loadstring(game:HttpGet(...))()
-- add this block below that line, before you call WindUI:CreateWindow({...})

-- ===== platoboost service for WindUI KeySystem (with optional MasterKey) =====
do
    local HttpService = game:GetService("HttpService")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local setClipboard = setclipboard or toclipboard
    local requestFunc = (syn and syn.request) or (http and http.request) or request or http_request

    local function safeRequest(opts)
        if not requestFunc then
            return nil, "HTTP request not supported by executor"
        end
        local ok, res = pcall(function() return requestFunc(opts) end)
        if not ok then return nil, "request failed: " .. tostring(res) end
        if typeof(res) ~= "table" then return nil, "invalid response type" end
        return res
    end

    local function digest(input)
        local s = tostring(input)
        local out = ""
        for i = 1, #s do out = out .. string.format("%02x", string.byte(s, i)) end
        return out
    end

    local function getHwid()
        local ok, id = pcall(function() return tostring(LocalPlayer.UserId) end)
        return (ok and id) and id or "unknown"
    end

    WindUI.Services = WindUI.Services or {}
    -- Note Args now include MasterKey (optional)
    WindUI.Services.platoboost = {
        Name = "Platoboost",
        Icon = "cloud",
        Args = { "ServiceId", "Secret", "MasterKey" }, -- MasterKey is optional
        New = function(ServiceId, Secret, MasterKey)
            local apiHost = "https://api.platoboost.app"
            local cachedLink, cachedTime = "", 0

            local function cacheLink()
                if (cachedTime + 600) > os.time() and cachedLink ~= "" then
                    return true, cachedLink
                end

                local body = HttpService:JSONEncode({ service = tonumber(ServiceId) or ServiceId, identifier = digest(getHwid()) })
                local res, err = safeRequest({
                    Url = apiHost .. "/public/start",
                    Method = "POST",
                    Headers = { ["Content-Type"] = "application/json" },
                    Body = body
                })
                if not res then return false, err end
                if res.StatusCode == 200 then
                    local ok, decoded = pcall(function() return HttpService:JSONDecode(res.Body) end)
                    if ok and decoded and decoded.success and decoded.data and decoded.data.url then
                        cachedLink = decoded.data.url
                        cachedTime = os.time()
                        return true, cachedLink
                    else
                        return false, (decoded and decoded.message) or "invalid start response"
                    end
                elseif res.StatusCode == 429 then
                    return false, "rate limited"
                end
                return false, "failed to get link"
            end

            local function Copy()
                local ok, link = cacheLink()
                if ok and link then
                    pcall(setClipboard, link)
                    return true, link
                end
                return false, link
            end

            local function generateNonce()
                local chars = "abcdefghijklmnopqrstuvwxyz0123456789"
                local out = ""
                for i = 1, 16 do
                    local idx = math.random(1, #chars)
                    out = out .. chars:sub(idx, idx)
                end
                return out
            end

            local function Verify(key)
                if not key or key == "" then return false, "empty key" end

                -- 1) MasterKey bypass: if MasterKey exists and matches exactly, accept immediately
                if MasterKey and tostring(key) == tostring(MasterKey) then
                    return true, { master = true, message = "Master key accepted" }
                end

                -- 2) Otherwise perform platoboost verification
                local nonce = generateNonce()
                local identifier = digest(getHwid())

                local endpoint = apiHost .. "/public/whitelist/" .. tostring(ServiceId)
                endpoint = endpoint .. "?identifier=" .. identifier .. "&key=" .. tostring(key)
                endpoint = endpoint .. "&nonce=" .. nonce

                local res, err = safeRequest({ Url = endpoint, Method = "GET" })
                if not res then return false, err end
                if res.StatusCode == 200 then
                    local ok, decoded = pcall(function() return HttpService:JSONDecode(res.Body) end)
                    if ok and decoded and decoded.success and decoded.data then
                        if decoded.data.hash and decoded.data.value and Secret then
                            local expected = digest(tostring(decoded.data.value) .. "-" .. nonce .. "-" .. tostring(Secret))
                            if decoded.data.hash == expected then
                                return (decoded.data.valid == true), decoded
                            else
                                return false, "integrity verification failed"
                            end
                        end
                        return (decoded.data.valid == true), decoded
                    else
                        return false, (decoded and decoded.message) or "invalid verify response"
                    end
                elseif res.StatusCode == 429 then
                    return false, "rate limited"
                end
                return false, "invalid server response"
            end

            return {
                Verify = function(key)
                    local ok, a, b = pcall(function() return Verify(key) end)
                    if not ok then return false, "verify failed" end
                    if a == true then return true, b end
                    return false, b
                end,
                Copy = function()
                    local ok, a, b = pcall(function() return Copy() end)
                    if not ok then return false, "copy failed" end
                    if a then return true, b end
                    return false, b
                end
            }
        end
    }
end
-- ===== end platoboost service

    local function showQueueLoader()
        local blur = Instance.new("BlurEffect", Lighting)
        blur.Size = 0
        TweenService:Create(blur, TweenInfo.new(0.5), {Size = 24}):Play()

        local screenGui = Instance.new("ScreenGui", LocalPlayer:WaitForChild("PlayerGui"))
        screenGui.Name = "KatchiLoader"
        screenGui.ResetOnSpawn = false
        screenGui.IgnoreGuiInset = true

        local frame = Instance.new("Frame", screenGui)
        frame.Size = UDim2.new(1, 0, 1, 0)
        frame.BackgroundTransparency = 1

        local bg = Instance.new("Frame", frame)
        bg.Size = UDim2.new(1, 0, 1, 0)
        bg.BackgroundColor3 = Color3.fromRGB(10, 10, 20)
        bg.BackgroundTransparency = 1
        bg.ZIndex = 0
        TweenService:Create(bg, TweenInfo.new(0.5), {BackgroundTransparency = 0.3}):Play()

        local word = "KATCHI HUB"
        local letters = {}

        local function tweenOutAndDestroy()
            for _, label in ipairs(letters) do
                TweenService:Create(label, TweenInfo.new(0.3), {TextTransparency = 1, TextSize = 30}):Play()
            end
            TweenService:Create(bg, TweenInfo.new(0.5), {BackgroundTransparency = 1}):Play()
            TweenService:Create(blur, TweenInfo.new(0.5), {Size = 0}):Play()
            wait(0.6)
            screenGui:Destroy()
            blur:Destroy()
        end

        for i = 1, #word do
            local char = word:sub(i, i)

            local label = Instance.new("TextLabel")
            label.Text = char
            label.Font = Enum.Font.GothamBlack
            label.TextColor3 = Color3.fromRGB(135, 0, 0)
            label.TextStrokeTransparency = 1 
            label.TextTransparency = 1
            label.TextScaled = false
            label.TextSize = 30 
            label.Size = UDim2.new(0, 60, 0, 60)
            label.AnchorPoint = Vector2.new(0.5, 0.5)
            label.Position = UDim2.new(0.5, (i - (#word / 2 + 0.5)) * 65, 0.5, 0)
            label.BackgroundTransparency = 1
            label.Parent = frame

            local tweenIn = TweenService:Create(label, TweenInfo.new(0.3), {TextTransparency = 0, TextSize = 60})
            tweenIn:Play()

            table.insert(letters, label)
            wait(0.25)
        end

        wait(2)
        tweenOutAndDestroy()
    end

    showQueueLoader()

local Window = WindUI:CreateWindow({
    Title = "Katchi Hub",
    Author = "by Yuki",
    Folder = "KatchiHub/GutsBlackPowder",
    Transparent = true,
    HideSearchBar = false,
    ScrollBarEnabled = true,
    Theme = "Red",
    User = {
        Enabled = true,
        Anonymous = false,
        Callback = function() end,
    },
})
    Window:SetToggleKey(Enum.KeyCode.RightShift)

    local button = Window:EditOpenButton({
        Title = "Katchi Hub",
        Icon = "sword",
        Size = UDim2.new(0, 140, 0, 40),
        CornerRadius = UDim.new(0, 10),
        StrokeThickness = 3,
        Draggable = true,
    })

    -- Rounded corners
    local uicorner = Instance.new("UICorner")
    uicorner.CornerRadius = UDim.new(0, 10)
    uicorner.Parent = button

    -- Subtle background gradient for a premium look
    local bgGradient = Instance.new("UIGradient")
    bgGradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(165, 28, 48)),
        ColorSequenceKeypoint.new(0.5, Color3.fromRGB(220, 90, 40)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 180, 60)),
    }
    bgGradient.Rotation = 45
    bgGradient.Parent = button

    -- Stroke for contrast and slight glow effect
    local stroke = Instance.new("UIStroke")
    stroke.Thickness = 2.2
    stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    stroke.Color = Color3.fromRGB(255, 245, 220)
    stroke.Transparency = 0.25
    stroke.Parent = button

    -- Animated rotation to give subtle life to the control
    task.spawn(function()
        while true do
            local tween = TweenService:Create(bgGradient, TweenInfo.new(6, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {
                Rotation = bgGradient.Rotation + 360
            })
            tween:Play()
            tween.Completed:Wait()
            bgGradient.Rotation = bgGradient.Rotation % 360
        end
    end)

    Window:SetIconSize(48)
    Window:Tag({
        Title = "v2.5",
        Color = Color3.fromHex("#f81f1f") -- deep crimson
    })
    Window:Tag({
        Title = "Guts & BlackPowder",
        Color = Color3.fromHex("#f81f1f") -- gold accent
    })

    local DashboardTab = Window:Tab({ Title = "Dashboard", Icon = "layout-dashboard" })

    DashboardTab:Select() -- Select Tab

    local DiscordSection = DashboardTab:Section({
        Title = "Community",
        Icon = "users",
        Opened = true
    })

    local InfoSection = DashboardTab:Section({
        Title = "Information",
        Icon = "info",
        Opened = true
    })

    InfoSection:Paragraph({
        Title = "Katchi Hub v2.5",
        Desc = "Professional Guts & BlackPowder Script Hub\nMade by Yuki\nExecutor: "..(identifyexecutor and identifyexecutor() or "Unknown"),
    })

    InfoSection:Paragraph({
        Title = "Changelogs",
        Desc = "New Features\n- Added Auto Fife!\n- Added Anti Bomber In Reach And Kill Aura!\n- Improved AutoShove",
    })

-- Make sure this exists somewhere near the top of your script
local HttpService = game:GetService("HttpService")

-- Discord constants
local discordInvite = "https://discord.gg/vBYZCGGyK6"
local widgetUrl = "https://discord.com/api/guilds/1433658537027833969/widget.json"
local TOTAL_MEMBERS = 269 -- manually keep this roughly updated

-- Main Discord card
local DiscordCard = DiscordSection:Paragraph({
    Title = "Katchi Hub | Balls ðŸ”¥",
    Desc  = "ðŸŸ¢ Loading online...\nâšª " .. TOTAL_MEMBERS .. " Members\nEst. Oct 2025",

    -- WindUI supports remote URLs directly (same as their example)
    Image = "https://raw.githubusercontent.com/KatchiHub/Katchi-Huh/refs/heads/main/download.jpg",
    ImageSize = 48,

    Buttons = {
        {
            Title = "Copy Invite",
            Icon = "link",
            Callback = function()
                setclipboard(discordInvite)
                WindUI:Notify({
                    Title = "Copied!",
                    Content = "Discord invite link has been copied to your clipboard.",
                    Duration = 3,
                    Icon = "copy",
                })
            end
        }
    }
})

-- Live online count updater
local function updateDiscordCard()
    local online = 0

    local ok, body = pcall(function()
        return game:HttpGet(widgetUrl)
    end)

    if ok and body then
        local okDecode, data = pcall(function()
            return HttpService:JSONDecode(body)
        end)

        if okDecode and type(data) == "table" then
            online = tonumber(data.presence_count) or 0
        end
    end

    local line1 = string.format("ðŸŸ¢ %d Online    âšª %d Members", online, TOTAL_MEMBERS)
    local line2 = "Est. Oct 2025"

    DiscordCard:SetDesc(line1 .. "\n" .. line2)
end

task.spawn(function()
    while true do
        updateDiscordCard()
        task.wait(30)
    end
end)
end

local Main1Section = Window:Section({
    Title = "Main",
    Icon = "house",
    Opened = false,
})

local Esp1Section = Window:Section({
    Title = "Esp",
    Icon = "scan",
    Opened = false,
})

local Event1Section = Window:Section({
    Title = "Events",
    Icon = "sparkles",
    Opened = false,
})

local Others1Section = Window:Section({
    Title = "Others",
    Icon = "settings",
    Opened = false,
})

do -- // Main Tab
    local MainTab = Main1Section:Tab({ Title = "Main", Icon = "shield-check" })

local enabled = true

-- Modules (Bayonet / Melee override, safe non-blocking require)
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Modules = ReplicatedStorage:FindFirstChild("Modules") or nil

-- safe helper that returns status: "absent" | "failed" | "ok"
local function safeRequire(moduleInstance)
    if not moduleInstance then
        return "absent", "module not present"
    end
    local ok, res = pcall(function() return require(moduleInstance) end)
    if not ok then
        return "failed", res -- require attempted and errored
    end
    return "ok", res -- require succeeded
end

-- DEFAULT NO-OPS / STUBS so code doesn't error if modules missing
local function noop() end
local function noop_change(value) end

local changeBayonet = noop_change
local changeMelee = noop_change

-- DebugVisualizer stub (safe no-op interface)
local DebugVisualizerStub = {
    CastSphere = function(...) end,
    CastLine = function(...) end,
}

-- Track presence vs require-failure vs success
local FlintLockPresent, FlintLockRequireFailed, FlintLockSuccess, FlintLock = false, false, false, nil
local MeleeBasePresent, MeleeBaseRequireFailed, MeleeBaseSuccess, MeleeBase = false, false, false, nil

-- Attempt to find & require modules without yielding (don't lock on missing)
local weaponsFolder = Modules and Modules:FindFirstChild("Weapons")
local flintModInstance = weaponsFolder and weaponsFolder:FindFirstChild("Flintlock")
if flintModInstance then
    FlintLockPresent = true
    local status, res = safeRequire(flintModInstance)
    if status == "ok" then
        FlintLockSuccess = true
        FlintLock = res

        local originBayonet = FlintLock.BayonetHitCheck

        local v_u_1 = {}
        v_u_1.__index = v_u_1

        function v_u_1.BayonetHitCheck(p115, p116, p117, p118, p119)
            local v120 = workspace:Raycast(p116, p117, p118)
            if v120 then
                if v120.Instance.Parent.Name == "m_Zombie" then
                    local v121 = p118.FilterDescendantsInstances
                    local v122 = v120.Instance
                    table.insert(v121, v122)
                    p118.FilterDescendantsInstances = v121
                    local v123 = v120.Instance.Parent:FindFirstChild("Orig")
                    if v123 then
                        local Head = nil
                        for i, part in pairs(v120.Instance.Parent:GetChildren()) do
                            if part.Name == "Head" and (part.ClassName == "Part" or part.ClassName == "MeshPart") then
                                Head = part
                                break
                            end
                        end
                        if Head then
                            p115.remoteEvent:FireServer("Bayonet_HitZombie", v123.Value, Head.CFrame.Position, true, "Head")
                            local v_u_124 = v123.Value
                            local v_u_125 = tick()
                            v_u_124:SetAttribute("WepHitID", tick())
                            v_u_124:SetAttribute("WepHitDirection", p117 * 10)
                            v_u_124:SetAttribute("WepHitPos", v120.Position)
                            task.delay(0.2, function()
                                if v_u_124:GetAttribute("WepHitID") == v_u_125 then
                                    v_u_124:SetAttribute("WepHitDirection", nil)
                                    v_u_124:SetAttribute("WepHitPos", nil)
                                    v_u_124:SetAttribute("WepHitID", nil)
                                end
                            end)
                        end
                    end
                    return 1
                end
                local v126 = v120.Instance.Parent:FindFirstChild("DoorHit") or v120.Instance:FindFirstChild("BreakGlass")
                if v126 and not table.find(p119, v126) then
                    table.insert(p119, v126)
                    p115.remoteEvent:FireServer("Bayonet_HitCon", v120.Instance, v120.Position, v120.Normal, v120.Material)
                    return 2
                end
                local v127 = v120.Instance.Parent:FindFirstChild("Humanoid") or v120.Instance.Parent.Parent:FindFirstChild("Humanoid")
                if v127 and not table.find(p119, v127) then
                    table.insert(p119, v127)
                    p115.remoteEvent:FireServer("Bayonet_HitPlayer", v127, v120.Position)
                    return 2
                end
            end
            return 0
        end

        function changeBayonet(value)
            FlintLock.BayonetHitCheck = value and v_u_1.BayonetHitCheck or originBayonet
        end
    elseif status == "failed" then
        -- module present but require errored -> mark require-failed (will lock later)
        FlintLockRequireFailed = true
    else
        -- status == "absent", do nothing (wait)
        FlintLockPresent = false
    end
else
    -- module absent: do nothing (we wait)
    FlintLockPresent = false
end

-- Attempt MeleeBase detection + require similarly (non-blocking)
local meleeModInstance = (Modules and Modules:FindFirstChild("Weapons") and Modules.Weapons:FindFirstChild("MeleeBase")) or (Modules and Modules:FindFirstChild("MeleeBase"))
if meleeModInstance then
    MeleeBasePresent = true
    local status, res = safeRequire(meleeModInstance)
    if status == "ok" then
        MeleeBaseSuccess = true
        MeleeBase = res

        local originMelee = MeleeBase.MeleeHitCheck

        local u1 = {}
        u1.__index = u1

        local u8 = game:GetService("CollectionService")

        -- safe require for DebugVisualizer (non-blocking)
        local dbgMod = Modules and Modules:FindFirstChild("RbxUtil") and Modules.RbxUtil:FindFirstChild("DebugVisualizer")
        local dbgStatus, dbgRes = safeRequire(dbgMod)
        local u10 = (dbgStatus == "ok") and dbgRes or DebugVisualizerStub

        local v11 = game.Players.LocalPlayer:FindFirstChild("Options") or game.Players.LocalPlayer:WaitForChild("Options")
        local u14 = v11:FindFirstChild("Gore") or v11:WaitForChild("Gore")
        local u15 = v11:FindFirstChild("WeaponStains") or v11:WaitForChild("WeaponStains")
        local v5 = ReplicatedStorage:FindFirstChild("GameStates") and ReplicatedStorage.GameStates:FindFirstChild("Gameplay")
        local u7 = v5 and v5:FindFirstChild("PVP")

        function u1.MeleeHitCheck(p100, p101, p102, p103, p104, p105)
            local v106 = workspace:Raycast(p101, p102, p103)
            if v106 then
                if v106.Instance.Parent.Name == "m_Zombie" then
                    local v107 = p103.FilterDescendantsInstances
                    local v108 = v106.Instance
                    table.insert(v107, v108)
                    p103.FilterDescendantsInstances = v107
                    local v109 = v106.Instance.Parent:FindFirstChild("Orig")
                    if v109 then
                        if p100.sharp and shared.Gib ~= nil then
                            if v109.Value then
                                local v110 = v109.Value:FindFirstChild("Zombie")
                                local v111 = not p100.Stats.HeadshotMulti and 2.3 or p100.Stats.HeadshotMulti
                                if v110 and v110.Health - p100.Stats.Damage * v111 <= 0 then
                                    shared.Gib(v109.Value, v106.Instance.Name, v106.Position, v106.Normal, true)
                                end
                            else
                                shared.Gib(v109.Value, v106.Instance.Name, v106.Position, v106.Normal, true)
                            end
                        end
                        if not p104[v109] or p104[v109] < (p100.Stats.MaxHits or 3) then
                            if p105 then
                                p100.remoteEvent:FireServer("ThrustCharge", v109.Value, v106.Position, v106.Normal)
                            else
                                local Head = nil
                                for i, part in pairs(v106.Instance.Parent:GetChildren()) do
                                    if part.Name == "Head" and (part.ClassName == "Part" or part.ClassName == "MeshPart") then
                                        Head = part
                                        break
                                    end
                                end
                                if Head then
                                    local u112 = v109.Value
                                    local v113 = Head.CFrame.Position - p101
                                    if v113:Dot(v113) > 1 then
                                        v113 = v113.Unit
                                    end
                                    local v114 = v113 * 25
                                    p100.remoteEvent:FireServer("HitZombie", u112, Head.CFrame.Position, true, v114, "Head", v106.Normal)
                                    if not u112:GetAttribute("WepHitDirection") then
                                        local u115 = tick()
                                        u112:SetAttribute("WepHitID", tick())
                                        u112:SetAttribute("WepHitDirection", v114)
                                        u112:SetAttribute("WepHitPos", v106.Position)
                                        task.delay(0.2, function()
                                            if u112:GetAttribute("WepHitID") == u115 then
                                                u112:SetAttribute("WepHitDirection", nil)
                                                u112:SetAttribute("WepHitPos", nil)
                                                u112:SetAttribute("WepHitID", nil)
                                            end
                                        end)
                                    end
                                    pcall(function() u10:CastSphere("MeleeHitValid", CFrame.new(p101), Color3.fromRGB(0, 255, 0)) end)
                                    pcall(function() u10:CastSphere("PartPosition", CFrame.new(v106.Position), Color3.fromRGB(255, 85, 0)) end)
                                    pcall(function() u10:CastLine("MeleeHit", CFrame.new(p101, p101 + p102) * CFrame.new(0, 0, -p102.Magnitude / 2), Color3.fromRGB(0, 255, 0), p102.Magnitude / 1) end)
                                end
                            end
                            if p104[v109] then
                                p104[v109] = p104[v109] + 1
                            else
                                table.insert(p104, v109)
                                p104[v109] = 1
                                if u14.Value and (u15.Value and p100.player:GetAttribute("Platform") ~= "Console") then
                                    local v116 = p100.bloodSaturation + 0.1
                                    p100.bloodSaturation = math.min(v116, 1)
                                end
                            end
                        end
                    end
                    return 1
                end
                if not p105 then
                    local v117 = v106.Instance.Parent:FindFirstChild("DoorHit") or v106.Instance:FindFirstChild("BreakGlass")
                    if v117 and not table.find(p104, v117) then
                        table.insert(p104, v117)
                        p100.remoteEvent:FireServer("HitCon", v106.Instance)
                        pcall(function() u10:CastSphere("MeleeHitValid", CFrame.new(p101), Color3.fromRGB(0, 255, 0)) end)
                        pcall(function() u10:CastLine("MeleeHit", CFrame.new(p101, p101 + p102) * CFrame.new(0, 0, -p102.Magnitude / 2), Color3.fromRGB(255, 255, 0), p102.Magnitude / 1) end)
                        return 2
                    end
                    local v118 = v106.Instance.Parent:FindFirstChild("Humanoid") or v106.Instance.Parent.Parent:FindFirstChild("Humanoid")
                    if v118 and not table.find(p104, v118) then
                        table.insert(p104, v118)
                        p100.remoteEvent:FireServer("HitPlayer", v118, v106.Position)
                        pcall(function() u10:CastSphere("MeleeHitValid", CFrame.new(p101), Color3.fromRGB(0, 255, 0)) end)
                        pcall(function() u10:CastLine("MeleeHit", CFrame.new(p101, p101 + p102) * CFrame.new(0, 0, -p102.Magnitude / 2), Color3.fromRGB(0, 255, 0), p102.Magnitude / 1) end)
                        return 2
                    end
                    if u7 and u7:GetAttribute("Active") == true then
                        local v119 = v106.Instance.Parent:FindFirstChild("BuildingHealth") or v106.Instance.Parent.Parent:FindFirstChild("BuildingHealth")
                        if v119 ~= nil and not table.find(p104, v119) then
                            table.insert(p104, v119)
                            local v120 = v119.Parent:FindFirstChild("Creator")
                            if v120 then
                                v120 = v120.Value
                            end
                            if v120 ~= nil and (v120.Neutral == false and (p100.player.Team ~= nil and (v120.Team ~= nil and p100.player.Team.Name == v120.Team.Name))) then
                                return 2
                            end
                            p100.remoteEvent:FireServer("HitBuilding", v119.Parent)
                            pcall(function() u10:CastSphere("MeleeHitValid", CFrame.new(p101), Color3.fromRGB(0, 255, 0)) end)
                            pcall(function() u10:CastLine("MeleeHit", CFrame.new(p101, p101 + p102) * CFrame.new(0, 0, -p102.Magnitude / 2), Color3.fromRGB(255, 255, 0), p102.Magnitude / 1) end)
                            return 2
                        end
                    end
                    if p100.Stats.BreaksDown and u8:HasTag(v106.Instance, "Breakable") then
                        local v121 = OverlapParams.new()
                        v121.FilterDescendantsInstances = p103.FilterDescendantsInstances
                        local v122 = workspace:GetPartBoundsInRadius(v106.Position, 0.1, v121)
                        local v123 = {}
                        for v124 = 1, #v122 do
                            if u8:HasTag(v122[v124], "Breakable") then
                                local v125 = v122[v124]
                                table.insert(v123, v125)
                            end
                        end
                        p100.remoteEvent:FireServer("HitBreakable", v123, (v106.Position - p101).Unit)
                        pcall(function() u10:CastSphere("MeleeHitValid", CFrame.new(p101), Color3.fromRGB(0, 255, 0)) end)
                        pcall(function() u10:CastLine("MeleeHit", CFrame.new(p101, p101 + p102) * CFrame.new(0, 0, -p102.Magnitude / 2), Color3.fromRGB(255, 255, 0), p102.Magnitude / 1) end)
                        return 2
                    end
                    pcall(function() u10:CastLine("MeleeHit", CFrame.new(p101, p101 + p102) * CFrame.new(0, 0, -p102.Magnitude / 2), Color3.fromRGB(255, 0, 0), p102.Magnitude / 1) end)
                end
            else
                pcall(function() u10:CastLine("MeleeHit", CFrame.new(p101, p101 + p102) * CFrame.new(0, 0, -p102.Magnitude / 2), Color3.fromRGB(255, 0, 0), p102.Magnitude / 1) end)
            end
            return 0
        end

        function changeMelee(value)
            MeleeBase.MeleeHitCheck = value and u1.MeleeHitCheck or originMelee
        end
    elseif status == "failed" then
        MeleeBaseRequireFailed = true
    else
        MeleeBasePresent = false
    end
else
    MeleeBasePresent = false
end

-- ---------- Aiming Section (toggles for head hit) ----------
local AimingSection = MainTab:Section({
    Title = "Aiming",
    Icon = "crosshair",
    Opened = false
})

local HeadHitEnabled = false

local function notifyErrorAndLock(toggle)
    -- notify user and lock the toggle (both wrapped so they won't error)
    pcall(function()
        if WindUI then
            WindUI:Notify({
                Title = "Aiming â€” Error",
                Content = "Head Hit had an error and will be locked.",
                Duration = 4,
                Icon = "alert-circle",
            })
        end
    end)
    pcall(function()
        if toggle and toggle.Lock then toggle:Lock() end
    end)
end

local HeadHitToggle = AimingSection:Toggle({
    Title = "Head Hit",
    Flag = "Aiming_HeadHit",
    Desc = "Forces Attacks To Redirect to the zombies Head.",
    Default = HeadHitEnabled,
    Callback = function(value)
        -- reflect UI intent immediately
        HeadHitEnabled = value

        -- If a require previously failed for any module, lock & notify (require-failure = module existed but require errored)
        if FlintLockRequireFailed or MeleeBaseRequireFailed then
            HeadHitEnabled = false
            pcall(function() changeBayonet(false) end)
            pcall(function() changeMelee(false) end)
            notifyErrorAndLock(HeadHitToggle)
            return
        end

        -- If user is enabling but no modules are present yet, allow it (we "wait")
        -- apply overrides only for modules that successfully required
        local ok, err = pcall(function()
            if FlintLockSuccess then changeBayonet(value) end
            if MeleeBaseSuccess then changeMelee(value) end
        end)

        if not ok then
            -- a runtime error happened while applying overrides -> lock
            HeadHitEnabled = false
            pcall(function()
                if FlintLockSuccess then changeBayonet(false) end
                if MeleeBaseSuccess then changeMelee(false) end
            end)
            notifyErrorAndLock(HeadHitToggle)
            return
        end

        -- success notify (safe)
        pcall(function()
            if WindUI then
                WindUI:Notify({
                    Title = "Aiming",
                    Content = value and "Head Hit enabled" or "Head Hit disabled",
                    Duration = 2,
                    Icon = value and "crosshair" or "crosshair-off",
                })
            end
        end)
    end
})

-- If any require previously failed, lock & notify immediately (module existed but require errored)
if FlintLockRequireFailed or MeleeBaseRequireFailed then
    notifyErrorAndLock(HeadHitToggle)
end

    -- === Jump On Specific Animations (with WindUI Toggle) ===            
    -- === Target Animation IDs ===            
    local TARGET_ANIM_IDS = {            
        "rbxassetid://17406577733",            
        "rbxassetid://15669224658",            
        "rbxassetid://12591948314",            
        "rbxassetid://12333491302",            
    }            
            
    local TARGETS = {}            
    for _, v in ipairs(TARGET_ANIM_IDS) do            
        local id = tostring(v)            
        if id:match("^%d+$") then            
            id = "rbxassetid://" .. id            
        end            
        TARGETS[id] = true            
    end            
            
    -- === Jump logic ===            
    local humanoid, animator            
    local playedTracks = {}            
    local monitoring = false            
            
    local function normalizeAnimId(id)            
        if not id then return nil end            
        local s = tostring(id)            
        if s:match("^%d+$") then            
            return "rbxassetid://" .. s            
        end            
        return s            
    end            
            
    local function trackIsTarget(track)            
        if not track or not track.IsPlaying then return false end            
        local anim = track.Animation            
        if not anim or not anim.AnimationId then return false end            
        local aId = normalizeAnimId(anim.AnimationId)            
        return aId and TARGETS[aId]            
    end            
            
    local function doJump()  
        if not humanoid or not humanoid.Parent then return end  
  
        task.spawn(function()  
            pcall(function()  
                -- Wait until humanoid can jump again  
                local timeout = 1  
                local startTime = os.clock()  
  
                while os.clock() - startTime < timeout do  
                    local state = humanoid:GetState()  
                    if state == Enum.HumanoidStateType.Running  
                        or state == Enum.HumanoidStateType.Landed  
                        or state == Enum.HumanoidStateType.RunningNoPhysics  
                        or state == Enum.HumanoidStateType.Climbing then  
                        break  
                    end  
                    task.wait(0.05)  
                end  
  
                -- === Hardcoded jump simulation ===  
                local root = humanoid.RootPart or humanoid.Parent:FindFirstChild("HumanoidRootPart")  
                if root then  
                    local gravity = workspace.Gravity  
                    local JumpPower = 30  
                    local JumpHeight = 7.199999809265137  
  
                    -- Calculate velocity based on those constants  
                    local jumpVelocity  
                    if humanoid.UseJumpPower then  
                        jumpVelocity = JumpPower  
                    else  
                        jumpVelocity = math.sqrt(2 * gravity * JumpHeight)  
                    end  
  
                    root.Velocity = Vector3.new(root.Velocity.X, jumpVelocity, root.Velocity.Z)  
                end  
            end)  
        end)  
    end  
            
    -- === Monitoring loop ===            
    local function startMonitoring()            
        if monitoring then return end            
        monitoring = true            
        task.spawn(function()            
            while monitoring do            
                if animator then            
                    local ok, tracks = pcall(function()            
                        return animator:GetPlayingAnimationTracks()            
                    end)            
                    if ok and tracks then            
                        for _, track in ipairs(tracks) do            
                            if trackIsTarget(track) and not playedTracks[track] then            
                                playedTracks[track] = true            
                                pcall(doJump)            
                                track.Stopped:Connect(function()            
                                    playedTracks[track] = nil            
                                end)            
                            end            
                        end            
                    end            
                end            
                task.wait(0.08)            
            end            
        end)            
    end            
            
    local function stopMonitoring()            
        monitoring = false            
        playedTracks = {}            
    end            
            
    -- === Character initialization ===  
    local function refreshCharacter(char)  
        humanoid = char and char:FindFirstChildOfClass("Humanoid") or nil  
        animator = nil  
        if humanoid then  
            animator = humanoid:FindFirstChildOfClass("Animator")  
            if not animator then  
                animator = Instance.new("Animator")  
                animator.Name = "AutoAnimator"  
                animator.Parent = humanoid  
            end  
        end  
        playedTracks = {}  
    end  
  
    refreshCharacter(LocalPlayer.Character)  

    -- === Restore toggle state after respawn ===
    local function restoreAutoJump()
        local persisted = false
        pcall(function()
            persisted = LocalPlayer:GetAttribute("AutoJumpEnabled")
        end)
        if persisted then
            task.delay(0.2, startMonitoring)
        end
    end
    restoreAutoJump()

    LocalPlayer.CharacterAdded:Connect(function(ch)  
        -- Wait for character to fully load  
        ch:WaitForChild("Humanoid", 5)  
        ch:WaitForChild("HumanoidRootPart", 5)  
        refreshCharacter(ch)  
        restoreAutoJump()
    end)  
            
    local LegitSection = MainTab:Section({            
        Title = "Legit Thingys",            
        Icon = "shield-check",            
        Opened = false            
    })            
            
    -- === WindUI Toggle Setup ===            
    LegitSection:Toggle({            
        Title = "Auto Jump",            
        Flag = "Legit_AutoJump",
        Desc = "Makes you jump When Thrusting Your Weapon",            
        Default = false,            
        Callback = function(value)            
            pcall(function() LocalPlayer:SetAttribute("AutoJumpEnabled", value) end)
            if value then            
                startMonitoring()            
                WindUI:Notify({            
                    Title = "Jump On Swing",            
                    Content = "Auto Jump Enabled",            
                    Duration = 2,            
                    Icon = "activity",            
                })            
            else            
                stopMonitoring()            
                WindUI:Notify({            
                    Title = "Jump On Swing",            
                    Content = "Auto Jump Disabled",            
                    Duration = 2,            
                    Icon = "activity-off",            
                })            
            end            
        end            
    })
     
local HitboxSection = MainTab:Section({
        Title = "Hitbox",
        Icon = "box",
        Opened = false
    })

-- Hitbox Expander (robust, non-blocking, locks UI on error + notifies)
local hitboxEnabled = false
local hitboxSize = 10

local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")

-- prefer non-blocking find; if missing, use nil and continue
local zombieFolder = Workspace:FindFirstChild("Zombies")
if not zombieFolder then
    warn("Zombies folder not found (non-blocking). Hitbox operations will try Camera fallback.")
end

-- Helper to notify + lock UI widgets safely
local function notifyHitboxErrorAndLock(widgets)
    pcall(function()
        if WindUI then
            WindUI:Notify({
                Title = "Hitbox â€” Error",
                Content = "Hitbox had an error and will be locked.",
                Duration = 4,
                Icon = "alert-circle",
            })
        end
    end)
    -- lock all provided widgets (toggle + sliders)
    pcall(function()
        for _, w in ipairs(widgets or {}) do
            if w and type(w.Lock) == "function" then
                w:Lock()
            end
        end
    end)
end

-- safe create hitbox part
local function safeCreateHitbox(parent, name, size, attachPart)
    local ok, err = pcall(function()
        if not parent or not parent.Parent then return end
        local part = Instance.new("Part")
        part.Name = name
        part.Size = Vector3.new(size, size, size)
        part.Transparency = 1
        part.Anchored = false
        part.CanCollide = false
        part.Massless = true
        part.CanTouch = true
        part.CFrame = attachPart.CFrame
        part.Parent = parent

        local weld = Instance.new("WeldConstraint")
        weld.Part0 = attachPart
        weld.Part1 = part
        weld.Parent = part
    end)
    return ok, err
end

local function addOuterHitbox(zombie)
    if not zombie or not zombie.Parent then return end
    local hrp = zombie:FindFirstChild("HumanoidRootPart")
    if hrp and not zombie:FindFirstChild("OuterHitbox") then
        local ok, err = safeCreateHitbox(zombie, "OuterHitbox", hitboxSize, hrp)
        if not ok then
            warn("Failed to create OuterHitbox:", err)
            return false, err
        end
    end
    return true
end

local function addHeadHitbox(zombie)
    if not zombie or not zombie.Parent then return end
    local head = zombie:FindFirstChild("Head")
    if head and not zombie:FindFirstChild("HeadHitbox") then
        local ok, err = safeCreateHitbox(zombie, "HeadHitbox", hitboxSize/2, head)
        if not ok then
            warn("Failed to create HeadHitbox:", err)
            return false, err
        end
    end
    return true
end

local function removeHitboxes(zombie)
    if not zombie then return end
    pcall(function()
        local outer = zombie:FindFirstChild("OuterHitbox")
        local head = zombie:FindFirstChild("HeadHitbox")
        if outer then outer:Destroy() end
        if head then head:Destroy() end
    end)
end

local function updateHitboxes(zombie)
    if not zombie then return end
    if hitboxEnabled then
        -- remove old then create new; use pcall to catch errors
        local ok, err = pcall(function()
            removeHitboxes(zombie)
            task.wait(0.05)
            addOuterHitbox(zombie)
            addHeadHitbox(zombie)
        end)
        if not ok then
            return false, err
        end
    else
        removeHitboxes(zombie)
    end
    return true
end

local function setHitboxSize(newSize, widgetsToLock)
    hitboxSize = newSize
    if hitboxEnabled then
        local ok, err = pcall(function()
            -- Attempt on zombieFolder if exists
            if zombieFolder then
                for _, zombie in pairs(zombieFolder:GetChildren()) do
                    updateHitboxes(zombie)
                end
            end
            -- Camera fallback (some maps put m_Zombie under Camera)
            if Workspace:FindFirstChild("Camera") then
                for _, zombie in pairs(Workspace.Camera:GetChildren()) do
                    if zombie.Name == "m_Zombie" then
                        updateHitboxes(zombie)
                    end
                end
            end
        end)
        if not ok then
            warn("setHitboxSize encountered an error:", err)
            notifyHitboxErrorAndLock(widgetsToLock)
        end
    end
end

local function toggleHitboxExpander(enabled, widgetsToLock)
    hitboxEnabled = enabled

    local ok, err = pcall(function()
        if zombieFolder then
            for _, zombie in pairs(zombieFolder:GetChildren()) do
                updateHitboxes(zombie)
            end
        end
        if Workspace:FindFirstChild("Camera") then
            for _, zombie in pairs(Workspace.Camera:GetChildren()) do
                if zombie.Name == "m_Zombie" then
                    updateHitboxes(zombie)
                end
            end
        end
    end)

    if not ok then
        warn("toggleHitboxExpander encountered an error:", err)
        -- rollback logical state
        hitboxEnabled = false
        -- remove any partial hitboxes
        pcall(function()
            if zombieFolder then
                for _, z in pairs(zombieFolder:GetChildren()) do removeHitboxes(z) end
            end
        end)
        notifyHitboxErrorAndLock(widgetsToLock)
    end
end

-- auto-apply to new zombies (guards to ensure no yield)
if zombieFolder then
    zombieFolder.ChildAdded:Connect(function(zombie)
        if hitboxEnabled then
            task.wait(0.2)
            pcall(function() updateHitboxes(zombie) end)
        end
    end)
end

-- Camera fallback connection (non-blocking)
if Workspace:FindFirstChild("Camera") then
    Workspace.Camera.ChildAdded:Connect(function(zombie)
        if zombie.Name == "m_Zombie" and hitboxEnabled then
            task.wait(0.2)
            pcall(function() updateHitboxes(zombie) end)
        end
    end)
end

-- Keep references to UI widgets so we can lock them on errors
local toggleWidgetRef
local sliderSizeWidgetRef
local sliderRangeWidgetRef

-- Create toggle (capture reference)
toggleWidgetRef = HitboxSection:Toggle({
    Title = "Hitbox Expander",
    Flag = "Hitbox_HitboxExpander",
    Desc = "Expands zombie hitboxes for easier hits.",
    Default = false,
    Callback = function(value)
        -- pass the UI widgets list so errors lock them
        toggleHitboxExpander(value, { toggleWidgetRef, sliderSizeWidgetRef, sliderRangeWidgetRef })
        pcall(function()
            if WindUI then
                WindUI:Notify({
                    Title = "Hitbox",
                    Content = value and "Hitbox Expander enabled" or "Hitbox Expander disabled",
                    Duration = 2,
                    Icon = value and "scan" or "scan-line",
                })
            end
        end)
    end
})

-- Slider: Hitbox Size (capture reference)
sliderSizeWidgetRef = HitboxSection:Slider({
    Title = "Hitbox Zombie Size",
    Flag = "Hitbox_HitboxSize",
    Step = 1,
    Value = {
        Min = 1,
        Max = 30,
        Default = hitboxSize,
    },
    Callback = function(value)
        -- pass widgets so setHitboxSize can lock them on error
        setHitboxSize(value, { toggleWidgetRef, sliderSizeWidgetRef, sliderRangeWidgetRef })
    end
})

-- Slider: Hitbox Range (capture reference)
sliderRangeWidgetRef = HitboxSection:Slider({
    Title = "Hitbox Zombie Range",
    Flag = "Hitbox_HitboxRange",
    Step = 1,
    Value = {
        Min = 0,
        Max = 30,
        Default = MaxRange or 30,
    },
    Callback = function(value)
        -- just set MaxRange; if you need errors to lock, call notifyHitboxErrorAndLock
        local ok, err = pcall(function()
            MaxRange = value
        end)
        if not ok then
            warn("Setting MaxRange failed:", err)
            notifyHitboxErrorAndLock({ toggleWidgetRef, sliderSizeWidgetRef, sliderRangeWidgetRef })
        end
    end
})

-- If initial state is broken (e.g., Camera and Zombies missing), lock UI immediately and notify
local cameraExists = Workspace:FindFirstChild("Camera") ~= nil
if (not zombieFolder) and (not cameraExists) then
    warn("No Zombies folder and no Camera fallback found â€” Hitbox feature locked.")
    notifyHitboxErrorAndLock({ toggleWidgetRef, sliderSizeWidgetRef, sliderRangeWidgetRef })
end

    -- Cleanup function  
    local function cleanup()  
        changeBayonet(false)  
        changeMelee(false)  
        AutoHeadEnabled = false  
        LastHitTime = {}  
        IsIgniter = {}  
        Remote = nil  
    end  
  
    _G.KatchiHeadHitCleanup = cleanup

-- Auto Universal Gun Aim â€” IMPROVED: multi-type selection, movement-based time-shots,
-- dynamic retargeting if obstructed/died, and preserves previous features (reload, wall checks, save players)
-- + FOV FEATURE + TARGET ESP (yellow chams)
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local StarterGui = game:GetService("StarterGui")
local UserInputService = game:GetService("UserInputService")
local GuiService = game:GetService("GuiService")
local LocalPlayer = Players.LocalPlayer
-- === CONFIG (core timings) ===
local LOOK_DURATION = 0.28
local MAX_TARGET_RANGE = 200
local FIRE_DELAY_AFTER_LOOK = 0.03
local CHECK_INTERVAL = 0.12
local APPEAR_DELAY_DEFAULT = 0.5
local APPEAR_DELAY = APPEAR_DELAY_DEFAULT
-- UI-exposed toggles (defaults)
local CHECK_WALLS = true
local AUTO_RELOAD_ENABLED = false
local USER_AUTO_SHOOT_TOGGLE = false
-- Instant shoot toggle
local INSTANT_SHOOT_ENABLED = false
-- Auto Save Players settings
local AUTO_SAVE_PLAYERS_ENABLED = false
local MAX_SAVE_PLAYERS_RANGE = MAX_TARGET_RANGE
local INSTANT_SAVE_PLAYERS_ENABLED = false
-- Save player delay slider
local SAVE_PLAYER_DELAY = 0.5
local PREDICTION_DISTANCE = 0 -- seconds to lead target positions (set via UI)
local PREDICTION_MIN_SPEED = 2 -- studs/sec; below this we treat targets as stationary
local PREDICTION_STILLNESS_WINDOW = 0.4 -- seconds of low movement before treating as stationary
-- Wall check thresholds
local WALL_CHECK_TRANSPARENCY_THRESHOLD = 0.95
local WALL_CHECK_SAMPLE_AXIS_SCALE = 0.35 -- percentage of part size to offset LOS samples by
local WALL_CHECK_MIN_SAMPLE_OFFSET = 0.4 -- studs; prevents offsets from collapsing on tiny parts
local WALL_CHECK_MAX_SAMPLE_OFFSET = 2.75 -- studs; avoids overextending samples into other cover
local WALL_CHECK_REQUIRED_CLEAR_RATIO = 0.6 -- at least this fraction of samples must be unobstructed
local EPS = 1e-4
-- State management
local isAiming = false
local watchedTools = {}
local activeConnections = {}
local characterAddedConn = nil
local reloadInProgress = {}  -- Track which tools are currently reloading
-- Shooting type selection state (multi-select)
local ShootTypeList = { "Bomber", "Cuirassier", "Runner", "Zapper", "Igniter", "Shambler" }
local SelectedShootTypes = {} -- array of strings selected in UI
local EnabledShootTypes = {} -- toggled enabled per selected type (keeps parity with UI)
for _, t in ipairs(ShootTypeList) do EnabledShootTypes[t] = false end
local getPredictedAimPosition -- forward declaration
local getAimPosition -- forward declaration
local PartVelocityCache = setmetatable({}, { __mode = "k" })
local function getHistoricalVelocity(part)
    if not part or not part.Parent then return nil end
    local now = os.clock()
    local pos = part.Position
    local entry = PartVelocityCache[part]
    if entry then
        local dt = math.max(now - entry.time, EPS)
        if dt < (1 / 240) then
            return entry.vel
        end
        local vel = (pos - entry.pos) / dt
        entry.pos = pos
        entry.time = now
        entry.vel = vel
        entry.lastSpeed = vel.Magnitude
        if entry.lastSpeed >= PREDICTION_MIN_SPEED then
            entry.lastMoveTime = now
        end
        return vel
    else
        PartVelocityCache[part] = {
            pos = pos,
            time = now,
            vel = Vector3.new(0, 0, 0),
            lastSpeed = 0,
            lastMoveTime = nil,
        }
    end
    return nil
end

local function hasRecentMovement(part)
    local entry = PartVelocityCache[part]
    if not entry or not entry.lastMoveTime then
        return false
    end
    return (os.clock() - entry.lastMoveTime) <= PREDICTION_STILLNESS_WINDOW
end
local function getModelVelocityFromPart(part)
    if not part then return nil end
    local model = part:FindFirstAncestorWhichIsA("Model")
    if not model then return nil end
    local root = model:FindFirstChild("HumanoidRootPart")
        or model:FindFirstChild("Torso")
        or model:FindFirstChild("UpperTorso")
        or model.PrimaryPart
    if root and root:IsA("BasePart") then
        local vel = root.AssemblyLinearVelocity or Vector3.new(0, 0, 0)
        if vel.Magnitude > EPS then
            return vel
        end
    end
    return nil
end

-- ===== FOV SETTINGS =====
local USE_FOV = false      -- "Use Fov" toggle
local SHOW_FOV = false     -- "Show Fov" toggle
local MOBILE_FOV = false   -- "Mobile Fov" toggle (centered) / off = follow cursor

local FOV_SIZE_DEG = 50 -- default FOV angle in degrees
local FOV_MIN_DEG, FOV_MAX_DEG = 10, 120

local fovGui = nil
local fovCircle = nil
local fovUpdateConn = nil

local function ensureFovGui()
    if fovGui and fovGui.Parent then
        return fovGui, fovCircle
    end

    local pg
    if type(getPlayerGui) == "function" then
        pg = getPlayerGui()
    else
        pg = LocalPlayer:FindFirstChild("PlayerGui") or LocalPlayer:WaitForChild("PlayerGui")
    end

    fovGui = Instance.new("ScreenGui")
    fovGui.Name = "AutoShoot_FovGui"
    fovGui.ResetOnSpawn = false
    fovGui.Parent = pg

    local circle = Instance.new("Frame")
    circle.Name = "Circle"
    circle.AnchorPoint = Vector2.new(0.5, 0.5)
    circle.Position = UDim2.new(0.5, 0, 0.5, 0)
    circle.BackgroundTransparency = 1 -- no fill
    circle.BorderSizePixel = 0
    circle.Parent = fovGui

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(1, 0)
    corner.Parent = circle

    local stroke = Instance.new("UIStroke")
    stroke.Thickness = 2
    stroke.Color = Color3.fromRGB(255, 255, 0)
    stroke.Transparency = 0.2
    stroke.Parent = circle

    fovCircle = circle
    return fovGui, fovCircle
end

local function getFovScreenCenter()
    local cam = Workspace.CurrentCamera
    if not cam then
        return Vector2.new(0, 0)
    end

    local viewportSize = cam.ViewportSize

    -- If MOBILE FOV is on OR mouse is locked (ShiftLock / right-click lock),
    -- use the center of the screen
    if MOBILE_FOV or UserInputService.MouseBehavior == Enum.MouseBehavior.LockCenter then
        return Vector2.new(viewportSize.X / 2, viewportSize.Y / 2)
    end

    -- Otherwise, use the real mouse position, adjusted for GUI inset
    local mousePos = UserInputService:GetMouseLocation()
    local inset = GuiService:GetGuiInset()

    -- mousePos includes the top bar; ViewportPoint uses inset-removed coords.
    -- So we subtract inset to get into the same space as ViewportPoint.
    return mousePos - Vector2.new(inset.X, inset.Y)
end

local function ensureFovUpdateLoop()
    if fovUpdateConn then return end

    fovUpdateConn = RunService.RenderStepped:Connect(function()
        if not (USE_FOV and SHOW_FOV) then
            if fovGui then fovGui.Enabled = false end
            return
        end

        local gui, circle = ensureFovGui()
        gui.Enabled = true

        local cam = Workspace.CurrentCamera
        if not cam then return end

        -- size in pixels (same mapping as before: 40Â° -> 250px)
        local clamped = math.clamp(FOV_SIZE_DEG, FOV_MIN_DEG, FOV_MAX_DEG)
        local sizePx = math.floor((clamped / 40) * 250)
        circle.Size = UDim2.new(0, sizePx, 0, sizePx)

        -- center position using unified helper (handles mobile + shiftlock + inset)
        local viewportSize = cam.ViewportSize
        local centerVec = getFovScreenCenter()

        local xScale = centerVec.X / viewportSize.X
        local yScale = centerVec.Y / viewportSize.Y

        circle.Position = UDim2.new(xScale, 0, yScale, 0)
    end)
end

local function updateFovCircle()
    if not (USE_FOV and SHOW_FOV) then
        if fovGui then fovGui.Enabled = false end
        return
    end
    -- make sure the render-stepped loop is running
    ensureFovUpdateLoop()
end

-- FOV check that matches the circle on screen (pixel-based)
local function isWorldPosInFov(worldPos)
    if not USE_FOV then return true end

    local cam = Workspace.CurrentCamera
    if not cam then return true end

    local viewportSize = cam.ViewportSize
    if not viewportSize or viewportSize.X <= 0 or viewportSize.Y <= 0 then
        return true
    end

    local screenPos, onScreen = cam:WorldToViewportPoint(worldPos)
    if not onScreen then
        -- if it's behind us / off screen, just treat as outside FOV
        return false
    end

    -- same center used as the circle
    local centerVec = getFovScreenCenter()
    local dist = (Vector2.new(screenPos.X, screenPos.Y) - centerVec).Magnitude

    local clamped = math.clamp(FOV_SIZE_DEG, FOV_MIN_DEG, FOV_MAX_DEG)
    local sizePx = (clamped / 40) * 250
    local radius = sizePx / 2

    return dist <= radius
end
-- ===== TARGET VISUALS (TARGET ESP) =====
local TARGET_ESP_ENABLED = false

local activeAimModel = nil
local activeAimPart = nil
local activeHighlight = nil -- Highlight instance for target esp

local TARGET_CHAMS_TRANSPARENCY = 0.4
local TARGET_CHAMS_COLOR = Color3.fromRGB(255, 220, 50) -- yellow
local function clearActiveTargetVisuals()
    activeAimModel = nil
    activeAimPart = nil
    if activeHighlight then
        pcall(function() activeHighlight:Destroy() end)
        activeHighlight = nil
    end
end
local function createTargetHighlight(model)
    if not model or not model.Parent then return nil end
    if activeHighlight then
        pcall(function() activeHighlight:Destroy() end)
        activeHighlight = nil
    end
    local hl = Instance.new("Highlight")
    hl.Name = "AutoTargetHighlight"
    hl.Adornee = model
    hl.Parent = model
    hl.FillColor = TARGET_CHAMS_COLOR
    hl.OutlineColor = Color3.fromRGB(255, 255, 255)
    hl.FillTransparency = math.clamp(TARGET_CHAMS_TRANSPARENCY, 0, 1)
    hl.OutlineTransparency = 0
    activeHighlight = hl
    return hl
end
local function updateActiveTargetVisuals(model, part)
    if not model or not part then
        clearActiveTargetVisuals()
        return
    end
    -- same target: just ensure state matches toggles
    if activeAimModel == model and activeAimPart == part then
        if TARGET_ESP_ENABLED and not activeHighlight then
            pcall(function() createTargetHighlight(model) end)
        end
        return
    end
    -- new target
    clearActiveTargetVisuals()
    activeAimModel = model
    activeAimPart = part
    if TARGET_ESP_ENABLED then
        pcall(function() createTargetHighlight(model) end)
    end
end

-- Notification helper
local lastReloadNotify = 0
local NOTIFY_COOLDOWN = 4
local function notifyReload()
    local now = tick()
    if now - lastReloadNotify < NOTIFY_COOLDOWN then return end
    lastReloadNotify = now
    pcall(function()
        if type(WindUI) == "table" and type(WindUI.Notify) == "function" then
            pcall(function()
                WindUI:Notify({ Title = "Auto Reload", Content = "A Round Has Been Reloaded.", Duration = 3, Icon = "refresh-cw" })
            end)
            return
        end
        pcall(function()
            StarterGui:SetCore("SendNotification", { Title = "Auto Reload"; Text = "A Round Has Been Reloaded."; Duration = 3; })
        end)
    end)
end
-- Helper: is this tool a gun?
local function isGun(tool)
    if not tool or not tool:IsA("Tool") then return false end
    local animFolder = tool:FindFirstChild("Animations")
    if not animFolder then return false end
    if animFolder:FindFirstChild("Aim") then return true end
    if animFolder:FindFirstChild("Aiming") then return true end
    return false
end
-- Utility: build a base ignore list for raycasts (players and camera zombies)
local function buildBaseIgnore()
    local baseIgnore = {}
    for _, pl in ipairs(Players:GetPlayers()) do
        local ch = pl.Character
        if ch and ch:IsA("Model") then table.insert(baseIgnore, ch) end
    end
    local camFolderInst = Workspace:FindFirstChild("Camera")
    if camFolderInst then
        for _, d in ipairs(camFolderInst:GetDescendants()) do
            if d and d:IsA("Model") and d.Name == "m_Zombie" then table.insert(baseIgnore, d) end
        end
    end
    return baseIgnore
end

local function getWallCheckOrigin()
    if LocalPlayer and LocalPlayer.Character and LocalPlayer.Character.Parent then
        local head = LocalPlayer.Character:FindFirstChild("Head")
        if head and head:IsA("BasePart") then
            return head.Position
        end
    end
    local cam = Workspace.CurrentCamera
    if cam then
        return cam.CFrame.Position
    end
    return nil
end
-- NEW: stricter, whitelist-aware obstruction check.
-- Returns true => obstructed; false => not obstructed.
local function isObstructedBetweenIterative(origin, targetPos, targetModel, baseIgnore)
    if not CHECK_WALLS then return false end
    if not targetPos then return false end
    
    -- Always use player's head as the origin for wall checks (more accurate detection)
    local actualOrigin = origin
    if LocalPlayer and LocalPlayer.Character then
        local head = LocalPlayer.Character:FindFirstChild("Head")
        if head and head:IsA("BasePart") then
            actualOrigin = head.Position
        end
    end
    
    if not actualOrigin then return false end
    
    local dir = targetPos - actualOrigin
    local dist = dir.Magnitude
    if dist <= 0 then return false end
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    local filter = {}
    if baseIgnore then
        for i = 1, #baseIgnore do filter[#filter + 1] = baseIgnore[i] end
    end
    -- always ignore the local player's character so we don't accidentally hit ourselves
    if LocalPlayer and LocalPlayer.Character then table.insert(filter, LocalPlayer.Character) end
    params.FilterDescendantsInstances = filter
    local maxIterations = 16
    local remainingDistance = dist
    local originPos = actualOrigin
    local dirUnit = dir.Unit
    local epsilon = 0.25
    for i = 1, maxIterations do
        local ok, result = pcall(function()
            return Workspace:Raycast(originPos, dirUnit * remainingDistance, params)
        end)
        -- If raycast failed or no hit -> clear line of sight
        if not ok or not result then
            return false
        end
        local hitInst = result.Instance
        if not hitInst then return false end
        -- If the part belongs to the targetModel, treat as clear
        if targetModel and hitInst:IsDescendantOf(targetModel) then
            return false
        end
        -- Whitelist: transparent or non-collidable parts are ignored
        local isBasePart = hitInst:IsA("BasePart")
        local transparency = isBasePart and hitInst.Transparency or 0
        local canCollide = isBasePart and hitInst.CanCollide
        local effectiveInvisible = (isBasePart and transparency >= WALL_CHECK_TRANSPARENCY_THRESHOLD)
        local nonBlocking = false
        -- If part is non-collidable or effectively invisible, ignore it
        if isBasePart and (not canCollide or effectiveInvisible) then nonBlocking = true end
        -- If part belongs to a player model or camera m_Zombie but is not the target, ignore it
        local ancestor = hitInst
        while ancestor and ancestor.Parent do
            if ancestor:IsA("Model") and (ancestor.Name == "m_Zombie") then
                nonBlocking = true; break
            end
            ancestor = ancestor.Parent
        end
        -- If hit is part of any Player character (not the target) we consider it non-blocking for aim checks
        for _, pl in ipairs(Players:GetPlayers()) do
            local ch = pl.Character
            if ch and hitInst:IsDescendantOf(ch) then nonBlocking = true; break end
        end
        if nonBlocking then
            -- add this instance to the filter and continue the ray
            table.insert(params.FilterDescendantsInstances, hitInst)
            local advancePos = result.Position + dirUnit * epsilon
            if (advancePos - actualOrigin).Magnitude >= dist - EPS then return false end
            originPos = advancePos
            remainingDistance = (targetPos - originPos).Magnitude
            -- loop continues to next iteration
        else
            -- this is a blocking object
            return true
        end
    end
    -- conservative: assume obstructed if we reached iteration limit
    return true
end

-- Helper: sample multiple positions around the aim part so we only fire when most of the part is visible.
local function getWallCheckSamplePositions(part, aimPosOverride)
    if not part or not part.Parent then return {} end
    local basePos = aimPosOverride or part.Position
    local cf = part.CFrame
    local size = part.Size or Vector3.new(1, 1, 1)
    local function axisOffset(component)
        local scaled = component * WALL_CHECK_SAMPLE_AXIS_SCALE
        if scaled < WALL_CHECK_MIN_SAMPLE_OFFSET then
            scaled = WALL_CHECK_MIN_SAMPLE_OFFSET
        end
        if scaled > WALL_CHECK_MAX_SAMPLE_OFFSET then
            scaled = WALL_CHECK_MAX_SAMPLE_OFFSET
        end
        return scaled
    end
    local xOff = axisOffset(size.X)
    local yOff = axisOffset(size.Y)
    local zOff = axisOffset(size.Z)
    local offsets = {
        Vector3.new(0, 0, 0),
        Vector3.new(0, yOff, 0),
        Vector3.new(0, -yOff, 0),
        Vector3.new(xOff, 0, 0),
        Vector3.new(-xOff, 0, 0),
        Vector3.new(0, 0, zOff),
        Vector3.new(0, 0, -zOff)
    }
    local samples = {}
    for _, offset in ipairs(offsets) do
        local worldOffset = cf:VectorToWorldSpace(offset)
        samples[#samples + 1] = basePos + worldOffset
    end
    return samples
end

local function hasClearShotOnPart(originPos, aimPart, targetModel, baseIgnore, aimPosOverride)
    if not CHECK_WALLS then return true end
    if not originPos or not aimPart or not aimPart.Parent then return false end
    local samples = getWallCheckSamplePositions(aimPart, aimPosOverride)
    if #samples == 0 then return false end
    local requiredClear = math.max(1, math.ceil(#samples * WALL_CHECK_REQUIRED_CLEAR_RATIO))
    local clearCount = 0
    for _, samplePos in ipairs(samples) do
        local obstructed = isObstructedBetweenIterative(originPos, samplePos, targetModel, baseIgnore)
        if not obstructed then
            clearCount = clearCount + 1
            if clearCount >= requiredClear then
                return true
            end
        end
    end
    return false
end
-- (Timing helper removed; prediction slider handles movement compensation)
-- Helper: get adornee/aim part from zombie model.
-- Uses global GetAdorneePart if present (from ESP script). Falls back to Barrel/Head/Torso
local function findBestAimPart(zombie)
    if not zombie or not zombie.Parent then return nil end
    -- Prefer your ESP helper, if it exists
    if type(GetAdorneePart) == "function" then
        local ok, res = pcall(function()
            return GetAdorneePart(zombie)
        end)
        if ok and res and typeof(res) == "Instance" and res:IsA("BasePart") then
            return res
        end
    end
    -- Fallback ordering: Barrel â†’ Head â†’ Torso/UpperTorso/HRP â†’ PrimaryPart â†’ any BasePart
    local barrel = zombie:FindFirstChild("Barrel", true)
    if barrel and barrel:IsA("BasePart") then return barrel end
    local head = zombie:FindFirstChild("Head", true)
    if head and head:IsA("BasePart") then return head end
    local torso = zombie:FindFirstChild("Torso")
        or zombie:FindFirstChild("UpperTorso")
        or zombie:FindFirstChild("HumanoidRootPart")
    if torso and torso:IsA("BasePart") then return torso end
    if zombie.PrimaryPart and zombie.PrimaryPart:IsA("BasePart") then
        return zombie.PrimaryPart
    end
    for _, p in ipairs(zombie:GetDescendants()) do
        if p:IsA("BasePart") then
            return p
        end
    end
    return nil
end
getPredictedAimPosition = function(part)
    if not part or not part.Parent or not part:IsA("BasePart") then return nil end
    local position = part.Position
    local leadTime = tonumber(PREDICTION_DISTANCE) or 0
    if leadTime <= EPS then
        return position
    end
    local vel = part.AssemblyLinearVelocity or Vector3.new(0, 0, 0)
    local historical = getHistoricalVelocity(part)
    local recentlyMoving = hasRecentMovement(part)
    local entry = PartVelocityCache[part]
    local function isValidVelocity(v)
        return v and v.Magnitude >= PREDICTION_MIN_SPEED
    end
    if not isValidVelocity(vel) then
        local fallback = getModelVelocityFromPart(part)
        if isValidVelocity(fallback) then
            vel = fallback
        end
    end
    if not isValidVelocity(vel) and isValidVelocity(historical) then
        vel = historical
    end
    local movingNow = isValidVelocity(vel)
    if movingNow and entry then
        entry.lastSpeed = vel.Magnitude
        entry.lastMoveTime = os.clock()
    end
    if not movingNow and not recentlyMoving then
        return position
    end
    return position + vel * leadTime
end

local function getAimPosition(part, opts)
    if not part or not part.Parent or not part:IsA("BasePart") then return nil end
    opts = opts or {}
    if opts.skipPrediction then
        return part.Position
    end
    return getPredictedAimPosition(part) or part.Position
end
-- Helper: resolve zombie type from new agent folders/attributes or slim folder
local function GetZombieTypeFromModel(model)
    if not model or not model:IsA("Model") then return nil end
    -- Cuirassier: any model under Zombies.Slim
    local parent = model.Parent
    if parent and parent.Name == "Slim" and parent.Parent and parent.Parent.Name == "Zombies" then
        return "Cuirassier"
    end
    -- Agent types: map attribute Type to canonical names
    if parent and parent.Name == "Agent" and parent.Parent and parent.Parent.Name == "Zombies" then
        local t = nil
        if typeof(model.GetAttribute) == "function" then
            t = model:GetAttribute("Type")
        end
        if not t then
            local typeValue = model:FindFirstChild("Type")
            if typeValue and typeValue:IsA("StringValue") then
                t = typeValue.Value
            end
        end
        if type(t) == "string" then
            local lower = string.lower(t)
            if lower == "normal" then return "Shambler" end
            if lower == "barrel" then return "Bomber" end
            if lower == "fast" then return "Runner" end
            if lower == "sapper" then return "Zapper" end
            if lower == "igniter" then return "Igniter" end
        end
    end
    return nil
end
-- Helper: check if model matches a given typeName using ESPConfigs.match if available
local function isZombieOfType(model, typeName)
    if not model or not model:IsA("Model") then return false end
    if type(typeName) ~= "string" then return false end
    -- Prefer new agent/slim mapping if available
    local mappedType = GetZombieTypeFromModel(model)
    if mappedType and mappedType == typeName then
        return true
    elseif mappedType and mappedType ~= typeName then
        return false
    end
    -- Prefer ESPConfigs[type].match if it exists
    if type(ESPConfigs) == "table" and ESPConfigs[typeName] and type(ESPConfigs[typeName].match) == "function" then
        local ok, res = pcall(function()
            return ESPConfigs[typeName].match(model)
        end)
        return ok and not not res
    end
    -- Fallback heuristics:
    if typeName == "Bomber" then
        return model:FindFirstChild("Barrel", true) ~= nil
    end
    if typeName == "Cuirassier" then
        return model:FindFirstChild("Sword", true) ~= nil
    end
    if typeName == "Runner" then
        return model:FindFirstChild("Eye", true)
        and not model:FindFirstChild("Axe", true)
        and model:FindFirstChild("Head", true)
    end
    if typeName == "Zapper" then
        return model:FindFirstChild("Axe", true)
        and model:FindFirstChild("Head", true)
    end
    if typeName == "Igniter" then
        return model:FindFirstChild("Whale Oil Lantern", true) ~= nil
    end
    if typeName == "Shambler" then
        return model.Name == "m_Zombie"
        and not model:FindFirstChild("Barrel", true)
        and not model:FindFirstChild("Sword", true)
        and not model:FindFirstChild("Eye", true)
        and not model:FindFirstChild("Axe", true)
        and not model:FindFirstChild("Whale Oil Lantern", true)
    end
    return false
end
-- Get nearest zombie among selected types; returns aimPart, zombieModel, typeName
local function getNearestSelectedZombie(range)
    range = range or MAX_TARGET_RANGE
    local cam = Workspace.CurrentCamera
    local originPos
    if LocalPlayer and LocalPlayer.Character and LocalPlayer.Character.Parent then
        local head = LocalPlayer.Character:FindFirstChild("Head")
        if head and head:IsA("BasePart") then
            originPos = head.Position
        end
    end
    if not originPos and cam then
        originPos = cam.CFrame.Position
    end
    if not originPos then
        return nil, nil, nil
    end
    local baseIgnore = buildBaseIgnore()
    local bestPart, bestDist, bestModel, bestType = nil, range + EPS, nil, nil
    local camFolder = Workspace:FindFirstChild("Camera")
    if not camFolder then
        return nil, nil, nil
    end
    -- build a selected types lookup
    local sel = {}
    for _, t in ipairs(SelectedShootTypes or {}) do
        sel[t] = true
    end
    if not next(sel) then
        return nil, nil, nil
    end
    for _, model in ipairs(camFolder:GetChildren()) do
        if model:IsA("Model") and model.Name == "m_Zombie" then
            -- check type membership
            local matchedType = nil
            for typeName, _ in pairs(sel) do
                if isZombieOfType(model, typeName) then
                    matchedType = typeName
                    break
                end
            end
            if matchedType then
                -- find aim part
                local aimPart = findBestAimPart(model)
                if aimPart and aimPart:IsA("BasePart") then
                    local aimPos = getAimPosition(aimPart)
                    -- FOV filter: only consider zombies inside the cone (if enabled)
                    local passedFovCheck = true
                    if USE_FOV then
                        local okFov, inFov = pcall(function()
                            return isWorldPosInFov(aimPos)
                        end)
                        if not okFov or not inFov then
                            passedFovCheck = false
                        end
                    end
                    if passedFovCheck then
                        local okDist, d = pcall(function()
                            return (aimPos - originPos).Magnitude
                        end)
                        if okDist and d and d <= range + EPS and d < bestDist then
                            -- visibility check (majority of aim part must be exposed)
                            local okVis, hasClear = pcall(function()
                                return hasClearShotOnPart(originPos, aimPart, model, baseIgnore)
                            end)
                            if okVis and hasClear then
                                bestPart, bestDist, bestModel, bestType = aimPart, d, model, matchedType
                            end
                        end
                    end
                end
            end
        end
    end
    return bestPart, bestModel, bestType
end

-- Get nearest zombie Torso to a visible player that needs saving
-- RETURNS: zombieTorso, zombieModel, targetPlayer
local function getNearestZombieToSavePlayer(range)
    -- (unchanged from original)
    local cam = Workspace.CurrentCamera
    local originPos
    if LocalPlayer and LocalPlayer.Character and LocalPlayer.Character.Parent then
        local head = LocalPlayer.Character:FindFirstChild("Head")
        if head and head:IsA("BasePart") then
            originPos = head.Position
        end
    end
    if not originPos and cam then
        originPos = cam.CFrame.Position
    end
    if not originPos then
        return nil, nil, nil
    end
    local wsPlayersFolder = Workspace:FindFirstChild("Players")
    local camFolder = Workspace:FindFirstChild("Camera")
    if not wsPlayersFolder or not camFolder then
        return nil, nil, nil
    end
    local baseIgnore = buildBaseIgnore()
    local bestZombieTorso, bestZombieModel, bestPlayer, bestDist = nil, nil, nil, range + EPS
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local playerFolder = wsPlayersFolder:FindFirstChild(player.Name)
            if playerFolder then
                local userStates = playerFolder:FindFirstChild("UserStates")
                if userStates then
                    local grabbedVal = userStates:FindFirstChild("Grabbed")
                    local pinVal = userStates:FindFirstChild("Pin")
                    local grabbed = (grabbedVal and tonumber(grabbedVal.Value) or 0) ~= 0
                    local pinnedVal = (pinVal and pinVal.Value) or ""
                    local pinned = pinnedVal == "RunnerAttack" or pinnedVal == "RunnerClaw" or pinnedVal == "RunnerVomit"
                    if grabbed or pinned then
                        -- skip players whose humanoid health is below 1 (i.e. dead/downed)
                        local character = player.Character
                        local humanoid = character and character:FindFirstChildOfClass("Humanoid")
                        if humanoid and humanoid.Health >= 1 then
                            -- proceed only for players that are alive (health >= 1)
                            if character and character:IsA("Model") then
                                local playerRoot = character:FindFirstChild("HumanoidRootPart")
                                if playerRoot and playerRoot:IsA("BasePart") then
                                    local hasClearToPlayer = hasClearShotOnPart(originPos, playerRoot, character, baseIgnore)
                                    if hasClearToPlayer then
                                        for _, model in ipairs(camFolder:GetChildren()) do
                                            if model:IsA("Model") and model.Name == "m_Zombie" then
                                                local zombieTorso = model:FindFirstChild("Torso") or model:FindFirstChild("UpperTorso")
                                                if zombieTorso and zombieTorso:IsA("BasePart") then
                                                    local zombiePos = getAimPosition(zombieTorso, { skipPrediction = true })
                                                    local okDist, d = pcall(function()
                                                        return (zombiePos - playerRoot.Position).Magnitude
                                                    end)
                                                    if okDist and d and d <= range + EPS and d < bestDist then
                                                        local hasClearToZombie = hasClearShotOnPart(originPos, zombieTorso, model, baseIgnore)
                                                        if hasClearToZombie then
                                                            bestZombieTorso = zombieTorso
                                                            bestZombieModel = model
                                                            bestPlayer = player
                                                            bestDist = d
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    return bestZombieTorso, bestZombieModel, bestPlayer
end
-- ShotsLoaded helper, findRemote, reload/watch functions (unchanged)
local function getShotsLoadedForTool(tool)
    if not tool then return 0 end
    local s = tool:FindFirstChild("ShotsLoaded")
    if s and (s:IsA("IntValue") or s:IsA("NumberValue")) then return s.Value end
    local wsPlayersFolder = Workspace:FindFirstChild("Players")
    if not wsPlayersFolder then return 0 end
    local playerFolder = wsPlayersFolder:FindFirstChild(LocalPlayer.Name)
    if not playerFolder then return 0 end
    local toolFolder = playerFolder:FindFirstChild(tool.Name)
    if not toolFolder then return 0 end
    local shots = toolFolder:FindFirstChild("ShotsLoaded")
    if shots and (shots:IsA("IntValue") or shots:IsA("NumberValue")) then return shots.Value end
    return 0
end
local function findRemoteForTool(tool)
    if not tool then return nil end
    local remote = tool:FindFirstChild("RemoteEvent")
    if remote then return remote end
    local wsPlayersFolder = Workspace:FindFirstChild("Players")
    if not wsPlayersFolder then return nil end
    local playerFolder = wsPlayersFolder:FindFirstChild(LocalPlayer.Name)
    if not playerFolder then return nil end
    local toolFolder = playerFolder:FindFirstChild(tool.Name)
    if not toolFolder then return nil end
    return toolFolder:FindFirstChild("RemoteEvent")
end

-- Special reload handlers for specific gun types
local function reloadNockGun(tool)
    -- Nock Gun: StartReload, then spam Reload until ShotsLoaded reaches 7 (only if under 7)
    if not tool then return end
    
    -- Prevent overlapping reloads for the same tool
    if reloadInProgress[tool] then return end
    reloadInProgress[tool] = true
    
    local shots = getShotsLoadedForTool(tool)
    if shots >= 7 then
        print("Nock Gun already full: ShotsLoaded =", shots)
        reloadInProgress[tool] = nil
        return
    end
    
    local remote = findRemoteForTool(tool) or tool:FindFirstChild("RemoteEvent")
    if not remote then
        reloadInProgress[tool] = nil
        return
    end
    
    -- Step 1: Fire StartReload
    pcall(function() remote:FireServer("StartReload") end)
    task.wait(0.1)
    
    -- Step 2: Spam Reload until ShotsLoaded is 7
    local attempts = 0
    local maxAttempts = 50
    while attempts < maxAttempts do
        local currentShots = getShotsLoadedForTool(tool)
        if currentShots >= 7 then
            print("Nock Gun reload complete: ShotsLoaded =", currentShots)
            -- Unequip and re-equip when full
            pcall(function() tool.Parent = LocalPlayer.Backpack end)
            task.wait(0.02)
            pcall(function() tool.Parent = LocalPlayer.Character end)
            break
        end
        pcall(function() remote:FireServer("Reload") end)
        task.wait(0.05)
        attempts = attempts + 1
    end
    
    reloadInProgress[tool] = nil
end

local function reloadDoubleBarrelPistol(tool)
    -- Double Barrel Pistol: spam Reload until ShotsLoaded reaches 2 (only if at 0)
    if not tool then return end
    
    -- Prevent overlapping reloads for the same tool
    if reloadInProgress[tool] then return end
    reloadInProgress[tool] = true
    
    local shots = getShotsLoadedForTool(tool)
    if shots ~= 0 then
        print(tool.Name .. " has shots remaining: ShotsLoaded =", shots)
        reloadInProgress[tool] = nil
        return
    end
    
    local remote = findRemoteForTool(tool) or tool:FindFirstChild("RemoteEvent")
    if not remote then
        reloadInProgress[tool] = nil
        return
    end
    
    local attempts = 0
    local maxAttempts = 50
    while attempts < maxAttempts do
        local currentShots = getShotsLoadedForTool(tool)
        if currentShots >= 2 then
            print(tool.Name .. " reload complete: ShotsLoaded =", currentShots)
            -- Unequip and re-equip when full
            reloadInProgress[tool] = nil  -- Clear flag before unequip/reequip
            pcall(function() tool.Parent = LocalPlayer.Backpack end)
            task.wait(0.02)
            pcall(function() tool.Parent = LocalPlayer.Character end)
            task.wait(0.1)  -- Wait for reequip to complete
            return
        end
        pcall(function() remote:FireServer("Reload") end)
        task.wait(0.05)
        attempts = attempts + 1
    end
    
    reloadInProgress[tool] = nil
end

local function reloadHorseArtilleryPistol(tool)
    -- Horse Artillery Pistol: StartReload, then spam Reload until ShotsLoaded reaches 2 (only if at 0)
    if not tool then return end
    
    -- Prevent overlapping reloads for the same tool
    if reloadInProgress[tool] then return end
    reloadInProgress[tool] = true
    
    local shots = getShotsLoadedForTool(tool)
    if shots ~= 0 then
        print(tool.Name .. " has shots remaining: ShotsLoaded =", shots)
        reloadInProgress[tool] = nil
        return
    end
    
    local remote = findRemoteForTool(tool) or tool:FindFirstChild("RemoteEvent")
    if not remote then
        reloadInProgress[tool] = nil
        return
    end
    
    -- Step 1: Fire StartReload
    pcall(function() remote:FireServer("StartReload") end)
    task.wait(0.1)
    
    -- Step 2: Spam Reload until ShotsLoaded is 2
    local attempts = 0
    local maxAttempts = 50
    while attempts < maxAttempts do
        local currentShots = getShotsLoadedForTool(tool)
        if currentShots >= 2 then
            -- Unequip and re-equip when full
            reloadInProgress[tool] = nil  -- Clear flag before unequip/reequip
            
            -- Verify tool still exists and is in character
            if tool and tool.Parent == LocalPlayer.Character then
                pcall(function() 
                    tool.Parent = LocalPlayer.Backpack
                end)
                task.wait(0.02)
                pcall(function() 
                    tool.Parent = LocalPlayer.Character
                end)
                task.wait(0.1)  -- Wait for reequip to complete
            end
            return
        end
        pcall(function() remote:FireServer("Reload") end)
        task.wait(0.05)
        attempts = attempts + 1
    end
    
    reloadInProgress[tool] = nil
end

local function quickUnequipReequip(tool)
    -- Quickly move tool from Character to Backpack and back
    if not tool or not tool.Parent then return end
    
    task.spawn(function()
        pcall(function()
            -- Move to Backpack
            tool.Parent = LocalPlayer.Backpack
        end)
        task.wait(0.02)  -- Very fast unequip
        pcall(function()
            -- Move back to Character
            tool.Parent = LocalPlayer.Character
        end)
    end)
end

local function reloadNormalGun(tool)
    -- All other guns: just fire Reload once
    if not tool then return end
    
    -- Prevent overlapping reloads for the same tool
    if reloadInProgress[tool] then return end
    reloadInProgress[tool] = true
    
    local remote = findRemoteForTool(tool) or tool:FindFirstChild("RemoteEvent")
    if not remote then
        reloadInProgress[tool] = nil
        return
    end
    pcall(function() remote:FireServer("Reload") end)
    
    -- When ShotsLoaded reaches 1, unequip and re-equip the gun
    task.wait(0.2)
    local shots = getShotsLoadedForTool(tool)
    if shots == 1 then
        quickUnequipReequip(tool)
    end
    
    reloadInProgress[tool] = nil
end
local function tryReloadTool(tool)
    if not tool then return end
    if not AUTO_RELOAD_ENABLED then return end
    if not isGun(tool) then return end
    local shots = getShotsLoadedForTool(tool)
    
    if tool.Name == "Horse Artillery Pistol" then
        print("tryReloadTool: Checking Horse Artillery Pistol, shots =", shots)
    end
    
    -- Determine if reload is needed based on gun type
    local shouldReload = false
    if tool.Name == "Nock Gun" then
        shouldReload = shots < 7
    elseif tool.Name == "Double Barrel Pistol" or tool.Name == "Horse Artillery Pistol" then
        shouldReload = shots == 0
    else
        shouldReload = shots == 0  -- Normal guns reload only when empty
    end
    
    if tool.Name == "Horse Artillery Pistol" then
        print("tryReloadTool: Horse Artillery Pistol shouldReload =", shouldReload)
    end
    
    if shouldReload then
        if tool.Name == "Horse Artillery Pistol" then
            print("tryReloadTool: Spawning reloadHorseArtilleryPistol")
        end
        -- Check gun name and fire appropriate reload sequence
        if tool.Name == "Nock Gun" then
            task.spawn(reloadNockGun, tool)
        elseif tool.Name == "Double Barrel Pistol" then
            task.spawn(reloadDoubleBarrelPistol, tool)
        elseif tool.Name == "Horse Artillery Pistol" then
            task.spawn(reloadHorseArtilleryPistol, tool)
        else
            task.spawn(reloadNormalGun, tool)
        end
    end
end

-- Simulate reload animations locally when auto-reload fires.
-- Plays reload animations found in the tool's `Animations` folder (ReloadP1/ReloadP2/ReloadP3/Reload)
local function simulateReloadAnimations(tool, forcePlay)
    if not tool then return end
    local char = LocalPlayer and LocalPlayer.Character
    if not char then return end
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    local animator = humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoid)
    if not animator then return end

    -- We'll search for specific animation names in several likely locations
    local function findAnimationByName(name)
        if not name then return nil end
        -- 1) tool.Animations
        local animFolder = tool:FindFirstChild("Animations")
        if animFolder then
            local a = animFolder:FindFirstChild(name)
            if a and a:IsA("Animation") then return a end
        end
        -- 2) tool.Model or ModelReference -> Animations
        local modelRef = tool:FindFirstChild("Model") or tool:FindFirstChild("ModelReference")
        if modelRef then
            local model = (modelRef.Value and modelRef.Value) or modelRef
            if model and model:IsA("Model") then
                local mf = model:FindFirstChild("Animations")
                if mf then
                    local a = mf:FindFirstChild(name)
                    if a and a:IsA("Animation") then return a end
                end
            end
        end
        -- 3) Workspace.Players.<LocalPlayer>.<ToolName>.Animations (decompiled-style path)
        local wsPlayers = Workspace:FindFirstChild("Players")
        if wsPlayers and LocalPlayer and LocalPlayer.Name then
            local playerFolder = wsPlayers:FindFirstChild(LocalPlayer.Name)
            if playerFolder then
                local toolFolder = playerFolder:FindFirstChild(tool.Name)
                if toolFolder then
                    local af = toolFolder:FindFirstChild("Animations")
                    if af then
                        local a = af:FindFirstChild(name)
                        if a and a:IsA("Animation") then return a end
                    end
                end
            end
        end
        -- 4) search descendants as a last resort
        for _, d in ipairs(tool:GetDescendants()) do
            if d.Name == name and d:IsA("Animation") then return d end
        end
        return nil
    end

    local order = {"HammerDownLoaded", "ReloadP1", "ReloadP2", "HammerPull"}
    local seq = {}
    for _, name in ipairs(order) do
        local anim = findAnimationByName(name)
        if anim then table.insert(seq, anim) end
    end
    -- nothing to play
    if #seq == 0 then return end

    -- Helper: try to find a cartridge part in the tool or its model
    local function findCartridgePart(tool)
        if not tool then return nil end
        if tool:FindFirstChild("Cartridge") and tool.Cartridge:IsA("BasePart") then
            return tool.Cartridge
        end
        local model = tool:FindFirstChild("Model") or tool:FindFirstChild("ModelReference")
        if model and model.Value and model.Value:IsA("Model") then
            local c = model.Value:FindFirstChild("Cartridge")
            if c and c:IsA("BasePart") then return c end
        elseif model and model:IsA("Model") then
            local c = model:FindFirstChild("Cartridge")
            if c and c:IsA("BasePart") then return c end
        end
        return nil
    end

    -- Play sequentially without blocking main thread, and respond to animation markers
    task.spawn(function()
        local rightPart = nil
        local char = LocalPlayer and LocalPlayer.Character
        if char then
            rightPart = char:FindFirstChild("RightHand") or char:FindFirstChild("Right Arm") or char:FindFirstChild("RightLowerArm") or char:FindFirstChild("RightUpperArm") or char:FindFirstChild("RightArm")
        end

        local handCart = nil
        local originalCartridge = findCartridgePart(tool)

        for _, anim in ipairs(seq) do
            local ok, track = pcall(function() return animator:LoadAnimation(anim) end)
            if not ok or not track then
                task.wait(0.02)
            else
                track.Priority = Enum.AnimationPriority.Action

                -- Connect common marker events if available
                local conns = {}
                local function safeConnect(mName, fn)
                    local succ, conn = pcall(function() return track:GetMarkerReachedSignal(mName):Connect(fn) end)
                    if succ and conn then table.insert(conns, conn) end
                end

                safeConnect("HandCart", function()
                    -- create a hand cart clone and weld to right arm
                    if handCart then return end
                    local cartSrc = originalCartridge
                    if not cartSrc then
                        -- try to find a Cartridge under tool model
                        cartSrc = tool:FindFirstChild("Cartridge") or (tool:FindFirstChild("Model") and tool.Model:FindFirstChild("Cartridge"))
                    end
                    if cartSrc and rightPart then
                        local ok2, cloned = pcall(function() return cartSrc:Clone() end)
                        if ok2 and cloned then
                            cloned.Parent = tool
                            cloned.Transparency = 0
                            local weld = Instance.new("Weld")
                            weld.Part0 = rightPart
                            weld.Part1 = cloned
                            weld.C0 = CFrame.new(0, -0.85, -0.4)
                            weld.Parent = cloned
                            handCart = cloned
                        end
                    end
                end)

                safeConnect("HandCartOff", function()
                    if handCart and handCart.Parent then
                        handCart:Destroy()
                        handCart = nil
                    end
                    if originalCartridge and originalCartridge:IsA("BasePart") then
                        pcall(function() originalCartridge.Transparency = 0 end)
                    end
                end)

                safeConnect("PourPowder", function()
                    if handCart then
                        local powder = handCart:FindFirstChild("Powder", true)
                        if powder and powder:IsA("ParticleEmitter") then
                            powder.Enabled = true
                            task.delay(0.3, function() pcall(function() powder.Enabled = false end) end)
                        end
                    else
                        -- try to find particle on tool
                        local powder = tool:FindFirstChild("Powder", true)
                        if powder and powder:IsA("ParticleEmitter") then
                            powder.Enabled = true
                            task.delay(0.3, function() pcall(function() powder.Enabled = false end) end)
                        end
                    end
                end)

                safeConnect("CartOff", function()
                    if originalCartridge and originalCartridge:IsA("BasePart") then
                        pcall(function() originalCartridge.Transparency = 1 end)
                    end
                end)

                safeConnect("RipCart", function()
                    if handCart then
                        local ripped = handCart:FindFirstChild("Ripped")
                        if ripped then
                            ripped.Transparency = 0
                            handCart.Transparency = 1
                        end
                    end
                end)

                safeConnect("CartridgeStart", function()
                    if originalCartridge and originalCartridge:IsA("BasePart") then
                        pcall(function()
                            if originalCartridge.Parent and originalCartridge.Parent:IsA("Model") then
                                -- try to nudge weld if present
                                for _, w in ipairs(originalCartridge:GetJoints()) do
                                    if w:IsA("Weld") then
                                        w.C1 = w.C1 * CFrame.new(0, -0.03, 0)
                                        break
                                    end
                                end
                            end
                        end)
                    end
                end)

                -- Play and wait
                track:Play(0.02, 1, 1)
                pcall(function() track.Stopped:Wait() end)

                -- cleanup connections
                for _, c in ipairs(conns) do pcall(function() c:Disconnect() end) end
                task.wait(0.02)
            end
        end

        -- ensure handCart cleanup
        if handCart and handCart.Parent then
            pcall(function() handCart:Destroy() end)
            handCart = nil
        end
    end)
end
local function watchShotsForTool(tool)
    if not tool then return end
    if not isGun(tool) then return end
    if watchedTools[tool] then return end
    watchedTools[tool] = true
    local function attach(shotsObj, reloadRemote)
        if not shotsObj then return end
        local prevVal = (shotsObj.Value ~= nil) and shotsObj.Value or 0
        
        -- Initial check: reload if below threshold for this gun
        if AUTO_RELOAD_ENABLED then
            local shouldReload = false
            if tool.Name == "Nock Gun" then
                shouldReload = prevVal < 7
            elseif tool.Name == "Double Barrel Pistol" or tool.Name == "Horse Artillery Pistol" then
                shouldReload = prevVal == 0
            else
                shouldReload = prevVal == 0
            end
            
            if tool.Name == "Horse Artillery Pistol" then
                print("watchShotsForTool INITIAL: Horse Artillery Pistol detected, prevVal =", prevVal, ", shouldReload =", shouldReload, ", reloadRemote =", reloadRemote ~= nil)
            end
            
            if shouldReload and reloadRemote then
                if tool.Name == "Horse Artillery Pistol" then
                    print("watchShotsForTool INITIAL: Spawning reloadHorseArtilleryPistol")
                end
                if tool.Name == "Nock Gun" then
                    task.spawn(reloadNockGun, tool)
                elseif tool.Name == "Double Barrel Pistol" then
                    task.spawn(reloadDoubleBarrelPistol, tool)
                elseif tool.Name == "Horse Artillery Pistol" then
                    task.spawn(reloadHorseArtilleryPistol, tool)
                else
                    task.spawn(reloadNormalGun, tool)
                end
            end
        end
        
        local reloadDebounce = false
        local conn
        conn = shotsObj.Changed:Connect(function()
            local v = shotsObj.Value
            if AUTO_RELOAD_ENABLED and type(v) == "number" and type(prevVal) == "number" and v > prevVal then
                for i = prevVal + 1, v do task.spawn(notifyReload) end
            end
            
            -- Check if reload is needed based on gun type
            local shouldReload = false
            if tool.Name == "Nock Gun" then
                shouldReload = v < 7
            elseif tool.Name == "Double Barrel Pistol" or tool.Name == "Horse Artillery Pistol" then
                shouldReload = v == 0
            else
                shouldReload = v == 0
            end
            
            if shouldReload and reloadRemote and not reloadDebounce then
                reloadDebounce = true
                if AUTO_RELOAD_ENABLED then
                    -- Trigger reload with appropriate handler for this tool
                    if tool.Name == "Nock Gun" then
                        task.spawn(reloadNockGun, tool)
                    elseif tool.Name == "Double Barrel Pistol" then
                        task.spawn(reloadDoubleBarrelPistol, tool)
                    elseif tool.Name == "Horse Artillery Pistol" then
                        task.spawn(reloadHorseArtilleryPistol, tool)
                    else
                        task.spawn(reloadNormalGun, tool)
                    end
                end
                task.delay(1.2, function() reloadDebounce = false end)
            end
            prevVal = v
        end)
        tool.AncestryChanged:Connect(function(_, parent)
            if not parent and conn then conn:Disconnect() end
        end)
    end
    local shotsInst = tool:FindFirstChild("ShotsLoaded")
    local remoteInst = tool:FindFirstChild("RemoteEvent")
    if shotsInst and (shotsInst:IsA("IntValue") or shotsInst:IsA("NumberValue")) then
        attach(shotsInst, remoteInst); return
    end
    local wsPlayersFolder = Workspace:FindFirstChild("Players")
    if not wsPlayersFolder then return end
    local playerFolder = wsPlayersFolder:FindFirstChild(LocalPlayer.Name)
    if not playerFolder then return end
    local toolFolder = playerFolder:FindFirstChild(tool.Name)
    local serverRemote = (toolFolder and toolFolder:FindFirstChild("RemoteEvent")) or remoteInst
    if toolFolder then
        local shots = toolFolder:FindFirstChild("ShotsLoaded")
        if shots and (shots:IsA("IntValue") or shots:IsA("NumberValue")) then attach(shots, serverRemote); return end
    end
end
-- Smoothing + animation helpers (unchanged)
local function smoothLookAtDynamic(rootPart, getPosFunc, duration)
    if not rootPart or not getPosFunc then return end
    local start = tick()
    local startCFrame = rootPart.CFrame
    local ok, initTarget = pcall(getPosFunc)
    if not ok or not initTarget then return end
    while tick() - start < duration do
        if not rootPart.Parent then return end
        local curPos = nil
        pcall(function() curPos = getPosFunc() end)
        if not curPos then curPos = initTarget end
        local desired = CFrame.new(rootPart.Position, Vector3.new(curPos.X, rootPart.Position.Y, curPos.Z))
        local t = math.clamp((tick() - start) / duration, 0, 1)
        local smoothT = t * t * (3 - 2 * t)
        local lerped = startCFrame:Lerp(desired, smoothT)
        local safeCFrame = CFrame.new(rootPart.Position, rootPart.Position + lerped.LookVector)
        pcall(function() rootPart.CFrame = safeCFrame end)
        RunService.RenderStepped:Wait()
    end
    local finalPos = nil
    pcall(function() finalPos = getPosFunc() end)
    if finalPos then pcall(function() rootPart.CFrame = CFrame.new(rootPart.Position, rootPart.Position + CFrame.new(rootPart.Position, Vector3.new(finalPos.X, rootPart.Position.Y, finalPos.Z)).LookVector) end) end
end
-- Cache for animations to avoid recreating them
local animationCache = {}
local function playAnimation(animId, animator)
    if not animId or not animator then return nil end
    local cacheKey = animId .. tostring(animator)
    
    -- Check cache first
    if animationCache[cacheKey] and animationCache[cacheKey].Parent then
        local track = animationCache[cacheKey]
        if track.IsPlaying then track:Stop(0.02) end
        track:Play(0.02, 1, 1)
        return track
    end
    
    local ok, track = pcall(function()
        local anim = Instance.new("Animation")
        anim.AnimationId = animId
        return animator:LoadAnimation(anim)
    end)
    if not ok or not track then return nil end
    track.Priority = Enum.AnimationPriority.Action
    track:Play(0.02, 1, 1)
    animationCache[cacheKey] = track
    return track
end
-- aimThenShootGun (UPDATED) â€” supports dynamic retargeting and movement-abort rule
local function aimThenShootGun(targetModel, initialPart, tool, isPlayerTarget, savedPlayer)
    if not targetModel or not targetModel.Parent then return end
    if not initialPart or not initialPart.Parent or not initialPart:IsA("BasePart") then return end
    if not tool or not tool.Parent or not tool:IsDescendantOf(LocalPlayer.Character) then return end
    if not isGun(tool) then return end
    local char = LocalPlayer.Character
    if not char then return end
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    local animator = humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoid)
    pcall(watchShotsForTool, tool)
    local remote = tool:FindFirstChild("RemoteEvent") or nil
    -- Discover animations
    local animFolder = tool:FindFirstChild("Animations")
    local animAId, animBId
    if animFolder then
        local aim = animFolder:FindFirstChild("Aim")
        local aiming = animFolder:FindFirstChild("Aiming")
        if aim and aim:IsA("Animation") then animAId = aim.AnimationId end
        if aiming and aiming:IsA("Animation") then animBId = aiming.AnimationId end
    end
    animAId = animAId or "rbxassetid://83511222574103"
    animBId = animBId or "rbxassetid://136849639865723"
    local fireAnimId = nil
    if animFolder then
        local fire = animFolder:FindFirstChild("Fire")
        if fire and fire:IsA("Animation") then fireAnimId = fire.AnimationId end
    end
    -- Origin function
    local function getAimOrigin()
        if LocalPlayer and LocalPlayer.Character and LocalPlayer.Character.Parent then
            local head = LocalPlayer.Character:FindFirstChild("Head")
            if head and head:IsA("BasePart") then return head.Position end
        end
        local cam = Workspace.CurrentCamera
        if cam then return cam.CFrame.Position end
        return nil
    end
    -- dynamic utilities (local copies used during aiming)
    local currentTargetPart = initialPart
    local currentTargetModel = targetModel
    local function resolveAimPos(part)
        if not part or not part.Parent or not part:IsA("BasePart") then return nil end
        if isPlayerTarget then
            return getAimPosition(part, { skipPrediction = true })
        end
        return getAimPosition(part)
    end
    local function refreshTargetVisuals()
        if not TARGET_ESP_ENABLED then return end
        if not currentTargetPart or not currentTargetModel then return end
        pcall(function()
            updateActiveTargetVisuals(currentTargetModel, currentTargetPart)
        end)
    end
    local function isPartVisible(part, model)
        if not part or not part.Parent or not part:IsA("BasePart") then return false end
        local origin = getAimOrigin()
        if not origin then return false end
        local baseIgnore = buildBaseIgnore()
        local aimPos = resolveAimPos(part)
        if not aimPos then return false end
        local ok, res = pcall(function() return hasClearShotOnPart(origin, part, model, baseIgnore) end)
        return ok and res
    end
    -- animations
    local trackA, trackB
    local trackATimeoutThread, trackBTimeoutThread
    local function cleanupTrack(track, timeoutThread)
        if track and track.IsPlaying then
            pcall(function() track:Stop(0.1) end)
        end
        if timeoutThread then
            task.cancel(timeoutThread)
        end
    end
    -- Start animations AND rotation simultaneously
    local root = char:FindFirstChild("HumanoidRootPart")
    if root and currentTargetModel and currentTargetModel.Parent then
        trackA = playAnimation(animAId, animator)
        if trackA then
            trackATimeoutThread = task.delay(3, function()
                if trackA and trackA.IsPlaying then
                    pcall(function() trackA:Stop(0.1) end)
                end
            end)
        end
        task.wait(0.02)
        trackB = playAnimation(animBId, animator)
        if trackB then
            trackBTimeoutThread = task.delay(3, function()
                if trackB and trackB.IsPlaying then
                    pcall(function() trackB:Stop(0.1) end)
                end
            end)
        end
        -- rotation with dynamic getPos
        local function getPosFunc()
            if not currentTargetPart or not currentTargetPart.Parent then
                -- pick best part from model
                local nxt = findBestAimPart(currentTargetModel)
                if nxt and isPartVisible(nxt, currentTargetModel) then
                    currentTargetPart = nxt
                    return resolveAimPos(nxt)
                end
                return nil
            end
            if currentTargetPart and currentTargetPart.Parent then
                return resolveAimPos(currentTargetPart)
            end
            return nil
        end
        local originalAutoRotate = humanoid.AutoRotate
        humanoid.AutoRotate = false
        task.spawn(function()
            pcall(function() smoothLookAtDynamic(root, getPosFunc, LOOK_DURATION) end)
        end)
        -- Wait for rotation duration while animations play
        task.wait(LOOK_DURATION)
        -- Restore AutoRotate
        humanoid.AutoRotate = originalAutoRotate
        -- Stop aim animation and cancel timeout
        cleanupTrack(trackA, trackATimeoutThread)
    else
        cleanupTrack(trackA, trackATimeoutThread)
        cleanupTrack(trackB, trackBTimeoutThread)
        return
    end
    -- Initial movement sign (for abort rule)
    -- Wait for shots with repeated abort checks and dynamic retargeting
    local WAIT_TIMEOUT = 3.0
    local waited = 0
    local POLL_INTERVAL = 0.06
    local shotsNow = getShotsLoadedForTool(tool)
    while (not shotsNow or shotsNow < 1) and waited < WAIT_TIMEOUT do
        -- abort if tool lost
        if not tool or not tool.Parent or not tool:IsDescendantOf(LocalPlayer.Character) then
            cleanupTrack(trackA, trackATimeoutThread)
            cleanupTrack(trackB, trackBTimeoutThread)
            return
        end
        -- abort if toggles disabled
        if not (USER_AUTO_SHOOT_TOGGLE or AUTO_SAVE_PLAYERS_ENABLED) then
            cleanupTrack(trackA, trackATimeoutThread)
            cleanupTrack(trackB, trackBTimeoutThread)
            return
        end
        -- If player-targeted save: ensure the player is still grabbed/pinned and alive
        if isPlayerTarget and savedPlayer then
            local wsPlayersFolder = Workspace:FindFirstChild("Players")
            local playerFolder = (wsPlayersFolder and wsPlayersFolder:FindFirstChild(savedPlayer.Name)) or nil
            local stillGrabbed = false
            if playerFolder then
                local userStates = playerFolder:FindFirstChild("UserStates")
                if userStates then
                    local grabbedVal = userStates:FindFirstChild("Grabbed")
                    local pinVal = userStates:FindFirstChild("Pin")
                    local grabbed = (grabbedVal and tonumber(grabbedVal.Value) or 0) ~= 0
                    local pinState = (pinVal and pinVal.Value) or ""
                    local pinned = (pinState == "RunnerAttack" or pinState == "RunnerClaw" or pinState == "RunnerVomit")
                    stillGrabbed = grabbed or pinned
                end
            end
            local plChar = savedPlayer.Character
            local plHum = plChar and plChar:FindFirstChildOfClass("Humanoid")
            if (not stillGrabbed) or (not plHum) or (plHum.Health < 1) then
                -- player saved or dead -> abort
                cleanupTrack(trackA, trackATimeoutThread)
                cleanupTrack(trackB, trackBTimeoutThread)
                return
            end
        end
        -- If target died or removed -> try retargeting to nearest selected type
        if (not currentTargetModel) or (not currentTargetModel.Parent) then
            -- try to retarget
            local newPart, newModel = getNearestSelectedZombie(MAX_TARGET_RANGE)
            if newPart and newModel then
                currentTargetPart = newPart
                currentTargetModel = newModel
                refreshTargetVisuals()
                -- update initial sign when retargeting
            else
                cleanupTrack(trackA, trackATimeoutThread)
                cleanupTrack(trackB, trackBTimeoutThread)
                return
            end
        end
        local hum = (currentTargetModel and currentTargetModel:FindFirstChildOfClass("Humanoid")) or nil
        if hum and hum.Health and hum.Health < 1 then
            -- retarget attempt
            local newPart, newModel = getNearestSelectedZombie(MAX_TARGET_RANGE)
            if newPart and newModel then
                currentTargetPart = newPart
                currentTargetModel = newModel
                refreshTargetVisuals()
            else
                cleanupTrack(trackA, trackATimeoutThread)
                cleanupTrack(trackB, trackBTimeoutThread)
                return
            end
        end
        -- Visibility: if current part is blocked -> try other parts or retarget to another zombie
        if currentTargetPart and (not isPartVisible(currentTargetPart, currentTargetModel)) then
            -- try alternative parts on same model
            local barrel = currentTargetModel:FindFirstChild("Barrel")
            local head = currentTargetModel:FindFirstChild("Head")
            local torso = currentTargetModel:FindFirstChild("Torso") or currentTargetModel:FindFirstChild("UpperTorso") or currentTargetModel:FindFirstChild("HumanoidRootPart")
            local switched = false
            if barrel and barrel ~= currentTargetPart and isPartVisible(barrel, currentTargetModel) then currentTargetPart = barrel; switched = true
            elseif head and head ~= currentTargetPart and isPartVisible(head, currentTargetModel) then currentTargetPart = head; switched = true
            elseif torso and torso ~= currentTargetPart and isPartVisible(torso, currentTargetModel) then currentTargetPart = torso; switched = true end
            if not switched then
                -- try to retarget to other selected zombies
                local newPart, newModel = getNearestSelectedZombie(MAX_TARGET_RANGE)
                if newPart and newModel then
                    currentTargetPart = newPart
                    currentTargetModel = newModel
                    refreshTargetVisuals()
                else
                    cleanupTrack(trackA, trackATimeoutThread)
                    cleanupTrack(trackB, trackBTimeoutThread)
                    return
                end
            else
                refreshTargetVisuals()
            end
        end
        task.wait(POLL_INTERVAL)
        waited = waited + POLL_INTERVAL
        shotsNow = getShotsLoadedForTool(tool)
    end
    if not shotsNow or shotsNow < 1 then
        cleanupTrack(trackA, trackATimeoutThread)
        cleanupTrack(trackB, trackBTimeoutThread)
        return
    end
    task.wait(FIRE_DELAY_AFTER_LOOK)
    -- Final existence/visibility checks before fire, with fallback/retargeting similar to above
    if not currentTargetPart or not currentTargetPart.Parent or (not isPartVisible(currentTargetPart, currentTargetModel)) then
        local barrel = currentTargetModel and currentTargetModel:FindFirstChild("Barrel")
        local head = currentTargetModel and currentTargetModel:FindFirstChild("Head")
        local torso = currentTargetModel and (currentTargetModel:FindFirstChild("Torso") or currentTargetModel:FindFirstChild("UpperTorso") or currentTargetModel:FindFirstChild("HumanoidRootPart"))
        if barrel and isPartVisible(barrel, currentTargetModel) then currentTargetPart = barrel
        elseif head and isPartVisible(head, currentTargetModel) then currentTargetPart = head
        elseif torso and isPartVisible(torso, currentTargetModel) then currentTargetPart = torso
        else
            -- try retargeting
            local newPart, newModel = getNearestSelectedZombie(MAX_TARGET_RANGE)
            if newPart and newModel then
                currentTargetPart = newPart
                currentTargetModel = newModel
            else
                cleanupTrack(trackA, trackATimeoutThread)
                cleanupTrack(trackB, trackBTimeoutThread)
                return
            end
        end
        refreshTargetVisuals()
    end
    -- Extra final checks: alive & player save checks
    if currentTargetModel and (not currentTargetModel.Parent) then cleanupTrack(trackB, trackBTimeoutThread); return end
    local finalHum = (currentTargetModel and currentTargetModel:FindFirstChildOfClass("Humanoid")) or nil
    if finalHum and finalHum.Health and finalHum.Health < 1 then cleanupTrack(trackB, trackBTimeoutThread); return end
    if isPlayerTarget and savedPlayer then
        local wsPlayersFolder = Workspace:FindFirstChild("Players")
        local playerFolder = (wsPlayersFolder and wsPlayersFolder:FindFirstChild(savedPlayer.Name)) or nil
        local stillGrabbed = false
        if playerFolder then
            local userStates = playerFolder:FindFirstChild("UserStates")
            if userStates then
                local grabbedVal = userStates:FindFirstChild("Grabbed")
                local pinVal = userStates:FindFirstChild("Pin")
                local grabbed = (grabbedVal and tonumber(grabbedVal.Value) or 0) ~= 0
                local pinState = (pinVal and pinVal.Value) or ""
                local pinned = (pinState == "RunnerAttack" or pinState == "RunnerClaw" or pinState == "RunnerVomit")
                stillGrabbed = grabbed or pinned
            end
        end
        local plChar = savedPlayer.Character
        local plHum = plChar and plChar:FindFirstChildOfClass("Humanoid")
        if (not stillGrabbed) or (not plHum) or (plHum.Health < 1) then
            cleanupTrack(trackB, trackBTimeoutThread)
            return
        end
    end
    -- Fire
    local fireTrack = nil
    if fireAnimId then pcall(function() fireTrack = playAnimation(fireAnimId, animator) end) end
    pcall(function()
        local modelRef = char:FindFirstChild("Model") or char
        local t = Workspace:GetServerTimeNow()
        remote = remote or tool:FindFirstChild("RemoteEvent")
        -- Before firing re-check obstruction using origin to currentTargetPart
        local origin = (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head") and LocalPlayer.Character.Head.Position) or (Workspace.CurrentCamera and Workspace.CurrentCamera.CFrame.Position)
        local baseIgnore = buildBaseIgnore()
        if CHECK_WALLS and origin and currentTargetPart and currentTargetPart.Parent then
            local hasClear = hasClearShotOnPart(origin, currentTargetPart, currentTargetModel, baseIgnore)
            if not hasClear then
                -- abort
                if fireTrack then pcall(function() fireTrack:Stop(0.07) end) end
                return
            end
        end
        if remote and currentTargetPart and currentTargetPart.Parent then
            local aimPos = resolveAimPos(currentTargetPart)
            if not aimPos then return end
            remote:FireServer("Fire", modelRef, aimPos, t)
        end
    end)
    if fireTrack then task.delay(0.35, function() pcall(function() fireTrack:Stop(0.07) end) end) end
    -- Stop trackB and cancel timeout after firing
    cleanupTrack(trackB, trackBTimeoutThread)
end
-- Instant shoot path â€” UPDATED with movement & obstruction check
local function instantShootGun(targetModel, initialPart, tool, skipPrediction)
    if not targetModel or not targetModel.Parent then return end
    if not initialPart or not initialPart.Parent or not initialPart:IsA("BasePart") then return end
    if not tool or not tool.Parent or not tool:IsDescendantOf(LocalPlayer.Character) then return end
    if not isGun(tool) then return end
    pcall(watchShotsForTool, tool)
    local char = LocalPlayer.Character
    if not char then return end
    local origin = (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head") and LocalPlayer.Character.Head.Position) or (Workspace.CurrentCamera and Workspace.CurrentCamera.CFrame.Position)
    local aimPos = getAimPosition(initialPart, skipPrediction and { skipPrediction = true }) or initialPart.Position
    if origin and CHECK_WALLS then
        local baseIgnore = buildBaseIgnore()
        local hasClear = hasClearShotOnPart(origin, initialPart, targetModel, baseIgnore)
        if not hasClear then return end
    end
    -- additional check: alive
    if targetModel and (not targetModel.Parent) then return end
    local hum = (targetModel and targetModel:FindFirstChildOfClass("Humanoid")) or nil
    if hum and hum.Health and hum.Health < 1 then return end
    pcall(function()
        local remote = tool:FindFirstChild("RemoteEvent") or findRemoteForTool(tool)
        local modelRef = char:FindFirstChild("Model") or char
        local t = Workspace:GetServerTimeNow()
        if remote and initialPart and initialPart.Parent then
            remote:FireServer("Fire", modelRef, aimPos, t)
        end
    end)
end
-- Cleanup function for profile load
local function cleanupConnections()
    for _, conn in ipairs(activeConnections) do
        pcall(function() conn:Disconnect() end)
    end
    activeConnections = {}
    watchedTools = {}
    isAiming = false
end
-- MAIN LOOP â€” updated to use selected types rather than bombers only
local mainLoopRunning = false
local function startMainLoop()
    if mainLoopRunning then return end
    mainLoopRunning = true
    task.spawn(function()
        while mainLoopRunning do
            local equippedTool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
            local equippedIsGun = equippedTool and isGun(equippedTool)
            local shotsForEquipped = (equippedTool and equippedIsGun) and getShotsLoadedForTool(equippedTool) or 0
            local effectiveAutoShoot = (equippedTool ~= nil) and equippedIsGun and (shotsForEquipped >= 1) and (USER_AUTO_SHOOT_TOGGLE or AUTO_SAVE_PLAYERS_ENABLED)
            -- Attempt to auto-reload on equip if requested
            if AUTO_RELOAD_ENABLED and equippedTool and equippedIsGun then
            pcall(tryReloadTool, equippedTool)
            end
            if effectiveAutoShoot and not isAiming then
            local targetPart, targetModel, isPlayerTarget, savedPlayer = nil, nil, false, nil
            -- Save players ALWAYS first (use pcall to avoid crashes from unexpected runtime errors)
            if AUTO_SAVE_PLAYERS_ENABLED then
                local ok, zPart, zModel, pl = pcall(getNearestZombieToSavePlayer, MAX_SAVE_PLAYERS_RANGE)
                if ok and zPart and zModel then targetPart, targetModel, isPlayerTarget, savedPlayer = zPart, zModel, true, pl end
            end
            -- Only check selected types if no save target found
            if not targetPart and USER_AUTO_SHOOT_TOGGLE then
                -- If no selection -> skip
                if SelectedShootTypes and #SelectedShootTypes > 0 then
                local sPart, sModel, sType = getNearestSelectedZombie(MAX_TARGET_RANGE)
                if sPart and sModel then targetPart, targetModel, isPlayerTarget = sPart, sModel, false end
                end
            end
            if targetPart and targetModel then
                isAiming = true
                -- update visuals immediately
                pcall(function()
                updateActiveTargetVisuals(targetModel, targetPart)
                end)
                local baseIgnoreCache = nil
                local function targetHasClearLOS(customIgnore)
                if not CHECK_WALLS then return true end
                if not targetPart or not targetPart.Parent then return false end
                local originPos = getWallCheckOrigin()
                if not originPos then return true end
                if customIgnore then
                    baseIgnoreCache = customIgnore
                elseif not baseIgnoreCache then
                    baseIgnoreCache = buildBaseIgnore()
                end
                local ignoreList = customIgnore or baseIgnoreCache
                local ok, res = pcall(function()
                    return hasClearShotOnPart(originPos, targetPart, targetModel, ignoreList)
                end)
                return ok and res
                end
                -- smarter appear delay: poll during delay so we can abort quickly
                local appearDelay = (isPlayerTarget and INSTANT_SAVE_PLAYERS_ENABLED and 0.1)
                or (not isPlayerTarget and INSTANT_SHOOT_ENABLED and 0.1)
                or APPEAR_DELAY
                local startT = tick()
                local aborted = false
                while tick() - startT < appearDelay do
                -- abort if target removed
                if not targetModel or not targetModel.Parent then aborted = true; break end
                -- if target became dead
                local hum = (targetModel and targetModel:FindFirstChildOfClass("Humanoid")) or nil
                if hum and hum.Health and hum.Health < 1 then aborted = true; break end
                -- if player target: ensure still grabbed
                if isPlayerTarget and savedPlayer then
                    local wsPlayersFolder = Workspace:FindFirstChild("Players")
                    local playerFolder = (wsPlayersFolder and wsPlayersFolder:FindFirstChild(savedPlayer.Name)) or nil
                    local stillGrabbed = false
                    if playerFolder then
                    local userStates = playerFolder:FindFirstChild("UserStates")
                    if userStates then
                        local grabbedVal = userStates:FindFirstChild("Grabbed")
                        local pinVal = userStates:FindFirstChild("Pin")
                        local grabbed = (grabbedVal and tonumber(grabbedVal.Value) or 0) ~= 0
                        local pinState = (pinVal and pinVal.Value) or ""
                        local pinned = (pinState == "RunnerAttack" or pinState == "RunnerClaw" or pinState == "RunnerVomit")
                        stillGrabbed = grabbed or pinned
                    end
                    end
                    local plChar = savedPlayer.Character
                    local plHum = plChar and plChar:FindFirstChildOfClass("Humanoid")
                    if (not stillGrabbed) or (not plHum) or (plHum.Health < 1) then aborted = true; break end
                end
                if CHECK_WALLS then
                    if not targetHasClearLOS() then
                    aborted = true
                    break
                    end
                end
                task.wait(0.03)
                end
                if aborted then
                pcall(function() clearActiveTargetVisuals() end)
                isAiming = false
                else
                -- Final wall check before shooting
                if CHECK_WALLS then
                    local freshIgnore = buildBaseIgnore()
                    if not targetHasClearLOS(freshIgnore) then
                    pcall(function() clearActiveTargetVisuals() end)
                    isAiming = false
                    end
                end
                
                -- Only proceed if still aiming (not aborted by wall check)
                if isAiming then
                    if equippedTool and equippedTool.Parent and isGun(equippedTool) then
                    local currentTool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
                    if currentTool and currentTool == equippedTool then
                        task.spawn(function()
                        local success, err = pcall(function()
                            if (isPlayerTarget and INSTANT_SAVE_PLAYERS_ENABLED) or (not isPlayerTarget and INSTANT_SHOOT_ENABLED) then
                            instantShootGun(targetModel, targetPart, currentTool, isPlayerTarget)
                            else
                            aimThenShootGun(targetModel, targetPart, currentTool, isPlayerTarget, savedPlayer)
                            end
                        end)
                        if not success then
                            warn("Error in shoot function: " .. tostring(err))
                        end
                        task.wait(0.05)
                        pcall(function() clearActiveTargetVisuals() end)
                        isAiming = false
                        end)
                    else
                        pcall(function() clearActiveTargetVisuals() end)
                        isAiming = false
                    end
                    else
                    pcall(function() clearActiveTargetVisuals() end)
                    isAiming = false
                    end
                end
                end
            end
            end
            task.wait(CHECK_INTERVAL)
        end
    end)
end
-- Attach watchers for tools that might be on character when script loads (and watch Equip)
local function monitorCharacterTools(char)
    if not char then return end
    -- Clean up existing connections for this character
    cleanupConnections()
    -- Watch existing tools and also attach hand mortar watchers
    for _, c in ipairs(char:GetChildren()) do
        if c:IsA("Tool") then
            -- Watch guns
            if isGun(c) then
                pcall(watchShotsForTool, c)
                pcall(tryReloadTool, c)
                -- Equip listener
                local ok, eqConn = pcall(function()
                    return c.Equipped:Connect(function()
                        pcall(tryReloadTool, c)
                    end)
                end)
                if ok and eqConn then table.insert(activeConnections, eqConn) end
            end
            -- Attach hand mortar watcher (best-effort)
            pcall(function() attachHandMortarWatcher(c) end)
        end
    end
    -- Set up new connections for tools added later
    local childAddedConn = char.ChildAdded:Connect(function(child)
        if child and child:IsA("Tool") then
            -- Watch guns added later
            if isGun(child) then
                pcall(watchShotsForTool, child)
                pcall(tryReloadTool, child)
                local ok, eqConn = pcall(function()
                    return child.Equipped:Connect(function()
                        pcall(tryReloadTool, child)
                    end)
                end)
                if ok and eqConn then table.insert(activeConnections, eqConn) end
            end
            -- Hand mortar watcher for future tools
            pcall(function() attachHandMortarWatcher(child) end)
        end
    end)
    table.insert(activeConnections, childAddedConn)
end
-- Set up character monitoring
local function setupCharacterMonitoring()
    -- Disconnect any existing CharacterAdded connection if present
    for i, conn in ipairs(activeConnections) do
        if conn == characterAddedConn then
            pcall(function() conn:Disconnect() end)
            table.remove(activeConnections, i)
            break
        end
    end
    characterAddedConn = LocalPlayer.CharacterAdded:Connect(monitorCharacterTools)
    table.insert(activeConnections, characterAddedConn)
    if LocalPlayer.Character then
        monitorCharacterTools(LocalPlayer.Character)
    end
end
-- Start the script
setupCharacterMonitoring()
startMainLoop()

-- UI â€” create GunTab and sections once, then add toggles
local GunTab = Main1Section and Main1Section:Tab({ Title = "Gun Modifiers", Icon = "target" }) or nil
local GunModSection, ShootingSection
if GunTab then
    GunModSection = GunTab:Section({ Title = "Gun Mod", Icon = "zap", Opened = false })
    ShootingSection = GunTab:Section({ Title = "Shooting", Icon = "target", Opened = false })
    -- Multi-select dropdown for zombie types to auto-shoot
    local shootDropdown = ShootingSection:Dropdown({
        Title = "Select Zombie Types To AutoShoot",
        Flag = "Shooting_Type_Select",
        Desc = "Choose which zombie types to target.",
        Values = ShootTypeList,
        Value = {},
        Multi = true,
        Callback = function(selection)
            local newSelection = selection or {}
            SelectedShootTypes = {}
            for _, v in ipairs(newSelection) do table.insert(SelectedShootTypes, tostring(v)) end
            -- Keep EnabledShootTypes consistent: if some types were deselected, disable them
            for _, t in ipairs(ShootTypeList) do
                local found = false
                for _, s in ipairs(SelectedShootTypes) do if s == t then found = true; break end end
                if not found then EnabledShootTypes[t] = false end
            end
            pcall(function()
                WindUI:Notify({
                    Title = "Shooting Selection",
                    Content = (#SelectedShootTypes > 0) and ("Selected: " .. table.concat(SelectedShootTypes, ", ")) or "No selection",
                    Icon = "target",
                    Duration = 1
                })
            end)
        end
    })
    -- Toggle: enables/disables auto-shoot for selected types
    ShootingSection:Toggle({
        Title = "Enable Auto Shoot",
        Flag = "Shooting_Enable_Selected",
        Desc = "Enable Auto Shooting for the selected zombie types.",
        Icon = "play",
        Value = USER_AUTO_SHOOT_TOGGLE,
        Callback = function(state)
            USER_AUTO_SHOOT_TOGGLE = state
            -- If disabled, clear per-type enabled flags
            if not state then
                for t, _ in pairs(EnabledShootTypes) do EnabledShootTypes[t] = false end
            else
                -- enable all selected types for simplicity
                for _, t in ipairs(SelectedShootTypes) do EnabledShootTypes[t] = true end
            end
        end
    })
    -- Keep "Instant Shoot" behavior but generalized: instant for any selected type
    ShootingSection:Toggle({
        Title = "Instant Shoot",
        Flag = "Shooting_Instant",
        Desc = "Instantly shoot selected zombies (No Animations)",
        Icon = "zap",
        Value = INSTANT_SHOOT_ENABLED,
        Callback = function(state)
            INSTANT_SHOOT_ENABLED = state
            APPEAR_DELAY = (INSTANT_SHOOT_ENABLED and 0.1) or APPEAR_DELAY_DEFAULT
        end
    })
    ShootingSection:Slider({
        Title = "Prediction",
        Flag = "Shooting_Prediction",
        Desc = "Lead time in seconds (scaled by zombie speed, 0 disables prediction)",
        Step = 0.2,
        Value = { Min = 0, Max = 10, Default = PREDICTION_DISTANCE },
        Callback = function(val)
            PREDICTION_DISTANCE = math.clamp(tonumber(val) or 0, 0, 50)
        end
    })
    ShootingSection:Slider({
        Title = "Max Target Range",
        Flag = "Shooting_MaxRange",
        Desc = "Maximum detection range.",
        Step = 1,
        Value = { Min = 50, Max = 600, Default = MAX_TARGET_RANGE },
        Callback = function(val) MAX_TARGET_RANGE = val end
    })
    -- ===== FOV UI =====
    ShootingSection:Toggle({
        Title = "Use Fov",
        Flag = "Shooting_UseFov",
        Desc = "Only target zombies inside the FOV.",
        Icon = "circle",
        Value = USE_FOV,
        Callback = function(state)
            USE_FOV = state
            updateFovCircle()
        end
    })
    ShootingSection:Toggle({
        Title = "Mobile Fov",
        Flag = "Shooting_MobileFov",
        Desc = "Fov stays in the middle (can be used in pc too).",
        Icon = "smartphone",
        Value = MOBILE_FOV,
        Callback = function(state)
            MOBILE_FOV = state
            updateFovCircle()
        end
    })
    ShootingSection:Toggle({
        Title = "Show Fov",
        Flag = "Shooting_ShowFov",
        Desc = "Show the fov circle.",
        Icon = "eye",
        Value = SHOW_FOV,
        Callback = function(state)
            SHOW_FOV = state
            updateFovCircle()
        end
    })
    ShootingSection:Slider({
        Title = "Fov Size",
        Flag = "Shooting_FovSize",
        Desc = "change the FOV circle size.",
        Step = 1,
        Value = { Min = FOV_MIN_DEG, Max = FOV_MAX_DEG, Default = FOV_SIZE_DEG },
        Callback = function(val)
            FOV_SIZE_DEG = val
            updateFovCircle()
        end
    })
    ShootingSection:Toggle({
        Title = "Wall Check (Raycast)",
        Flag = "Shooting_WallCheck",
        Desc = "Selected zombies behind walls will be ignored.",
        Icon = "shield-off",
        Value = CHECK_WALLS,
        Callback = function(state) CHECK_WALLS = state end
    })
    GunModSection:Toggle({ Title = "Auto Reload", Flag = "GunMod_AutoReload", Desc = "Automatically reload.", Icon = "refresh-cw", Value = AUTO_RELOAD_ENABLED, Callback = function(state) AUTO_RELOAD_ENABLED = state end })
    -- Save Players Section (unchanged)
    local SavePlayersSection = GunTab:Section({ Title = "Save Players", Icon = "shield", Opened = false })
    SavePlayersSection:Toggle({
        Title = "Auto Save Players",
        Flag = "SavePlayers_AutoSavePlayers",
        Desc = "Shoot Zombies Grabbing The player.",
        Icon = "shield",
        Value = AUTO_SAVE_PLAYERS_ENABLED,
        Callback = function(state) AUTO_SAVE_PLAYERS_ENABLED = state end
    })
    SavePlayersSection:Toggle({
        Title = "Instant Save Players",
        Flag = "SavePlayers_InstantSavePlayers",
        Desc = "Instantly shoot the zombie grabbing the player (No Animations)",
        Icon = "zap",
        Value = INSTANT_SAVE_PLAYERS_ENABLED,
        Callback = function(state) INSTANT_SAVE_PLAYERS_ENABLED = state end
    })
    SavePlayersSection:Slider({
        Title = "Save Player Delay",
        Flag = "SavePlayers_Delay",
        Desc = "Delay before shooting when saving player (seconds)",
        Step = 0.1,
        Value = { Min = 0, Max = 5, Default = SAVE_PLAYER_DELAY },
        Callback = function(val) SAVE_PLAYER_DELAY = val end
    })
    SavePlayersSection:Slider({
        Title = "Max Save Players Range",
        Flag = "SavePlayers_MaxRange",
        Desc = "Max save players distance.",
        Step = 1,
        Value = { Min = 50, Max = 600, Default = MAX_SAVE_PLAYERS_RANGE },
        Callback = function(val) MAX_SAVE_PLAYERS_RANGE = val end
    })
    -- ===== Targets Settings Section =====
    local TargetsSection = GunTab:Section({ Title = "Targets Settings", Icon = "crosshair", Opened = false })
    TargetsSection:Toggle({
        Title = "Target ESP",
        Flag = "Targets_TargetEsp",
        Desc = "Shows the zombie its currently targeting.",
        Icon = "eye",
        Value = TARGET_ESP_ENABLED,
        Callback = function(state)
            TARGET_ESP_ENABLED = state
            if not state then
                pcall(function() clearActiveTargetVisuals() end)
            else
                if activeAimModel then
                    pcall(function() createTargetHighlight(activeAimModel) end)
                end
            end
        end
    })
end
--- hand mortar feature (updated: supports two anims, 1s delay, first-person overlay)
-- Hand Mortar Timing Feature
local HAND_MORTAR_TIMING_ENABLED = false
local HAND_MORTAR_DURATION = 5 -- seconds, displayed with milliseconds
local HAND_MORTAR_ANIM_IDS = {
    ["rbxassetid://117522716162453"] = true,
    ["rbxassetid://83761082384320"] = true,
}
-- State for GUI and running timer
-- handMortarGui will be a table: { billboard = BillboardGui, screen = ScreenGui }
local handMortarGui = nil
local handMortarUpdateConn = nil
local handMortarCameraConn = nil
local handMortarEndTick = nil
local handMortarRunning = false
local handMortarAnimConn = nil -- AnimationPlayed connection
-- Ensure PlayerGui exists
local function getPlayerGui()
    return LocalPlayer:WaitForChild("PlayerGui")
end
-- Detect first-person by checking camera position relative to head
local function isFirstPerson()
    local cam = Workspace.CurrentCamera
    if not cam then return false end
    local char = LocalPlayer.Character
    if not char then return false end
    local head = char:FindFirstChild("Head")
    if not head or not head:IsA("BasePart") then return false end
    local dist = (cam.CFrame.Position - head.Position).Magnitude
    -- threshold: if camera is very close to head (inside head), treat as first-person
    return dist < 0.7
end
-- Create (or reuse) the BillboardGui + ScreenGui
local function createHandMortarGui()
    -- if existing and parented, return it
    if handMortarGui and ((handMortarGui.billboard and handMortarGui.billboard.Parent) or (handMortarGui.screen and handMortarGui.screen.Parent)) then
        return handMortarGui
    end
    local playerGui = getPlayerGui()
    -- BILLBOARD (for 3rd-person)
    local bg = Instance.new("BillboardGui")
    bg.Name = "HandMortarTimingGui_Billboard"
    bg.Size = UDim2.new(0, 90, 0, 60)
    bg.StudsOffset = Vector3.new(2.2, 0, 0)
    bg.AlwaysOnTop = true
    bg.MaxDistance = 200
    bg.Parent = playerGui
    local frame = Instance.new("Frame")
    frame.Name = "BG"
    frame.Size = UDim2.new(1, 0, 1, 0)
    frame.BackgroundTransparency = 1
    frame.BorderSizePixel = 0
    frame.Parent = bg
    local plate = Instance.new("Frame")
    plate.Name = "Plate"
    plate.Size = UDim2.new(0, 70, 0, 46)
    plate.Position = UDim2.new(0, 0, 0, 6)
    plate.BackgroundTransparency = 0.5
    plate.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
    plate.BorderSizePixel = 0
    plate.Parent = frame
    local barBg = Instance.new("Frame")
    barBg.Name = "BarBg"
    barBg.Size = UDim2.new(0, 10, 0, 36)
    barBg.Position = UDim2.new(0, 6, 0, 5)
    barBg.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    barBg.BorderSizePixel = 0
    barBg.Parent = plate
    barBg.AnchorPoint = Vector2.new(0, 0)
    local fill = Instance.new("Frame")
    fill.Name = "Fill"
    fill.Size = UDim2.new(1, 0, 1, 0)
    fill.Position = UDim2.new(0, 0, 0, 0)
    fill.BackgroundColor3 = Color3.fromRGB(180, 80, 0)
    fill.BorderSizePixel = 0
    fill.Parent = barBg
    fill.AnchorPoint = Vector2.new(0, 1)
    fill.Position = UDim2.new(0, 0, 1, 0)
    local lbl = Instance.new("TextLabel")
    lbl.Name = "Timer"
    lbl.Size = UDim2.new(0, 44, 0, 18)
    lbl.Position = UDim2.new(0, 22, 0, 8)
    lbl.BackgroundTransparency = 1
    lbl.TextScaled = false
    lbl.Font = Enum.Font.SourceSansBold
    lbl.TextSize = 16
    lbl.Text = ""
    lbl.TextColor3 = Color3.fromRGB(255, 255, 255)
    lbl.Parent = plate
    local title = Instance.new("TextLabel")
    title.Name = "Title"
    title.Size = UDim2.new(0, 44, 0, 14)
    title.Position = UDim2.new(0, 22, 0, 27)
    title.BackgroundTransparency = 1
    title.TextScaled = false
    title.Font = Enum.Font.SourceSans
    title.TextSize = 12
    title.Text = "Hand Mortar"
    title.TextColor3 = Color3.fromRGB(200, 200, 200)
    title.Parent = plate
    -- SCREEN (for first-person) â€” overlay in PlayerGui
    local screen = Instance.new("ScreenGui")
    screen.Name = "HandMortarTimingGui_Screen"
    screen.ResetOnSpawn = false
    screen.Parent = playerGui
    local sFrame = Instance.new("Frame")
    sFrame.Name = "Plate"
    sFrame.Size = UDim2.new(0, 120, 0, 60)
    -- Position: right of screen center (adjust as needed)
    sFrame.Position = UDim2.new(0.55, 0, 0.45, 0)
    sFrame.AnchorPoint = Vector2.new(0, 0)
    sFrame.BackgroundTransparency = 0.25
    sFrame.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
    sFrame.BorderSizePixel = 0
    sFrame.Parent = screen
    local sBarBg = Instance.new("Frame")
    sBarBg.Name = "BarBg"
    sBarBg.Size = UDim2.new(0, 10, 0, 36)
    sBarBg.Position = UDim2.new(0, 6, 0, 12)
    sBarBg.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    sBarBg.BorderSizePixel = 0
    sBarBg.Parent = sFrame
    local sFill = Instance.new("Frame")
    sFill.Name = "Fill"
    sFill.Size = UDim2.new(1, 0, 1, 0)
    sFill.Position = UDim2.new(0, 0, 0, 0)
    sFill.BackgroundColor3 = Color3.fromRGB(180, 80, 0)
    sFill.BorderSizePixel = 0
    sFill.Parent = sBarBg
    sFill.AnchorPoint = Vector2.new(0, 1)
    sFill.Position = UDim2.new(0, 0, 1, 0)
    local sTimer = Instance.new("TextLabel")
    sTimer.Name = "Timer"
    sTimer.Size = UDim2.new(0, 80, 0, 24)
    sTimer.Position = UDim2.new(0, 22, 0, 12)
    sTimer.BackgroundTransparency = 1
    sTimer.TextScaled = false
    sTimer.Font = Enum.Font.SourceSansBold
    sTimer.TextSize = 18
    sTimer.Text = ""
    sTimer.TextColor3 = Color3.fromRGB(255, 255, 255)
    sTimer.Parent = sFrame
    local sTitle = Instance.new("TextLabel")
    sTitle.Name = "Title"
    sTitle.Size = UDim2.new(0, 80, 0, 16)
    sTitle.Position = UDim2.new(0, 22, 0, 38)
    sTitle.BackgroundTransparency = 1
    sTitle.TextScaled = false
    sTitle.Font = Enum.Font.SourceSans
    sTitle.TextSize = 12
    sTitle.Text = "Hand Mortar"
    sTitle.TextColor3 = Color3.fromRGB(200, 200, 200)
    sTitle.Parent = sFrame
    handMortarGui = {
        billboard = bg,
        screen = screen,
    }
    -- hide both initially; startHandMortarTimer will set visibility
    bg.Enabled = false
    screen.Enabled = false
    return handMortarGui
end
local function destroyHandMortarGui()
    if handMortarUpdateConn then
        pcall(function() handMortarUpdateConn:Disconnect() end)
        handMortarUpdateConn = nil
    end
    if handMortarCameraConn then
        pcall(function() handMortarCameraConn:Disconnect() end)
        handMortarCameraConn = nil
    end
    if handMortarGui then
        if handMortarGui.billboard and handMortarGui.billboard.Parent then
            pcall(function() handMortarGui.billboard:Destroy() end)
        end
        if handMortarGui.screen and handMortarGui.screen.Parent then
            pcall(function() handMortarGui.screen:Destroy() end)
        end
        handMortarGui = nil
    end
    handMortarRunning = false
    handMortarEndTick = nil
end
-- Start/restart the timer for given duration (seconds, float)
local function startHandMortarTimer(duration)
    if not HAND_MORTAR_TIMING_ENABLED then return end
    if not duration or type(duration) ~= "number" then duration = HAND_MORTAR_DURATION end
    -- create gui if not present
    local gui = createHandMortarGui()
    -- attach billboard to head if possible
    local char = LocalPlayer.Character
    if char then
        local head = char:FindFirstChild("Head") or char:FindFirstChild("HumanoidRootPart")
        if head and head:IsA("BasePart") and gui.billboard then
            gui.billboard.Adornee = head
        end
    end
    -- mark end tick
    handMortarEndTick = tick() + duration
    handMortarRunning = true
    -- Decide initial visibility depending on first/third person
    local function updateVisibility()
        local fp = isFirstPerson()
        if gui.billboard then gui.billboard.Enabled = not fp end
        if gui.screen then gui.screen.Enabled = fp end
    end
    updateVisibility()
    -- Listen for camera changes so it toggles during countdown
    if handMortarCameraConn then
        -- already listening
    else
        handMortarCameraConn = RunService.RenderStepped:Connect(function()
            if not handMortarRunning then return end
            if handMortarGui then
                local fp = isFirstPerson()
                if handMortarGui.billboard then handMortarGui.billboard.Enabled = not fp end
                if handMortarGui.screen then handMortarGui.screen.Enabled = fp end
            end
        end)
    end
    -- ensure update connection for fill + text
    if handMortarUpdateConn then
        -- already updating; just restart (the loop will pick new end tick)
        return
    end
    handMortarUpdateConn = RunService.RenderStepped:Connect(function()
        if not handMortarRunning or not handMortarGui then
            destroyHandMortarGui()
            return
        end
        local remaining = math.max(0, handMortarEndTick - tick())
        local ratio = remaining / duration
        ratio = math.clamp(ratio, 0, 1)
        pcall(function()
            -- billboard
            if handMortarGui.billboard and handMortarGui.billboard.Parent then
                local plate = handMortarGui.billboard:FindFirstChild("BG") and handMortarGui.billboard.BG:FindFirstChild("Plate")
                if plate then
                    local barBg = plate:FindFirstChild("BarBg")
                    if barBg then
                        local fillFrame = barBg:FindFirstChild("Fill")
                        if fillFrame then
                            fillFrame.Size = UDim2.new(1, 0, ratio, 0)
                        end
                    end
                    local timerLabel = plate:FindFirstChild("Timer")
                    if timerLabel then
                        local ms = math.floor(remaining * 1000 + 0.5)
                        local sec = math.floor(ms / 1000)
                        local remMs = ms - sec * 1000
                        timerLabel.Text = string.format("%d.%03ds", sec, remMs)
                    end
                end
            end
            -- screen
            if handMortarGui.screen and handMortarGui.screen.Parent then
                local sFrame = handMortarGui.screen:FindFirstChild("Plate")
                if sFrame then
                    local sBarBg = sFrame:FindFirstChild("BarBg")
                    if sBarBg then
                        local sFill = sBarBg:FindFirstChild("Fill")
                        if sFill then
                            sFill.Size = UDim2.new(1, 0, ratio, 0)
                        end
                    end
                    local sTimer = sFrame:FindFirstChild("Timer")
                    if sTimer then
                        local ms = math.floor(remaining * 1000 + 0.5)
                        local sec = math.floor(ms / 1000)
                        local remMs = ms - sec * 1000
                        sTimer.Text = string.format("%d.%03ds", sec, remMs)
                    end
                end
            end
        end)
        if remaining <= 0 then
            -- finished
            destroyHandMortarGui()
        end
    end)
end
---------------------------------------------------------------------
-- NEW DETECTION: via animation played on the local Humanoid (supports both anims)
---------------------------------------------------------------------
local function attachHandMortarWatcher()
    -- We only need one AnimationPlayed connection; ignore extra calls
    if handMortarAnimConn then return end
    local char = LocalPlayer.Character
    if not char then return end
    local hum = char:FindFirstChildOfClass("Humanoid")
    if not hum then return end
    local function onAnimPlayed(track)
        local anim = track and track.Animation
        if not anim then return end
        local id = string.lower(tostring(anim.AnimationId or ""))
        -- If this is one of our Hand Mortar fuse animations, wait 1s then start the 5s countdown
        if HAND_MORTAR_ANIM_IDS[id] then
            -- we wait 1s from the animation start, then show the 5s countdown
            task.delay(1, function()
                -- safety checks
                if not HAND_MORTAR_TIMING_ENABLED then return end
                if not LocalPlayer.Character then return end
                -- start the 5s countdown after 1 second delay
                startHandMortarTimer(HAND_MORTAR_DURATION)
            end)
        end
    end
    local ok, conn = pcall(function()
        return hum.AnimationPlayed:Connect(onAnimPlayed)
    end)
    if ok and conn then
        handMortarAnimConn = conn
        table.insert(activeConnections, conn)
    end
end
-- re-attach on character spawn + cleanup previous gui
LocalPlayer.CharacterAdded:Connect(function(newChar)
    task.wait(0.1)
    if handMortarAnimConn then
        pcall(function() handMortarAnimConn:Disconnect() end)
        handMortarAnimConn = nil
    end
    attachHandMortarWatcher()
    destroyHandMortarGui()
end)
-- initial attach if character already loaded
pcall(function()
    attachHandMortarWatcher()
end)
-- UI: Misc section and toggle (only if GunTab exists)
if GunTab then
    local MiscGunSection = GunTab:Section({ Title = "Misc", Icon = "settings", Opened = false })
    -- UI Toggle
    MiscGunSection:Toggle({
        Title = "Hand Mortar Timing",
        Flag = "Misc_HandMortarTiming",
        Desc = "Shows The Timer Of The Mortar Before Blowing Up.",
        Icon = "clock",
        Value = HAND_MORTAR_TIMING_ENABLED,
        Callback = function(state)
            HAND_MORTAR_TIMING_ENABLED = state
            if not state then
                -- cleanup UI if disabled
                destroyHandMortarGui()
            end
        end
    })
end
print("Skibidi")
end-- End hand mortar feature


do
    local EspTab = Esp1Section:Tab({ Title = "Esp", Icon = "eye" })

    local ESPSection = EspTab:Section({
        Title = "ESP & Zombie Alerts",
        Icon = "eye",
        Opened = false
    })

    local RunService = RunService or game:GetService("RunService")
    local CameraFolder = workspace:FindFirstChild("Camera")
    local IdentifiedIgniters = {}
    local ESPConfigs = {
        Bomber = {
            color = Color3.fromRGB(255, 180, 60),
            label = "Barrel",
            match = function(model)
                if not model or not model:IsA("Model") then return false end
                local zType = GetZombieTypeFromModel and GetZombieTypeFromModel(model)
                if zType then return zType == "Bomber" end
                return model:FindFirstChild("Barrel", true) ~= nil
            end,
        },
        Cuirassier = {
            color = Color3.fromRGB(0, 200, 255),
            label = "Cuirassier",
            match = function(model)
                local zType = GetZombieTypeFromModel and GetZombieTypeFromModel(model)
                if zType then return zType == "Cuirassier" end
                return model:FindFirstChild("Sword", true) ~= nil
            end,
        },
        Runner = {
            color = Color3.fromRGB(255, 0, 0),
            label = "Runner",
            match = function(model)
                local zType = GetZombieTypeFromModel and GetZombieTypeFromModel(model)
                if zType then return zType == "Runner" end
                return model:FindFirstChild("Eye") and not model:FindFirstChild("Axe") and model:FindFirstChild("Head")
            end,
        },
        Zapper = {
            color = Color3.fromRGB(0, 255, 0),
            label = "Zapper",
            match = function(model)
                local zType = GetZombieTypeFromModel and GetZombieTypeFromModel(model)
                if zType then return zType == "Zapper" end
                return model:FindFirstChild("Axe") and model:FindFirstChild("Head")
            end,
        },
        Igniter = {
            color = Color3.fromRGB(255, 255, 0),
            label = "Igniter",
            match = function(model)
                if not model or not model:IsA("Model") then return false end
                local zType = GetZombieTypeFromModel and GetZombieTypeFromModel(model)
                if zType then return zType == "Igniter" end
                if model:FindFirstChild("Whale Oil Lantern") then
                    IdentifiedIgniters[model] = true
                    return true
                end
                -- If lantern is gone, remove from identified igniters so it can become a shambler
                if IdentifiedIgniters[model] and not model:FindFirstChild("Whale Oil Lantern") then
                    IdentifiedIgniters[model] = nil
                    return false
                end
                return false
            end,
        },
        -- NEW: Shambler (normal)
        Shambler = {
            color = Color3.fromRGB(180, 180, 255),
            label = "Shambler",
            match = function(model)
                if not model or not model:IsA("Model") then return false end
                local zType = GetZombieTypeFromModel and GetZombieTypeFromModel(model)
                if zType then return zType == "Shambler" end
                -- must be the regular zombie model
                if model.Name ~= "m_Zombie" then return false end
                -- if it has any special markers, it's NOT a Shambler
                if model:FindFirstChild("Barrel", true) then return false end
                if model:FindFirstChild("Sword", true) then return false end
                if model:FindFirstChild("Eye", true) then return false end
                if model:FindFirstChild("Axe", true) then return false end
                if model:FindFirstChild("Whale Oil Lantern", true) then return false end
                -- passed all checks -> normal shambler
                return true
            end,
        },
    }

    local ESPData = {
        Bomber = {},
        Cuirassier = {},
        Runner = {},
        Zapper = {},
        Igniter = {},
        Shambler = {}, -- added
    }

    local EnabledESPs = {
        Bomber = false,
        Cuirassier = false,
        Runner = false,
        Zapper = false,
        Igniter = false,
        Shambler = false, -- added
    }

    -- Hidden per-type visual mode (kept defaults from before; not exposed in UI)
    local ESPModes = {
        Bomber = "Both",
        Cuirassier = "Both",
        Runner = "Both",
        Zapper = "Both",
        Igniter = "Both",
        Shambler = "Both", -- added
    }

    -- Default: show billboards disabled
    local ShowBillboards = false
    local ChamsTransparency = 0.6
    local PerformanceMode = false
    local ChamsMaxDistance = 2000

    local activeCount = 0
    local scanLoop
    local renderConn

    local function GetAdorneePart(model)
        if not model or not model:IsA("Model") then return nil end
        local head = model:FindFirstChild("Head", true)
        if head and head:IsA("BasePart") then return head end
        local hrp = model:FindFirstChild("HumanoidRootPart", true)
        if hrp and hrp:IsA("BasePart") then return hrp end
        if model.PrimaryPart and model.PrimaryPart:IsA("BasePart") then return model.PrimaryPart end
        local children = model:GetChildren()
        local possible = children[12]
        if possible and possible:IsA("BasePart") then return possible end
        for _, p in ipairs(model:GetDescendants()) do
            if p:IsA("BasePart") and p.Name ~= "Whale Oil Lantern" then
                return p
            end
        end
        return nil
    end

local function CreateVisual(espType, zombie)
    if not zombie or not zombie:IsA("Model") or ESPData[espType][zombie] then return end
    local config = ESPConfigs[espType]
    local headPart = GetAdorneePart(zombie)
    if not headPart then return end

    local mode = ESPModes[espType] or "Both"
    local data = {}
    ESPData[espType][zombie] = data
    data.maxDistance = ChamsMaxDistance
    local offset = Vector3.new(0, 3, 0)

    -- Decide visuals independently:
    local wantHighlight = (mode == "Both" or mode == "Highlight Only") and (not PerformanceMode)
    local wantBillboard = (mode == "Both" or mode == "Billboard Only")
    -- In performance mode we always want a dot (unless the user explicitly picked "Billboard Only" and you
    -- want to change that behavior later). The user's request was: make it a dot with billboard in perf mode,
    -- except if billboard turned off â€” so dot is always created in PerformanceMode.
    local wantDot = (mode == "Dot Only") or PerformanceMode

    -- DOT (small billboard used as dot)
    if wantDot then
        local dotBb = Instance.new("BillboardGui")
        dotBb.Name = espType .. "Dot"
        dotBb.Adornee = headPart
        dotBb.AlwaysOnTop = true
        dotBb.Size = UDim2.new(0, 8, 0, 8)
        dotBb.StudsOffset = Vector3.new(0, 0, 0)
        dotBb.MaxDistance = ChamsMaxDistance
        dotBb.Parent = zombie
        data.dot = dotBb

        local dotFrame = Instance.new("Frame")
        dotFrame.Size = UDim2.new(1, 0, 1, 0)
        dotFrame.BackgroundColor3 = config.color
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0.5, 0)
        corner.Parent = dotFrame
        dotFrame.Parent = dotBb
    end

    -- HIGHLIGHT (only when not in performance mode)
    if wantHighlight then
        local hl = Instance.new("Highlight")
        hl.Name = espType .. "Highlight"
        hl.Adornee = zombie
        hl.FillColor = config.color
        hl.OutlineColor = Color3.fromRGB(255, 255, 255)
        hl.FillTransparency = ChamsTransparency
        hl.OutlineTransparency = 0
        hl.Parent = zombie
        data.highlight = hl
    end

    -- BILLBOARD (create regardless of whether a dot exists; Enabled will be controlled in UpdateAllBillboards)
    if wantBillboard then
        local bb = Instance.new("BillboardGui")
        bb.Name = espType .. "Billboard"
        bb.Adornee = headPart
        bb.AlwaysOnTop = true
        bb.LightInfluence = 0
        bb.Size = UDim2.new(0, 100, 0, 40)
        bb.StudsOffset = offset
        bb.MaxDistance = 1000
        bb.Enabled = ShowBillboards -- initial enabled state; UpdateAllBillboards will adjust per-distance
        bb.Parent = zombie
        data.billboard = bb

        local frame = Instance.new("Frame")
        frame.Size = UDim2.new(1, 0, 1, 0)
        frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
        frame.BackgroundTransparency = 0.7
        frame.BorderSizePixel = 1
        frame.BorderColor3 = config.color
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = frame
        frame.Parent = bb
        data.frame = frame

        local lbl = Instance.new("TextLabel")
        lbl.AnchorPoint = Vector2.new(0.5, 0)
        lbl.Position = UDim2.new(0.5, 0, 0.1, 0)
        lbl.Size = UDim2.new(0.9, 0, 0.5, 0)
        lbl.BackgroundTransparency = 1
        lbl.Text = config.label
        lbl.TextColor3 = config.color
        lbl.TextStrokeTransparency = 0.8
        lbl.TextScaled = true
        lbl.Font = Enum.Font.GothamBold
        lbl.Parent = frame
        data.label = lbl

        local distLbl = Instance.new("TextLabel")
        distLbl.AnchorPoint = Vector2.new(0.5, 1)
        distLbl.Position = UDim2.new(0.5, 0, 0.9, 0)
        distLbl.Size = UDim2.new(0.9, 0, 0.3, 0)
        distLbl.BackgroundTransparency = 1
        distLbl.Text = "0 studs"
        distLbl.TextColor3 = Color3.fromRGB(200, 200, 200)
        distLbl.TextScaled = true
        distLbl.Font = Enum.Font.Gotham
        distLbl.Parent = frame
        data.distLabel = distLbl
    end
end

    local function RemoveVisual(espType, zombie)
        local data = ESPData[espType][zombie]
        if not data then return end
        pcall(function()
            if data.highlight then data.highlight:Destroy() end
            if data.billboard then data.billboard:Destroy() end
            if data.dot then data.dot:Destroy() end
        end)
        ESPData[espType][zombie] = nil
    end

    -- Collect zombies from new Agent/Slim folders, with Camera fallback for legacy setups
    local function CollectZombies()
        local list = {}
        local zFolder = workspace:FindFirstChild("Zombies")
        if zFolder then
            local agent = zFolder:FindFirstChild("Agent")
            if agent then
                for _, z in ipairs(agent:GetChildren()) do
                    if z:IsA("Model") then
                        table.insert(list, z)
                    end
                end
            end
            local slim = zFolder:FindFirstChild("Slim")
            if slim then
                for _, z in ipairs(slim:GetChildren()) do
                    if z:IsA("Model") then
                        table.insert(list, z)
                    end
                end
            end
        end
        if #list == 0 and CameraFolder then
            for _, z in ipairs(CameraFolder:GetChildren()) do
                if z:IsA("Model") then
                    table.insert(list, z)
                end
            end
        end
        return list
    end

    local function ScanAll()
        local zombies = CollectZombies()
        for espType, enabled in pairs(EnabledESPs) do
            if enabled then
                local currentWithData = {}
                for z, _ in pairs(ESPData[espType]) do
                    currentWithData[z] = true
                end
                for _, z in ipairs(zombies) do
                    if z:IsA("Model") then
                        if ESPConfigs[espType].match(z) then
                            -- Check if zombie already has ESP from another type to prevent duplicates
                            local hasOtherESP = false
                            for otherType, otherData in pairs(ESPData) do
                                if otherType ~= espType and otherData[z] then
                                    hasOtherESP = true
                                    break
                                end
                            end
                            if not hasOtherESP and not ESPData[espType][z] then 
                                CreateVisual(espType, z) 
                            end
                            currentWithData[z] = nil
                        else
                            -- If doesn't match anymore, remove its ESP
                            if ESPData[espType][z] then
                                RemoveVisual(espType, z)
                            end
                        end
                    end
                end
                for z in pairs(currentWithData) do RemoveVisual(espType, z) end
            else
                for z in pairs(ESPData[espType]) do RemoveVisual(espType, z) end
                ESPData[espType] = {}
            end
        end
    end

    local function UpdateAllTransparencies()
        for espType, dataTable in pairs(ESPData) do
            for _, data in pairs(dataTable) do
                if data.highlight then data.highlight.FillTransparency = ChamsTransparency end
            end
        end
    end

local function UpdateAllBillboards()
    local Camera = workspace.CurrentCamera
    if not Camera then return end

    for espType, dataTable in pairs(ESPData) do
        for zombie, data in pairs(dataTable) do
            if not zombie or not zombie.Parent then
                RemoveVisual(espType, zombie)
            else
                -- figure out adornee / distance first
                local adornee = nil
                if data.billboard and data.billboard.Adornee then
                    adornee = data.billboard.Adornee
                elseif data.dot and data.dot.Adornee then
                    adornee = data.dot.Adornee
                end

                local shouldContinue = true
                if (not adornee) or (not adornee.Parent) then
                    local newPart = GetAdorneePart(zombie)
                    if newPart then
                        if data.billboard then data.billboard.Adornee = newPart end
                        if data.dot then data.dot.Adornee = newPart end
                        adornee = newPart
                    else
                        RemoveVisual(espType, zombie)
                        shouldContinue = false
                    end
                end

                if shouldContinue then
                    local ok, pos = pcall(function() return adornee.Position end)
                    if not ok or not pos then
                        RemoveVisual(espType, zombie)
                    else
                        local dist = (Camera.CFrame.Position - pos).Magnitude
                        local maxDist = data.maxDistance or ChamsMaxDistance

                        -- precompute flags once
                        local enabledForType = EnabledESPs[espType]
                        local highlightAllowed = enabledForType and (not PerformanceMode)
                        local dotAllowed       = enabledForType and PerformanceMode

                        -- HIGHLIGHT
                        if data.highlight then
                            data.highlight.Enabled = highlightAllowed and (dist <= maxDist)
                            data.highlight.FillTransparency = ChamsTransparency
                        end

                        -- DOT
                        if data.dot then
                            data.dot.Enabled = dotAllowed and (dist <= maxDist)
                            data.dot.MaxDistance = maxDist
                        end

                        -- BILLBOARD
                        if data.billboard then
                            if not ShowBillboards then
                                data.billboard.Enabled = false
                            else
                                local baseW, baseH = 100, 40
                                local scale

                                if not PerformanceMode then
                                    if dist < 300 then
                                        scale = math.clamp(30 / math.max(dist, 1), 0.5, 1.5)
                                        data.billboard.Enabled = true
                                    else
                                        data.billboard.Enabled = false
                                    end
                                else
                                    if dist < 500 then
                                        scale = math.clamp(30 / math.max(dist, 1), 0.5, 1.0)
                                        data.billboard.Enabled = true
                                    else
                                        data.billboard.Enabled = false
                                    end
                                end

                                if scale then
                                    data.billboard.Size = UDim2.new(0, math.floor(baseW * scale), 0, math.floor(baseH * scale))
                                end
                                if data.distLabel then
                                    data.distLabel.Text = math.floor(dist) .. " studs"
                                end
                            end
                        end
                    end
                end
            end
        end
    end
end

    local function StartShared()
        activeCount = activeCount + 1
        if activeCount == 1 then
            ScanAll()
            scanLoop = task.spawn(function()
                while activeCount > 0 do
                    ScanAll()
                    task.wait(0.25)
                end
            end)
            renderConn = RunService.RenderStepped:Connect(UpdateAllBillboards)
        end
    end

    local function StopShared()
        activeCount = activeCount - 1
        if activeCount == 0 then
            if scanLoop then task.cancel(scanLoop) scanLoop = nil end
            if renderConn then renderConn:Disconnect() renderConn = nil end
        end
    end

    local function TogglePerformanceMode(state)
        PerformanceMode = state
        for espType in pairs(ESPConfigs) do
            for zombie in pairs(ESPData[espType]) do RemoveVisual(espType, zombie) end
            ESPData[espType] = {}
        end
        ScanAll()
    end

    -- Cuirassier-specific state
    local LastChargeState = false
    local NotifyCuirassierCharge = false
    local CuirassierStateLoop

    local function IsCharging(state)
        state = tostring(state or ""):lower()
        return (state == "begincharge" or state == "charge")
    end

    local function UpdateCuirassierState()
        local zFolder = workspace:FindFirstChild("Zombies")
        if not zFolder then return end
        local slim = zFolder:FindFirstChild("Slim")
        if not slim then return end
        local stateVal = slim:FindFirstChild("State")
        if not stateVal or not stateVal:IsA("StringValue") then return end

        local charging = IsCharging(stateVal.Value)
        for _, data in pairs(ESPData.Cuirassier) do
            if data.label and (data.frame or true) then
                if charging then
                    data.label.Text = "Charging"
                    data.label.TextColor3 = Color3.fromRGB(255, 80, 80)
                    if data.frame then data.frame.BorderColor3 = Color3.fromRGB(255, 80, 80) end
                else
                    data.label.Text = "Cuirassier"
                    data.label.TextColor3 = ESPConfigs.Cuirassier.color
                    if data.frame then data.frame.BorderColor3 = ESPConfigs.Cuirassier.color end
                end
            end
        end
        if charging and NotifyCuirassierCharge and not LastChargeState then
            pcall(function()
                if WindUI and typeof(WindUI.Notify) == "function" then
                    WindUI:Notify({ Title = "Cuirassier Charge", Content = "A Cuirassier is Charging!", Icon = "bell", Duration = 3 })
                end
            end)
        end
        LastChargeState = charging
    end

    local function StartCuirassierSpecific()
        LastChargeState = false
        UpdateCuirassierState()
        CuirassierStateLoop = task.spawn(function()
            while EnabledESPs.Cuirassier do
                UpdateCuirassierState()
                task.wait(0.5)
            end
        end)
    end

    local function StopCuirassierSpecific()
        if CuirassierStateLoop then task.cancel(CuirassierStateLoop) CuirassierStateLoop = nil end
        LastChargeState = false
    end

    local function ApplyColorToExisting(espType, color)
        local dataTable = ESPData[espType]
        if not dataTable then return end
        for zombie, data in pairs(dataTable) do
            pcall(function()
                if data.highlight then data.highlight.FillColor = color end
                if data.frame then data.frame.BorderColor3 = color end
                if data.label then data.label.TextColor3 = color end
                if data.dot then
                    for _, child in ipairs(data.dot:GetDescendants()) do
                        if child:IsA("Frame") then child.BackgroundColor3 = color end
                    end
                end
            end)
        end
    end

-- ===== Improved multi-select ESP dropdown + enable toggle =====
local EspList = { "Bomber", "Cuirassier", "Runner", "Zapper", "Igniter", "Shambler" }
local SelectedESPs = {} -- list/table of selected types (default: empty)
local previousSelectedESPs = {}
local espToggle -- forward ref
ESPData = ESPData or {}       -- make sure table exists
EnabledESPs = EnabledESPs or {} -- ensure exists

-- helper: remove all visuals safely for given type
local function RemoveAllVisualsForType(typeName)
    local t = ESPData[typeName]
    if not t then return end
    -- ESPData entries are expected to map zombieModel -> visualObject; iterate keys safely
    for zombieModel, _ in pairs(t) do
        -- only call RemoveVisual if zombieModel looks valid
        pcall(function()
            if zombieModel and (type(zombieModel) == "table" or typeof(zombieModel) == "Instance") then
                RemoveVisual(typeName, zombieModel)
            end
        end)
    end
    -- clear the table
    ESPData[typeName] = {}
end

-- helper: check if any ESP type is currently enabled
local function AnyESPEnabled()
    for k, v in pairs(EnabledESPs) do
        if v then return true end
    end
    return false
end

local espDropdown = ESPSection:Dropdown({
    Title = "Select ESP Types",
    Flag = "DropdowwnEsp",
    Desc = "Type Of Zombies To Enable Esp At.",
    Values = EspList,
    Value = {},            -- default empty
    Multi = true,
    Callback = function(selection)
        local newSelection = selection or {}
        -- normalize to array of strings
        local normalized = {}
        for _, v in ipairs(newSelection) do table.insert(normalized, tostring(v)) end

        -- build lookup sets
        local prevSet = {}
        for _, v in ipairs(previousSelectedESPs) do prevSet[tostring(v)] = true end
        local newSet = {}
        for _, v in ipairs(normalized) do newSet[tostring(v)] = true end

        -- 1) Handle removals: previously selected but not present now
        for _, removedKey in ipairs(previousSelectedESPs) do
            if not newSet[tostring(removedKey)] then
                -- Always remove any visuals and clear runtime state for this type
                RemoveAllVisualsForType(removedKey)
                EnabledESPs[removedKey] = false
                -- Cuirassier specific cleanup
                if removedKey == "Cuirassier" then
                    pcall(function() StopCuirassierSpecific() end)
                end
                -- if no types enabled now, stop shared routines
                if not AnyESPEnabled() then pcall(function() StopShared() end) end

                pcall(function()
                    WindUI:Notify({
                        Title = (removedKey .. " ESP"),
                        Content = (removedKey .. " ESP disabled (deselected)"),
                        Icon = "eye-off",
                        Duration = 1
                    })
                end)
            end
        end

        -- 2) Update SelectedESPs / previousSelectedESPs
        SelectedESPs = {}
        for _, v in ipairs(normalized) do table.insert(SelectedESPs, v) end

        previousSelectedESPs = {}
        for _, v in ipairs(SelectedESPs) do table.insert(previousSelectedESPs, v) end

        -- 3) Sync toggle UI: if nothing selected -> false, else true only if *all* selected are enabled
        if espToggle then
            local anySelected = (#SelectedESPs > 0)
            if not anySelected then
                pcall(function() espToggle:Select(false) end)
            else
                local allEnabled = true
                for _, key in ipairs(SelectedESPs) do
                    if not EnabledESPs[key] then
                        allEnabled = false
                        break
                    end
                end
                pcall(function() espToggle:Select(allEnabled) end)
            end
        end

        pcall(function()
            WindUI:Notify({
                Title = "ESP Selection",
                Content = (#SelectedESPs > 0) and ("Selected: " .. table.concat(SelectedESPs, ", ")) or "No selection",
                Icon = "eye",
                Duration = 1
            })
        end)
    end
})

-- Toggle: enables/disables all currently selected ESP types
espToggle = ESPSection:Toggle({
    Title = "Enable Selected ESP",
    Flag = "Esp_Select_Toggle",
    Desc = "Enable Esp From The Selected Type.",
    Default = false,
    Callback = function(state)
        -- ensure SelectedESPs is a table
        if not SelectedESPs or #SelectedESPs == 0 then
            pcall(function() WindUI:Notify({ Title = "ESP", Content = "No ESP types selected.", Icon = "alert-circle", Duration = 2 }) end)
            -- keep the toggle UI false if nothing selected
            pcall(function() espToggle:Select(false) end)
            return
        end

        for _, key in ipairs(SelectedESPs) do
            -- skip invalid keys (guard block instead of goto)
            if key then
                -- only act if the state actually changes for that key
                if EnabledESPs[key] ~= state then
                    EnabledESPs[key] = state

                    if state then
                        -- enabling this ESP type
                        ESPData[key] = ESPData[key] or {}
                        pcall(function() StartShared() end)
                        if key == "Cuirassier" then pcall(function() StartCuirassierSpecific() end) end
                        pcall(function()
                            WindUI:Notify({ Title = (key .. " ESP"), Content = (key .. " ESP enabled"), Icon = "eye", Duration = 1 })
                        end)
                    else
                        -- disabling this ESP type: remove visuals & clear data
                        pcall(function() RemoveAllVisualsForType(key) end)
                        EnabledESPs[key] = false
                        if key == "Cuirassier" then pcall(function() StopCuirassierSpecific() end) end
                        -- only stop shared if nothing else is enabled
                        if not AnyESPEnabled() then pcall(function() StopShared() end) end
                        pcall(function()
                            WindUI:Notify({ Title = (key .. " ESP"), Content = (key .. " ESP disabled"), Icon = "eye-off", Duration = 1 })
                        end)
                    end
                end
            end
        end
    end
})

    -- =========================
    -- ESP Colors (unchanged + new Shambler color)
    -- =========================
    local ColorsSection = EspTab:Section({ Title = "ESP Colors", Icon = "palette", Opened = false })
    ColorsSection:Colorpicker({ Title = "Barrel (Bomber)", Flag = "Color1", Desc = "Color for Barrel zombies (Bomber)", Default = ESPConfigs.Bomber.color, Transparency = 0, Locked = false, Callback = function(color) ESPConfigs.Bomber.color = color ApplyColorToExisting("Bomber", color) end })
    ColorsSection:Colorpicker({ Title = "Cuirassier", Flag = "Color2", Desc = "Color for Cuirassier zombies", Default = ESPConfigs.Cuirassier.color, Transparency = 0, Locked = false, Callback = function(color) ESPConfigs.Cuirassier.color = color ApplyColorToExisting("Cuirassier", color) end })
    ColorsSection:Colorpicker({ Title = "Runner", Flag = "Color3", Desc = "Color for Runner zombies", Default = ESPConfigs.Runner.color, Transparency = 0, Locked = false, Callback = function(color) ESPConfigs.Runner.color = color ApplyColorToExisting("Runner", color) end })
    ColorsSection:Colorpicker({ Title = "Zapper", Flag = "Color4", Desc = "Color for Zapper zombies", Default = ESPConfigs.Zapper.color, Transparency = 0, Locked = false, Callback = function(color) ESPConfigs.Zapper.color = color ApplyColorToExisting("Zapper", color) end })
    ColorsSection:Colorpicker({ Title = "Igniter", Flag = "Color5", Desc = "Color for Igniter zombies", Default = ESPConfigs.Igniter.color, Transparency = 0, Locked = false, Callback = function(color) ESPConfigs.Igniter.color = color ApplyColorToExisting("Igniter", color) end })
    ColorsSection:Colorpicker({ Title = "Shambler (Normal)", Flag = "Color6", Desc = "Color for normal Shambler zombies", Default = ESPConfigs.Shambler.color, Transparency = 0, Locked = false, Callback = function(color) ESPConfigs.Shambler.color = color ApplyColorToExisting("Shambler", color) end })

    local SettingsSection = EspTab:Section({ Title = "Settings", Icon = "settings", Opened = false })
    SettingsSection:Toggle({ Title = "Show Billboard", Flag = "Esp_6", Desc = "Toggles billboards above the zombies", Default = false, Callback = function(state) ShowBillboards = state end })
    SettingsSection:Slider({ Title = "Chams Transparency", Flag = "Esp_7", Desc = "Controls the transparency of the chams", Value = { Min = 0, Max = 1, Default = 0.6 }, Step = 0.05, Callback = function(value) ChamsTransparency = math.clamp(tonumber(value) or 0.6, 0, 1) UpdateAllTransparencies() end })
    SettingsSection:Slider({
        Title = "Chams View Distance",
        Flag = "Esp_10",
        Desc = "Maximum distance to render zombie chams/highlights (in studs)",
        Value = { Min = 500, Max = 5000, Default = 2000 },
        Step = 100,
        Callback = function(value)
            ChamsMaxDistance = math.clamp(tonumber(value) or 2000, 500, 5000)
            for _, dataTable in pairs(ESPData) do
                for _, data in pairs(dataTable) do
                    data.maxDistance = ChamsMaxDistance
                    if data.dot then
                        data.dot.MaxDistance = ChamsMaxDistance
                    end
                end
            end
        end
    })
    SettingsSection:Toggle({ Title = "Performance", Flag = "Esp_8", Desc = "Makes chams into a dot and makes billboard simple", Default = false, Callback = function(state) TogglePerformanceMode(state) end })
    SettingsSection:Toggle({ Title = "Notify Cuirassier Charge", Flag = "Esp_9", Desc = "Sends a notification when a Cuirassier starts charging", Default = false, Callback = function(state) NotifyCuirassierCharge = state end })
end

do
local KillAuraTab = Main1Section:Tab({ Title = "Kill Aura", Icon = "sword" })

-- === Kill Aura + Hitbox Expander (Position-match Barrel Mapping) ===
-- Uses position matching to exclude camera barrel zombies from real zombie targeting

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

-- Config
local DEBUG = false
local POSITION_THRESHOLD = 0.1 -- studs tolerance for position matching
local POSITION_THRESHOLD_SQ = POSITION_THRESHOLD * POSITION_THRESHOLD

-- State variables
local KillAuraEnabled = false
local KillAuraRange = 10
local KillAuraAttackSpeed = 0.02
local KillAura_MaxRange = 30
local KillAuraMultiTargets = 1
local KillAuraAutoLook = false
local KillAura_AutoEquipMelee = false
local IgnoreSpawningZombies = true
local KillAura_HitboxExpanderEnabled = false
local KillAura_AttackBarrels = false

-- NEW: bayonet setting
local KillAura_EnableBayonet = false

-- ADDED: Store reference to Hitbox Expander toggle for programmatic control
local HitboxExpanderToggleElement = nil

-- Pause-on-grab support
local KillAura_pausedForGrab = false

-- Internal caches
local KillAura_remotes = {}
local KillAura_HeadCache = {}
local KillAura_IsIgniter = {}
local KillAura_BarrelCache = {}
local KillAura_lastRemoteScan = 0
local KillAura_lastBarrelScan = 0

-- NEW: Primary remote optimization
local KillAura_primaryRemote = nil
local KillAura_remotesCount = 0

-- NEW: Reusable targets table
local KillAura_targets = {}

-- NEW: Barrel update debounce
local barrelUpdateDebounce = false

local KillAura_weaponRangeOverrides = {
    Pike = 11,
    Axe = 9,
    -- OPTIONAL: tweak musket / bayonet range if you want it a bit longer
    Musket = 15,
}

local function KillAura_isPinnedOrGrabbed()
    local wsPlayers = Workspace:FindFirstChild("Players")
    if not wsPlayers then return false end
    local folder = wsPlayers:FindFirstChild(LocalPlayer and LocalPlayer.Name or "")
    if not folder then return false end
    local userStates = folder:FindFirstChild("UserStates")
    if not userStates then return false end

    local grabbedVal = userStates:FindFirstChild("Grabbed")
    local pinVal = userStates:FindFirstChild("Pin")

    local function valIndicatesTrue(v)
        if not v or v.Value == nil then return false end
        local val = v.Value
        if type(val) == "boolean" and val == true then return true end
        local n = tonumber(val)
        if n and n > 0 then return true end
        if tostring(val):lower() == "true" then return true end
        if tostring(val) == "RunnerAttack" then return true end
        return false
    end

    return valIndicatesTrue(grabbedVal) or valIndicatesTrue(pinVal)
end

-- Helper functions
local function KillAura_findHead(zombie)
    if not zombie or not zombie:IsA("Model") then return nil end
    return zombie:FindFirstChild("Head") or zombie:FindFirstChild("head") or 
           zombie:FindFirstChild("HumanoidRootPart") or zombie:FindFirstChildWhichIsA("BasePart")
end

local function KillAura_checkIgniter(z)
    if not (z and z:IsA("Model")) then return false end
    if KillAura_IsIgniter[z] == nil then
        KillAura_IsIgniter[z] = z:FindFirstChild("Whale Oil Lantern") ~= nil
    end
    return KillAura_IsIgniter[z]
end

local function KillAura_isSpawning(model)
    local agent = model:FindFirstChild("Agent")
    if not agent then return false end
    local state = agent:FindFirstChild("State")
    if not state or not state:IsA("StringValue") then return false end
    return state.Value == "Spawn"
end

local function KillAura_getCameraMZ()
    local cam = Workspace:FindFirstChild("Camera")
    if not cam then return nil end
    return cam:FindFirstChild("m_Zombie")
end

local function KillAura_distSq(a, b)
    local dx = a.X - b.X
    local dy = a.Y - b.Y
    local dz = a.Z - b.Z
    return dx*dx + dy*dy + dz*dz
end

local function KillAura_fireSwing(remote)
    if not (remote and remote:IsA("RemoteEvent")) then return end
    pcall(function() remote:FireServer("Swing", "Side") end)
end

local function KillAura_registerRemote(remote)
    if not (remote and remote:IsA("RemoteEvent")) then return nil end
    if not KillAura_remotes[remote] then
        KillAura_remotes[remote] = true
        KillAura_remotesCount = KillAura_remotesCount + 1
    end
    return remote
end

-- NEW: Primary remote getter
local function KillAura_getPrimaryRemote()
    if KillAura_primaryRemote and KillAura_remotes[KillAura_primaryRemote] then 
        return KillAura_primaryRemote 
    end
    for r,_ in pairs(KillAura_remotes) do
        KillAura_primaryRemote = r
        return r
    end
    return nil
end

-- NEW: Clear reusable table
local function clearTargets(t)
    for i = 1, #t do t[i] = nil end
end

-- NEW: Debounced barrel update
local function scheduleBarrelUpdate()
    if barrelUpdateDebounce then return end
    barrelUpdateDebounce = true
    task.delay(0.05, function()
        barrelUpdateDebounce = false
        KillAura_updateBarrelCache()
    end)
end

local function KillAura_updateBarrelCache()
    if tick() - KillAura_lastBarrelScan < 1 then return end
    KillAura_lastBarrelScan = tick()
    
    table.clear(KillAura_BarrelCache)
    
    local mZ = KillAura_getCameraMZ()
    local zombiesFolder = Workspace:FindFirstChild("Zombies")
    if not mZ or not zombiesFolder then return end
    
    local barrelPositions = {}
    for _, camVisual in ipairs(mZ:GetChildren()) do
        if camVisual and camVisual:IsA("Model") then
            local barrelPart = camVisual:FindFirstChild("Barrel")
            if barrelPart and barrelPart:IsA("BasePart") then
                table.insert(barrelPositions, barrelPart.Position)
            end
        end
    end
    
    if #barrelPositions == 0 then return end
    
    for _, real in ipairs(zombiesFolder:GetChildren()) do
        if real and real:IsA("Model") then
            local hrp = real:FindFirstChild("HumanoidRootPart") or real:FindFirstChild("Head") or real:FindFirstChildWhichIsA("BasePart")
            if hrp then
                local hrpPos = hrp.Position
                for _, bpos in ipairs(barrelPositions) do
                    local diffSq = KillAura_distSq(hrpPos, bpos)
                    if diffSq <= POSITION_THRESHOLD_SQ then
                        KillAura_BarrelCache[real] = true
                        break
                    end
                end
            end
        end
    end
end

-- Setup listeners
local CameraFolder = Workspace:FindFirstChild("Camera")
if CameraFolder then
    local mZombieFolder = CameraFolder:FindFirstChild("m_Zombie")
    if mZombieFolder then
        mZombieFolder.ChildAdded:Connect(scheduleBarrelUpdate)
        mZombieFolder.ChildRemoved:Connect(scheduleBarrelUpdate)
    else
        spawn(function()
            local cam = Workspace:WaitForChild("Camera")
            local mZ = cam:WaitForChild("m_Zombie")
            mZ.ChildAdded:Connect(scheduleBarrelUpdate)
            mZ.ChildRemoved:Connect(scheduleBarrelUpdate)
            KillAura_updateBarrelCache()
        end)
    end
end

local ZombiesFolder = Workspace:FindFirstChild("Zombies")
if ZombiesFolder then
    ZombiesFolder.ChildAdded:Connect(function(child)
        task.delay(0.2, function()
            local h = KillAura_findHead(child)
            if h then KillAura_HeadCache[child] = h end
            scheduleBarrelUpdate()
        end)
    end)
    ZombiesFolder.ChildRemoved:Connect(function(child)
        KillAura_HeadCache[child] = nil
        KillAura_IsIgniter[child] = nil
        KillAura_BarrelCache[child] = nil
    end)
    
    for _, z in ipairs(ZombiesFolder:GetChildren()) do
        local h = KillAura_findHead(z)
        if h then KillAura_HeadCache[z] = h end
    end
end

-- Remote scanning
local function KillAura_ScanRemotesNow()
    table.clear(KillAura_remotes)
    KillAura_primaryRemote = nil
    KillAura_remotesCount = 0
    local char = LocalPlayer.Character
    if not char then return end
    for _, tool in ipairs(char:GetChildren()) do
        if tool:IsA("Tool") then
            for _, c in ipairs(tool:GetChildren()) do
                if KillAura_registerRemote(c) and not KillAura_primaryRemote then
                    KillAura_primaryRemote = c
                end
            end
        end
    end
    KillAura_lastRemoteScan = tick()
end

LocalPlayer.CharacterAdded:Connect(function(char)
    task.wait(0.6)
    KillAura_ScanRemotesNow()
    char.ChildAdded:Connect(function(child)
        if child:IsA("Tool") then task.delay(0.05, KillAura_ScanRemotesNow) end
    end)
    char.ChildRemoved:Connect(function(child)
        if child:IsA("Tool") then task.delay(0.05, KillAura_ScanRemotesNow) end
    end)
end)
if LocalPlayer.Character then KillAura_ScanRemotesNow() end

local function KillAura_isGun(tool)
    if not tool or not tool:IsA("Tool") then return false end
    if tool:FindFirstChild("Ammo") or tool:FindFirstChild("ShotsLoaded") then return true end
    if tool:FindFirstChild("GunSettings") then return true end
    local cfg = tool:FindFirstChild("Configuration")
    if cfg and (cfg:FindFirstChild("Ammo") or cfg:FindFirstChild("ShotsLoaded")) then return true end
    return false
end

-- Helper: detect bayonet-usable tool (Musket) when enabled
local function KillAura_isBayonetTool(tool)
    if not (tool and tool:IsA("Tool")) then return false end
    if not KillAura_EnableBayonet then return false end
    local name = string.lower(tool.Name)
    -- You can tighten this check if your game uses a different name
    return name == "musket" or string.find(name, "musket")
end

local function KillAura_isMelee(tool)
    if not tool or not tool:IsA("Tool") then return false end

    -- Normal rule: guns are not melee
    if KillAura_isGun(tool) and not KillAura_isBayonetTool(tool) then
        return false
    end

    -- If bayonet is enabled and this is a Musket, treat it as melee
    if KillAura_isBayonetTool(tool) then
        return true
    end

    if tool:GetAttribute("Melee") == true then return true end
    if tool:FindFirstChild("Melee") or tool:FindFirstChild("MeleeConfig") then return true end
    local name = string.lower(tool.Name)
    return name:find("axe") or name:find("pike") or name:find("sword") or name:find("sabre") or name:find("bayonet") or name:find("dagger") or name:find("knife")
end

local function KillAura_findMeleeToolIn(container)
    if not container then return nil end
    for _, tool in ipairs(container:GetChildren()) do
        if KillAura_isMelee(tool) then
            return tool
        end
    end
    return nil
end

local function KillAura_getMeleeTool()
    local char = LocalPlayer.Character
    if not char then return nil end

    local equipped = KillAura_findMeleeToolIn(char)
    if equipped then return equipped end

    local backpack = LocalPlayer:FindFirstChildOfClass("Backpack") or LocalPlayer:FindFirstChild("Backpack")
    if not backpack then return nil end

    local stored = KillAura_findMeleeToolIn(backpack)
    if stored and KillAura_AutoEquipMelee then
        local ok = pcall(function()
            stored.Parent = char
        end)
        if ok then
            task.defer(KillAura_ScanRemotesNow)
            return stored
        end
    end

    return nil
end

local function KillAura_getWeaponRange(tool)
    local range = KillAuraRange
    if not tool then return range end

    local attrRange = tonumber(tool:GetAttribute("Range"))
    if attrRange then
        range = math.max(range, attrRange)
    end

    local override = KillAura_weaponRangeOverrides[tool.Name]
    if override then
        range = math.max(range, override)
    end

    return range
end

local function KillAura_getRemoteForTool(tool)
    if tool then
        local remote = tool:FindFirstChild("RemoteEvent")
        if not remote then
            remote = tool:FindFirstChildWhichIsA("RemoteEvent")
        end
        if remote then
            KillAura_registerRemote(remote)
            KillAura_primaryRemote = remote
            return remote
        end
    end
    return KillAura_getPrimaryRemote()
end

local function KillAura_shouldSkipZombie(model)
    if not (model and model:IsA("Model")) then return true end
    if KillAura_checkIgniter(model) then return true end
    if IgnoreSpawningZombies and KillAura_isSpawning(model) then return true end
    if KillAura_BarrelCache[model] then return true end

    if not KillAura_AttackBarrels then
        local attrTypeValue = ""
        if typeof(model.GetAttribute) == "function" then
            attrTypeValue = model:GetAttribute("Type") or ""
        end
        local attrType = tostring(attrTypeValue)
        if string.lower(attrType) == "barrel" then return true end
        local name = string.lower(tostring(model.Name or ""))
        if string.find(name, "barrel") then return true end
        if model:FindFirstChild("Barrel", true) then return true end
    end

    return false
end

-- INTEGRATED: Hybrid kill aura logic - Always uses Clear Zombie behavior
local function KillAura_performKillAura(hrp)
    if not KillAuraEnabled then return end

    local meleeTool = KillAura_getMeleeTool()
    if not meleeTool then return end

    if KillAura_remotesCount == 0 and tick() - KillAura_lastRemoteScan > 0.8 then
        KillAura_ScanRemotesNow()
    end

    local primaryRemote = KillAura_getRemoteForTool(meleeTool)
    if not primaryRemote then return end

    -- Detect if this swing should use bayonet logic
    local meleeName = string.lower(meleeTool.Name)
    local isBayonet = KillAura_isBayonetTool(meleeTool)

    local hrpPos = hrp.Position
    local effectiveRange = KillAura_getWeaponRange(meleeTool)
    local rangeSq = effectiveRange * effectiveRange

    -- Collect candidates then hit closest first to honor MultiTargets fully
    clearTargets(KillAura_targets)
    local count = 0
    for model, head in pairs(KillAura_HeadCache) do
        local valid = model and model.Parent and head and head.Parent
        if valid and not KillAura_shouldSkipZombie(model) then
            local d2 = KillAura_distSq(head.Position, hrpPos)
            if d2 <= rangeSq then
                count = count + 1
                KillAura_targets[count] = { model = model, head = head, d2 = d2 }
            end
        end
    end

    if count == 0 then return end
    table.sort(KillAura_targets, function(a, b) return a.d2 < b.d2 end)

    local maxTargets = math.clamp(math.floor(KillAuraMultiTargets or 1), 1, math.min(50, count))
    local firstTarget = KillAura_targets[1]
    for i = 1, maxTargets do
        local entry = KillAura_targets[i]
        if not entry then break end

        -- Axe specific logic
        if meleeTool.Name == "Axe" then
            local stateVal = entry.model:FindFirstChild("State")
            local stunned = stateVal and string.lower(tostring(stateVal.Value or "")) == "stunned"
            if not stunned then
                pcall(function()
                    primaryRemote:FireServer("BraceBlock")
                    primaryRemote:FireServer("StopBraceBlock")
                    primaryRemote:FireServer("FeedbackStun", entry.model, entry.head.Position)
                end)
            end
        end

        if isBayonet then
            -- BAYONET LOGIC: use ThrustBayonet + Bayonet_HitZombie
            pcall(function()
                primaryRemote:FireServer("ThrustBayonet")
                primaryRemote:FireServer("Bayonet_HitZombie", entry.model, entry.head.Position, true)
            end)
        else
            -- Default melee logic
            pcall(KillAura_fireSwing, primaryRemote)
            pcall(function()
                primaryRemote:FireServer("HitZombie", entry.model, entry.head.Position, true)
            end)
        end

        KillAura_targets[i] = nil -- clear slot
    end

    if KillAuraAutoLook and firstTarget then
        local targetPos = firstTarget.head.Position
        local hrpPosNow = hrp.Position
        local lookAt = Vector3.new(targetPos.X, hrpPosNow.Y, targetPos.Z)
        pcall(function() hrp.CFrame = CFrame.new(hrpPosNow, lookAt) end)
    end
end

local function KillAura_performAutoHead(hrp)
    if not KillAura_HitboxExpanderEnabled then return end
    if KillAura_remotesCount == 0 and tick() - KillAura_lastRemoteScan > 0.8 then
        KillAura_ScanRemotesNow()
    end
    
    -- Throttle barrel scan
    if tick() - KillAura_lastBarrelScan > 1 then 
        KillAura_updateBarrelCache() 
    end
    
    local maxRangeSqLocal = KillAura_MaxRange * KillAura_MaxRange
    local hrpPos = hrp.Position
    
    -- Reuse targets table
    clearTargets(KillAura_targets)
    local n = 0
    
    for model, head in pairs(KillAura_HeadCache) do
        local valid = model and model.Parent and head and head.Parent
        if valid and not KillAura_shouldSkipZombie(model) then
            local d2 = KillAura_distSq(head.Position, hrpPos)
            if d2 <= maxRangeSqLocal then
                n = n + 1
                KillAura_targets[n] = { model = model, head = head, d2 = d2 }
            end
        end
    end
    
    if n == 0 then return end
    table.sort(KillAura_targets, function(a, b) return a.d2 < b.d2 end)
    
    local meleeTool = KillAura_getMeleeTool()
    if not meleeTool then return end

    local primaryRemote = KillAura_getRemoteForTool(meleeTool)
    if not primaryRemote then return end

    local isBayonet = KillAura_isBayonetTool(meleeTool)
    
    local maxTargets = KillAuraEnabled and math.clamp(math.floor(KillAuraMultiTargets or 1), 1, n) or 1
    for i = 1, maxTargets do
        local entry = KillAura_targets[i]
        if not entry then break end
        
        if isBayonet then
            pcall(function()
                primaryRemote:FireServer("ThrustBayonet")
                primaryRemote:FireServer("Bayonet_HitZombie", entry.model, entry.head.Position, true)
            end)
        else
            pcall(function()
                primaryRemote:FireServer("HitZombie", entry.model, entry.head.Position, true)
            end)
        end
        
        -- Clear slot to avoid stale refs
        KillAura_targets[i] = nil
    end
end

-- Heartbeat loop (with pause-while-grabbed)
local KillAura_nextTick = 0
RunService.Heartbeat:Connect(function()
    local char = LocalPlayer.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    -- If grabbed/pinned, temporarily pause Kill Aura actions so Anti Grab can operate uninterrupted
    if KillAura_isPinnedOrGrabbed() then
        if not KillAura_pausedForGrab then
            KillAura_pausedForGrab = true
        end
        return -- skip performing auto-head / aura while pinned
    else
        if KillAura_pausedForGrab then
            KillAura_pausedForGrab = false
        end
    end

    if tick() < KillAura_nextTick then return end
    KillAura_nextTick = tick() + KillAuraAttackSpeed

    if tick() - KillAura_lastRemoteScan > 1 then KillAura_ScanRemotesNow() end
    -- Barrel scan is throttled inside performAutoHead

    KillAura_performAutoHead(hrp)
    KillAura_performKillAura(hrp)
end)

-- UI Creation
-- Hitbox Expander Settings
local HitboxExpanderSection = KillAuraTab:Section({ Title = "Reach", Icon = "box", Opened = false })

-- Store toggle element reference and use helper function
local function SetHitboxExpanderState(enabled)
    KillAura_HitboxExpanderEnabled = enabled
    
    -- Update UI toggle state without triggering callback if framework supports it
    if HitboxExpanderToggleElement and HitboxExpanderToggleElement.SetValue then
        HitboxExpanderToggleElement:SetValue(enabled)
    end
    
    WindUI:Notify({
        Title = "Reach",
        Content = enabled and "Reach Enabled" or "Reach Disabled",
        Duration = 2,
        Icon = enabled and "scan" or "x"
    })
end

-- ===== KillAura API for external suppression (AntiGrab) =====
local KillAura_SuppressedByAntiGrab = false
local KillAura_StoredEnabled = nil
local KillAura_StoredHitbox = nil

local function KillAura_suppressByAntiGrab()
    if KillAura_SuppressedByAntiGrab then return end
    KillAura_SuppressedByAntiGrab = true

    -- store current values to restore later
    KillAura_StoredEnabled = KillAuraEnabled
    KillAura_StoredHitbox = KillAura_HitboxExpanderEnabled

    -- force off
    KillAuraEnabled = false
    -- also force off hitbox/reach safely via helper (keeps UI state consistent if possible)
    pcall(SetHitboxExpanderState, false)

    pcall(function()
        if WindUI and WindUI.Notify then
            WindUI:Notify({ Title = "Kill Aura", Content = "Disabled by Anti-Grab", Duration = 1.5 })
        end
    end)
end

local function KillAura_unsuppressByAntiGrab()
    if not KillAura_SuppressedByAntiGrab then return end
    KillAura_SuppressedByAntiGrab = false

    -- restore previously stored state (only if we stored something)
    if KillAura_StoredEnabled ~= nil then
        KillAuraEnabled = KillAura_StoredEnabled
        KillAura_StoredEnabled = nil
    end
    if KillAura_StoredHitbox ~= nil then
        pcall(SetHitboxExpanderState, KillAura_StoredHitbox)
        KillAura_StoredHitbox = nil
    end

    pcall(function()
        if WindUI and WindUI.Notify then
            WindUI:Notify({ Title = "Kill Aura", Content = "Restored", Duration = 1.5 })
        end
    end)
end

-- expose API for other scripts (AntiGrab) in a robust way
if type(getgenv) == "function" then
    local g = getgenv()
    g.KillAuraAPI = g.KillAuraAPI or {}
    g.KillAuraAPI.suppress = KillAura_suppressByAntiGrab
    g.KillAuraAPI.unsuppress = KillAura_unsuppressByAntiGrab
else
    _G.KillAuraAPI = _G.KillAuraAPI or {}
    _G.KillAuraAPI.suppress = KillAura_suppressByAntiGrab
    _G.KillAuraAPI.unsuppress = KillAura_unsuppressByAntiGrab
end
-- ============================================================

HitboxExpanderToggleElement = HitboxExpanderSection:Toggle({
    Title = "Reach",
    Flag = "KillAura_HitboxExpander",
    Desc = "Will Reach The Zombie For About 30 studs (Might Be Lower)",
    Default = false,
    Callback = function(v)
        KillAura_HitboxExpanderEnabled = v
        WindUI:Notify({
            Title = "Reach",
            Content = v and "Reach Enabled" or "Reach Disabled",
            Duration = 2,
            Icon = v and "scan" or "x"
        })
    end
})

HitboxExpanderSection:Slider({
    Title = "Reach Range",
    Flag = "KillAura_HitboxRange",
    Desc = "Range of Reach",
    Step = 1,
    Value = { Min = 5, Max = 30, Default = KillAura_MaxRange },
    Callback = function(v)
        KillAura_MaxRange = v
    end
})

-- Kill Aura Settings
local KillAuraSection = KillAuraTab:Section({ Title = "Kill Aura", Icon = "sword", Opened = false })

KillAuraSection:Toggle({
    Title = "Kill Aura",
    Flag = "KillAura_Enabled",
    Desc = "Automatically Kills Zombie In Range",
    Default = false,
    Callback = function(v)
        KillAuraEnabled = v
        
        -- Auto-toggle Hitbox Expander to match Kill Aura state
        SetHitboxExpanderState(v)
        
        WindUI:Notify({
            Title = "Kill Aura",
            Content = v and "Kill Aura Enabled" or "Kill Aura Disabled",
            Duration = 2,
            Icon = v and "sword" or "x"
        })
    end
})

KillAuraSection:Slider({
    Title = "Kill Aura Range",
    Desc = "The Range Of Where Kill Aura Will Start Attacking If a zombie crosses the range.",
    Flag = "KillAura_Range",
    Step = 1,
    Value = { Min = 5, Max = 30, Default = KillAuraRange },
    Callback = function(v)
        KillAuraRange = v
    end
})

KillAuraSection:Slider({
    Title = "Attack Speed",
    Desc = "The attacking speed of kill aura",
    Flag = "KillAura_Speed",
    Step = 0.01,
    Value = { Min = 0.01, Max = 5, Default = KillAuraAttackSpeed },
    Callback = function(v)
        KillAuraAttackSpeed = v
    end
})

KillAuraSection:Slider({
    Title = "Multiple Targets",
    Flag = "KillAura_MultiTargets",
    Desc = "Controls how many zombies kill aura target",
    Step = 1,
    Value = { Min = 1, Max = 10, Default = KillAuraMultiTargets },
    Callback = function(v)
        KillAuraMultiTargets = math.max(1, math.floor(v))
    end
})

KillAuraSection:Toggle({
    Title = "Auto Equip Melee",
    Flag = "KillAura_AutoEquipMelee",
    Desc = "Automatically equips a melee from backpack when Kill Aura is on.",
    Default = KillAura_AutoEquipMelee,
    Callback = function(v)
        KillAura_AutoEquipMelee = v
    end
})

KillAuraSection:Toggle({
    Title = "Attack Barrels",
    Flag = "KillAura_AttackBarrels",
    Desc = "Allow targeting Barrel zombies (leave off to avoid explosions).",
    Default = KillAura_AttackBarrels,
    Callback = function(v)
        KillAura_AttackBarrels = v
        WindUI:Notify({
            Title = "Kill Aura",
            Content = v and "Barrel targeting enabled" or "Barrel targeting blocked",
            Duration = 2,
            Icon = v and "alert-triangle" or "shield"
        })
    end
})

-- NEW: Enable Bayonet Kill Aura setting
KillAuraSection:Toggle({
    Title = "Enable Bayonet Kill Aura",
    Flag = "KillAura_EnableBayonet",
    Desc = "Kill aura will use bayonet.",
    Default = KillAura_EnableBayonet,
    Callback = function(v)
        KillAura_EnableBayonet = v
        WindUI:Notify({
            Title = "Kill Aura",
            Content = v and "Bayonet Kill Aura Enabled" or "Bayonet Kill Aura Disabled",
            Duration = 2,
            Icon = v and "sword" or "x"
        })
    end
})

KillAuraSection:Toggle({
    Title = "Auto Look",
    Flag = "KillAura_AutoLook",
    Desc = "Automatically looks at the nearest zombie",
    Default = false,
    Callback = function(v)
        KillAuraAutoLook = v
        WindUI:Notify({
            Title = "Kill Aura",
            Content = v and "Auto Look ON" or "Auto Look OFF",
            Duration = 2,
            Icon = v and "eye" or "eye-off"
        })
    end
})

end -- end of KillAuraTab block

do -- // Classes Tab
    local ClassesTab = Main1Section:Tab({ Title = "Classes", Icon = "heart" })

    local MusicianSection = ClassesTab:Section({
        Title = "Musician",
        Icon = "music-2",
        Opened = false
    })

    -- Auto Play (fife/drum/bagpipe) â€” simplified, no lag, always finds tools
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")

    local LocalPlayer = Players.LocalPlayer

    -- start OFF by default; toggle controls everything
    local AutoInstrumentEnabled = false
    local autoplay = false

    -- configurable
    local playInterval = 2                -- seconds between Play attempts
    local accuracyCooldown = 0.5          -- seconds between UpdateAccuracy
    local defaultSong = "La Marseillaise" -- change this or wire a dropdown

    -- state & caches
    local guiCache = { fife = nil, drum = nil, bagpipe = nil }
    local connections = {}
    local currentSong = defaultSong

    local function safeDisconnect(conn)
        if conn and typeof(conn) == "RBXScriptConnection" then
            pcall(function()
                conn:Disconnect()
            end)
        end
    end

    local function instrumentTools()
        local char = LocalPlayer and LocalPlayer.Character
        if not char then return {} end
        local list = {}
        for _, tool in ipairs(char:GetChildren()) do
            if tool:IsA("Tool") and (tool.Name:find("Fife") or tool.Name:find("Drum") or tool.Name:find("Bagpipe")) then
                table.insert(list, tool)
            end
        end
        return list
    end

    local function tintInstrumentGui(enabled)
        local pg = LocalPlayer and LocalPlayer:FindFirstChild("PlayerGui")
        if not pg then return end

        local function handleGui(name, cacheKey)
            local gui = pg:FindFirstChild(name)
                or (ReplicatedStorage:FindFirstChild("Modules")
                and ReplicatedStorage.Modules:FindFirstChild("Weapons")
                and ReplicatedStorage.Modules.Weapons:FindFirstChild(name:gsub("Gui", ""))
                and ReplicatedStorage.Modules.Weapons[name:gsub("Gui", "")]:FindFirstChild(name))
            if not gui then return end
            local root = gui:FindFirstChild("Root")
            if not root then return end
            local bg = root:FindFirstChild("BG")
            if not bg then return end
            if enabled then
                if not guiCache[cacheKey] then
                    guiCache[cacheKey] = { bg.BackgroundColor3, bg.BackgroundTransparency }
                end
                bg.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                bg.BackgroundTransparency = 0
            elseif guiCache[cacheKey] then
                bg.BackgroundColor3 = guiCache[cacheKey][1]
                bg.BackgroundTransparency = guiCache[cacheKey][2]
            end
        end

        handleGui("FifeGui", "fife")
        handleGui("DrumGui", "drum")
        handleGui("BagpipesGui", "bagpipe")
    end

    local function fireUpdateAccuracy()
        if not autoplay then return end
        local tools = instrumentTools()
        for _, tool in ipairs(tools) do
            local remote = tool:FindFirstChild("RemoteEvent") or tool:FindFirstChild("Remote")
            if remote then
                pcall(function()
                    remote:FireServer("UpdateAccuracy", 100)
                end)
                break
            end
        end
    end

    local function firePlay()
        if not autoplay then return end
        local tools = instrumentTools()
        for _, tool in ipairs(tools) do
            local remote = tool:FindFirstChild("RemoteEvent") or tool:FindFirstChild("Remote")
            local soundSource = tool:FindFirstChild("Model")
                and tool.Model:FindFirstChild("Handle")
                and tool.Model.Handle:FindFirstChild("SoundSource")
            if remote and soundSource and not soundSource.IsPlaying then
                pcall(function()
                    remote:FireServer("Play", currentSong)
                end)
                -- no task.wait here = no lag spike
                break
            end
        end
    end

    -- single heartbeat loop (no spawn/wait spam)
    local function startAutoplayHeartbeat()
        if connections.heartbeat then return end
        local playTimer = 0
        local accuracyTimer = 0
        local tintTimer = 0

        connections.heartbeat = RunService.Heartbeat:Connect(function(dt)
            if not autoplay then return end

            playTimer = playTimer - dt
            accuracyTimer = accuracyTimer - dt
            tintTimer = tintTimer - dt

            if playTimer <= 0 then
                playTimer = playInterval
                firePlay()
            end

            if accuracyTimer <= 0 then
                accuracyTimer = accuracyCooldown
                fireUpdateAccuracy()
            end

            if tintTimer <= 0 then
                tintTimer = 0.5
                tintInstrumentGui(true)
            end
        end)
    end

    local function stopAutoplayHeartbeat()
        safeDisconnect(connections.heartbeat)
        connections.heartbeat = nil
    end

    local function startAutoplay()
        if autoplay then return end
        autoplay = true
        AutoInstrumentEnabled = true
        tintInstrumentGui(true)
        startAutoplayHeartbeat()
    end

    local function stopAutoplay()
        if not autoplay then return end
        autoplay = false
        AutoInstrumentEnabled = false
        tintInstrumentGui(false)
        stopAutoplayHeartbeat()
    end

    -- song picker helper: call this from your UI when player picks a song
    local function setAutoplaySong(songName)
        if type(songName) == "string" and #songName > 0 then
            currentSong = songName
        end
    end

    local function setAutoInstrument(state)
        if state then
            startAutoplay()
        else
            stopAutoplay()
        end
    end

    -- UI: Toggle (starts OFF; user must enable)
    MusicianSection:Toggle({
        Title = "Auto Play Fife/Drum/Bagpipe",
        Flag = "GunMod_AutoInstrument",
        Desc = "Automatically plays instruments.",
        Icon = "music-2",
        Value = AutoInstrumentEnabled,
        Callback = function(state)
            setAutoInstrument(state)
            WindUI:Notify({
                Title = "Gun Modifiers",
                Content = state and "Auto instrument ON" or "Auto instrument OFF",
                Duration = 2,
                Icon = state and "music-2" or "x"
            })
        end
    })

    local MedicSection = ClassesTab:Section({
        Title = "Medic",
        Icon = "heart",
        Opened = false
    })

    local AutoRequestHealEnabled = false
    local HealRange = 10
    local HealCooldown = 3
    local HealThreshold = 25
    local HealData = {}
    local HealNotify = {}

    local function RequestHeal(player, humanoid)
        if not player or not humanoid then return end
        if humanoid.Health > humanoid.MaxHealth * (HealThreshold / 100) then return end

        local lastReq = HealData[player] or 0
        if tick() - lastReq < HealCooldown then return end
        HealData[player] = tick()

        local localChar = LocalPlayer.Character
        if not localChar then return end
        local localHRP = localChar:FindFirstChild("HumanoidRootPart")
        if not localHRP then return end

        local targetHRP = humanoid.Parent:FindFirstChild("HumanoidRootPart") or humanoid.Parent:FindFirstChild("Torso")
        if not targetHRP then return end

        if (localHRP.Position - targetHRP.Position).Magnitude > HealRange then return end

        local medSupplies = localChar:FindFirstChild("Medical Supplies")
        if not medSupplies then return end
        local remote = medSupplies:FindFirstChild("RemoteEvent")
        if not remote then return end

        pcall(function()
            remote:FireServer("SendRequest", humanoid)
            local lastNotify = HealNotify[player] or 0
            if tick() - lastNotify >= HealCooldown then
                HealNotify[player] = tick()
                WindUI:Notify({
                    Title = "Auto Heal",
                    Content = "Requested heal for " .. player.Name,
                    Duration = 2,
                    Icon = "heart",
                })
            end
        end)
    end

    task.spawn(function()
        while task.wait(0.25) do 
            if AutoRequestHealEnabled then
                for _, player in ipairs(Players:GetPlayers()) do
                    if player ~= LocalPlayer and player.Character then
                        local humanoid = player.Character:FindFirstChildWhichIsA("Humanoid")
                        if humanoid and humanoid.Health <= humanoid.MaxHealth * (HealThreshold / 100) then
                            pcall(function() RequestHeal(player, humanoid) end)
                        end
                    end
                end
            end
        end
    end)

    MedicSection:Toggle({
        Title = "Auto Request Heal Dying Players",
        Flag = "Classes_1",
        Desc = "Automatically requests heal for players with low health when nearby",
        Default = false,
        Callback = function(state)
            AutoRequestHealEnabled = state
            WindUI:Notify({
                Title = "Auto Heal",
                Content = state and "Auto Request Heal Enabled" or "Auto Request Heal Disabled",
                Duration = 2,
                Icon = state and "heart" or "x",
            })
        end
    })

    MedicSection:Slider({
        Title = "Heal Threshold (%)",
        Flag = "Classes_2",
        Desc = "Health percentage threshold for auto heal",
        Step = 1,
        Value = {Min = 1, Max = 100, Default = HealThreshold},
        Callback = function(val)
            HealThreshold = val
        end
    })

    local SapperSection = ClassesTab:Section({
        Title = "Sapper",
        Icon = "hammer",
        Opened = false
    })

    local AutoRepairEnabled = false
    local AutoRepairCooldown = 0.1

    local function FireRepair(buildHealth)
        local char = LocalPlayer.Character
        if not (char and buildHealth) then return end

        local hammer = char:FindFirstChild("Hammer")
        if not hammer or not hammer:FindFirstChild("RemoteEvent") then return end

        local args = {"Repair", buildHealth}
        pcall(function()
            hammer.RemoteEvent:FireServer(unpack(args))
        end)
    end

    local function GetLookedStructure()
        local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then return nil end

        local origin = Workspace.CurrentCamera.CFrame.Position
        local direction = Workspace.CurrentCamera.CFrame.LookVector * 50

        local params = RaycastParams.new()
        params.FilterDescendantsInstances = {LocalPlayer.Character}
        params.FilterType = Enum.RaycastFilterType.Blacklist

        local rayResult = Workspace:Raycast(origin, direction, params)
        if not rayResult or not rayResult.Instance then return nil end

        local hit = rayResult.Instance
        local model = hit:FindFirstAncestorOfClass("Model")
        if not model then return nil end

        local buildHealth = model:FindFirstChild("BuildingHealth") or (model.Parent and model.Parent:FindFirstChild("BuildingHealth"))
        return buildHealth
    end

    task.spawn(function()
        while true do
            task.wait(AutoRepairCooldown)
            if AutoRepairEnabled then
                local buildHealth = GetLookedStructure()
                if buildHealth then
                    local currentHealth = buildHealth.Value
                    local maxHealth = buildHealth:GetAttribute("MaxHealth")

                    if maxHealth and currentHealth < maxHealth then
                        FireRepair(buildHealth)
                    end
                end
            end
        end
    end)

    SapperSection:Toggle({
        Title = "Auto Repair",
        Flag = "Classes_3",
        Desc = "Auto repair's Buildings",
        Default = false,
        Callback = function(state)
            AutoRepairEnabled = state
            WindUI:Notify({
                Title = "Auto Repair",
                Content = state and "Auto Repair enabled" or "Auto Repair disabled",
                Duration = 2,
                Icon = state and "wrench" or "x",
            })
        end
    })

-- Anti Grab (Sapper) + Improved Shove Aura (RETRY EQUIP UNTIL FREED)
-- Maintains earlier behavior but will keep equipping weapon/tool while pinned/grabbed.

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Workspace = workspace

-- config
local ToolNamesPriority = {"Carbine", "Navy Pistol", "Axe", "Pickaxe"}
local AntiGrabPollRate = 0.05
local AntiGrabRange = 12

local ShoveAuraRange = 12
local ShoveTargets = 3
local ShoveAuraCooldown = 0.10
local ShovePreferEquipped = true
local AutoParrySapperEnabled = false

-- Carbine/Navy combo settings
local ComboStunRange = 15
local ComboStunMaxTargets = 10
local ComboStunDelay = 0.10

local AntiGrabEnabled = false
local ShoveAuraEnabled = false
local shoving = false

local function safeWait(t)
    t = tonumber(t) or 0
    if t > 0 then task.wait(t) end
end

local function GetBackpack()
    if not LocalPlayer then return nil end
    return LocalPlayer:FindFirstChild("Backpack") or LocalPlayer:FindFirstChild("BackPack")
end

local function FindToolInstanceByName(toolName)
    if not toolName or not LocalPlayer then return nil end
    local char = LocalPlayer.Character
    if char then
        local t = char:FindFirstChild(toolName)
        if t and t:IsA("Tool") then return t end
    end
    local bp = GetBackpack()
    if bp then
        local t = bp:FindFirstChild(toolName)
        if t and t:IsA("Tool") then return t end
    end
    local wsPlayers = Workspace:FindFirstChild("Players")
    if wsPlayers then
        local folder = wsPlayers:FindFirstChild(LocalPlayer.Name)
        if folder then
            local t = folder:FindFirstChild(toolName)
            if t and t:IsA("Tool") then return t end
        end
    end
    return nil
end

local function TryEquipToolInstance(tool)
    if not tool or not LocalPlayer then return false end
    if LocalPlayer.Character and tool.Parent == LocalPlayer.Character then return true end

    -- try humanoid:EquipTool
    local char = LocalPlayer.Character
    if char then
        local humanoid = char:FindFirstChildOfClass("Humanoid")
        if humanoid then
            local ok = pcall(function() humanoid:EquipTool(tool) end)
            if ok then
                for i=1,8 do
                    if tool.Parent == LocalPlayer.Character then return true end
                    safeWait(0.05)
                end
            end
        end
    end

    -- fallback parent
    if LocalPlayer.Character then
        local ok2 = pcall(function() tool.Parent = LocalPlayer.Character end)
        if ok2 then
            for i=1,8 do
                if tool.Parent == LocalPlayer.Character then return true end
                    safeWait(0.05)
            end
        end
    end

    -- Player:EquipTool if exists
    if LocalPlayer and LocalPlayer.EquipTool then
        local ok3 = pcall(function() LocalPlayer:EquipTool(tool) end)
        if ok3 then
            for i=1,8 do
                if tool.Parent == LocalPlayer.Character then return true end
                safeWait(0.05)
            end
        end
    end

    return false
end

local function TryEquipFromBackpack(timeout)
    timeout = tonumber(timeout) or 0.8
    local start = tick()
    while tick() - start < timeout do
        for _, name in ipairs(ToolNamesPriority) do
            local candidate = FindToolInstanceByName(name)
            if candidate and candidate:IsA("Tool") then
                if LocalPlayer.Character and candidate.Parent == LocalPlayer.Character then
                    return name
                end
                local ok = TryEquipToolInstance(candidate)
                if ok then
                    safeWait(0.06)
                    return name
                end
            end
        end
        safeWait(0.06)
    end
    return nil
end

local function GetToolRemoteByName(toolName)
    if not toolName then return nil end
    local char = LocalPlayer.Character
    local bp = GetBackpack()
    local tool = (char and char:FindFirstChild(toolName)) or (bp and bp:FindFirstChild(toolName))
    if tool and tool:FindFirstChild("RemoteEvent") then return tool.RemoteEvent end
    local wsPlayers = Workspace:FindFirstChild("Players")
    if wsPlayers and wsPlayers:FindFirstChild(LocalPlayer.Name) then
        local folder = wsPlayers:FindFirstChild(LocalPlayer.Name)
        local toolFolder = folder:FindFirstChild(toolName)
        if toolFolder and toolFolder:FindFirstChild("RemoteEvent") then return toolFolder.RemoteEvent end
    end
    return nil
end

local function CollectZombiesForTargeting()
    local zombiesFolder = Workspace:FindFirstChild("Zombies")
    if not zombiesFolder then return {} end
    local list = {}
    local function collect(folder)
        if not folder then return end
        for _, z in ipairs(folder:GetChildren()) do
            if z and z:IsA("Model") then
                table.insert(list, z)
            end
        end
    end
    local agent = zombiesFolder:FindFirstChild("Agent")
    local slim = zombiesFolder:FindFirstChild("Slim")
    collect(agent)
    collect(slim)
    if #list == 0 then
        collect(zombiesFolder)
    end
    return list
end

local function FindNearestAgentParts(pos, maxRange, n)
    if not pos then return {} end
    n = n or 1
    local list = {}
    for _, z in ipairs(CollectZombiesForTargeting()) do
        local part = z:FindFirstChild("HumanoidRootPart") or z:FindFirstChildWhichIsA("BasePart")
        if part then
            local ok, d = pcall(function() return (part.Position - pos).Magnitude end)
            if ok and d and d <= (maxRange or math.huge) then
                table.insert(list, {part = part, dist = d, model = z})
            end
        end
    end
    table.sort(list, function(a,b) return a.dist < b.dist end)
    local out = {}
    for i=1, math.min(n, #list) do
        table.insert(out, list[i].part)
    end
    return out
end

local function GetZombiesInComboRange(originPos, radius, maxTargets)
    if not originPos then return {} end
    radius = radius or ComboStunRange
    maxTargets = maxTargets or ComboStunMaxTargets
    local zombies = CollectZombiesForTargeting()
    local list = {}
    for _, z in ipairs(zombies) do
        local hrp = z:FindFirstChild("HumanoidRootPart") or z:FindFirstChildWhichIsA("BasePart")
        if hrp then
            local d = (hrp.Position - originPos).Magnitude
            if d <= radius then
                table.insert(list, {model = z, part = hrp, dist = d})
            end
        end
    end
    table.sort(list, function(a,b) return a.dist < b.dist end)
    local out = {}
    for i=1, math.min(maxTargets, #list) do
        table.insert(out, list[i])
    end
    return out
end

local function PerformGunStunCombo(remote, originPos)
    if not remote or not originPos then return end
    local targets = GetZombiesInComboRange(originPos, ComboStunRange, ComboStunMaxTargets)
    for i, entry in ipairs(targets) do
        if entry.model and entry.part then
            pcall(function() remote:FireServer("FeedbackStun", entry.model, entry.part.Position) end)
            if i < #targets then safeWait(ComboStunDelay) end
        end
    end
end

-- make pinned/grabbed detection tolerant of numbers, numeric-strings, and booleans
local function IsPinnedOrGrabbed(grabbedVal, pinVal)
    if not grabbedVal and not pinVal then return false end

    if grabbedVal and grabbedVal.Value ~= nil then
        local v = grabbedVal.Value
        if type(v) == "boolean" and v == true then return true end
        local n = tonumber(v)
        if n and n > 0 then return true end
        -- also accept string "true"
        if tostring(v):lower() == "true" then return true end
    end

    if pinVal and pinVal.Value ~= nil then
        local v = pinVal.Value
        if type(v) == "boolean" and v == true then return true end
        local n = tonumber(v)
        if n and n > 0 then return true end
        if tostring(v) == "RunnerAttack" then return true end
        if tostring(v):lower() == "true" then return true end
    end

    return false
end

-- Live-check helper (reads current Workspace user state each time)
local function CurrentPinnedOrGrabbed()
    local wsPlayers = Workspace:FindFirstChild("Players")
    if not wsPlayers then return false end
    local folder = wsPlayers:FindFirstChild(LocalPlayer and LocalPlayer.Name or "")
    if not folder then return false end
    local userStates = folder:FindFirstChild("UserStates")
    if not userStates then return false end
    local grabbedVal = userStates:FindFirstChild("Grabbed")
    local pinVal = userStates:FindFirstChild("Pin")
    return IsPinnedOrGrabbed(grabbedVal, pinVal)
end

local function IsToolEquipped(toolName)
    if not toolName then return false end
    if not LocalPlayer or not LocalPlayer.Character then return false end
    return LocalPlayer.Character:FindFirstChild(toolName) ~= nil
end

local function FireShoveRemote(remote, agentPart, toolName)
    if not remote then return end
    local tname = tostring(toolName or "")
    local char = LocalPlayer.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if tname == "Carbine" or tname == "Navy Pistol" then
        pcall(function() remote:FireServer("Shove") end)
        if hrp then PerformGunStunCombo(remote, hrp.Position) end
    else
        if not agentPart then return end
        pcall(function() remote:FireServer("FeedbackStun", agentPart.Parent, agentPart.Position) end)
        pcall(function() remote:FireServer("StopBraceBlock") end)
    end
end

-- ALWAYS try to keep equipping while pinned; if tool disappears keep retrying until freed
local function StartShovingLoop(initialEquipName)
    if shoving then return end
    shoving = true

    task.spawn(function()
        local equippedName = initialEquipName
        local remote = equippedName and GetToolRemoteByName(equippedName) or nil

        while true do
            -- If AntiGrab disabled externally, break out
            if not AntiGrabEnabled then break end

            -- If not currently pinned/grabbed, attempt a small confirmation window
            if not CurrentPinnedOrGrabbed() then
                local releaseConfirmed = true
                -- require a few consecutive checks to avoid flicker issues
                for i = 1, 4 do
                    safeWait(AntiGrabPollRate) -- small pause per check
                    if CurrentPinnedOrGrabbed() then
                        releaseConfirmed = false
                        break
                    end
                end
                if releaseConfirmed then break end
            end

            -- ensure we have a valid equipped tool; if not, keep trying while still pinned
            if not (equippedName and IsToolEquipped(equippedName)) then
                -- try to equip preferred tools repeatedly while still pinned
                local tryStart = tick()
                local equipSuccess = nil
                while CurrentPinnedOrGrabbed() and (not equipSuccess) and (tick() - tryStart < 1.5) do
                    local newName = TryEquipFromBackpack(0.5)
                    if newName then
                        equippedName = newName
                        equipSuccess = true
                        break
                    end
                    -- small wait to avoid busy loop; we'll retry afterwards as well
                    safeWait(0.08)
                end
                -- refresh remote
                remote = equippedName and GetToolRemoteByName(equippedName) or nil
            end

            -- if remote missing try to refresh but don't block long (keep trying across loop iterations)
            if not remote and equippedName then
                remote = GetToolRemoteByName(equippedName)
            end

            -- perform shove attempts if we have hrp and targets
            local char = LocalPlayer.Character
            local hrp = char and char:FindFirstChild("HumanoidRootPart")
            if hrp then
                local targets = FindNearestAgentParts(hrp.Position, AntiGrabRange, 2)
                for _, agentPart in ipairs(targets) do
                    -- lightweight refresh of remote per-target
                    if not remote and equippedName then
                        remote = GetToolRemoteByName(equippedName)
                    end
                    if remote then
                        FireShoveRemote(remote, agentPart, equippedName)
                    end
                end
            end

            task.wait(0.06)
        end

        shoving = false
    end)
end

-- monitor loop (debounced) â€” now notifies Kill Aura to disable/restore
task.spawn(function()
    local lastState = false
    while true do
        task.wait(AntiGrabPollRate)
        if not AntiGrabEnabled then
            -- if anti-grab got disabled while previously suppressing, try to unsuppress KillAura
            if lastState then
                pcall(function()
                    local ka = (type(getgenv) == "function" and getgenv().KillAuraAPI) or _G.KillAuraAPI
                    if ka and ka.unsuppress then ka.unsuppress() end
                end)
            end
            lastState = false
        else

            local currentlyPinnedOrGrabbed = CurrentPinnedOrGrabbed()

        -- transition: not grabbed -> grabbed
        if currentlyPinnedOrGrabbed and not lastState then
            -- try to equip aggressively once the state transitions
            local equippedName = TryEquipFromBackpack(1.0)
            StartShovingLoop(equippedName)

            -- request Kill Aura be disabled while we're grabbed
            pcall(function()
                local ka = (type(getgenv) == "function" and getgenv().KillAuraAPI) or _G.KillAuraAPI
                if ka and ka.suppress then ka.suppress() end
            end)
        end

        -- ensure loop has started if pinned
        if currentlyPinnedOrGrabbed and not shoving then
            local equippedName = TryEquipFromBackpack(1.0)
            StartShovingLoop(equippedName)

            pcall(function()
                local ka = (type(getgenv) == "function" and getgenv().KillAuraAPI) or _G.KillAuraAPI
                if ka and ka.suppress then ka.suppress() end
            end)
        end

            -- transition: grabbed -> released (use lastState to detect transition)
            if (not currentlyPinnedOrGrabbed) and lastState then
                -- Ask Kill Aura to restore previous state (after release)
                pcall(function()
                    local ka = (type(getgenv) == "function" and getgenv().KillAuraAPI) or _G.KillAuraAPI
                    if ka and ka.unsuppress then ka.unsuppress() end
                end)
            end

            lastState = currentlyPinnedOrGrabbed
        end
    end
end)

-- Shove Aura: unchanged aside from using the same robust remote lookup and gun/melee behavior
local function RemoteFromToolInstance(tool)
    if not tool then return nil end
    if tool:FindFirstChild("RemoteEvent") then return tool.RemoteEvent end
    local wsPlayers = Workspace:FindFirstChild("Players")
    if wsPlayers and wsPlayers:FindFirstChild(LocalPlayer.Name) then
        local folder = wsPlayers:FindFirstChild(LocalPlayer.Name)
        local t = folder:FindFirstChild(tool.Name)
        if t and t:FindFirstChild("RemoteEvent") then return t.RemoteEvent end
    end
    return nil
end

local function GetBestToolRemoteAndName()
    if ShovePreferEquipped and LocalPlayer.Character then
        local equipped = LocalPlayer.Character:FindFirstChildOfClass("Tool")
        if equipped then
            local r = RemoteFromToolInstance(equipped)
            if r then return r, equipped.Name end
        end
    end

    for _, name in ipairs(ToolNamesPriority) do
        local charTool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild(name)
        if charTool then
            local r = RemoteFromToolInstance(charTool)
            if r then return r, name end
        end
        local back = GetBackpack()
        if back then
            local btool = back:FindFirstChild(name)
            if btool then
                local r = RemoteFromToolInstance(btool)
                if r then return r, name end
            end
        end
        local wsPlayers = Workspace:FindFirstChild("Players")
        if wsPlayers and wsPlayers:FindFirstChild(LocalPlayer.Name) then
            local folder = wsPlayers:FindFirstChild(LocalPlayer.Name)
            local ftool = folder:FindFirstChild(name)
            if ftool and ftool:FindFirstChild("RemoteEvent") then return ftool.RemoteEvent, name end
        end
    end
    return nil, nil
end

local function FireShove(remote, agentPart, toolName)
    if not remote then return end
    local tname = tostring(toolName or "")
    local char = LocalPlayer.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if tname == "Carbine" or tname == "Navy Pistol" then
        pcall(function() remote:FireServer("Shove") end)
        if hrp then PerformGunStunCombo(remote, hrp.Position) end
    else
        if not agentPart then return end
        pcall(function() remote:FireServer("FeedbackStun", agentPart.Parent, agentPart.Position) end)
        pcall(function() remote:FireServer("StopBraceBlock") end)
    end
end

task.spawn(function()
    while true do
        task.wait(ShoveAuraCooldown)
        if ShoveAuraEnabled then
            local char = LocalPlayer.Character
            local hrp = char and char:FindFirstChild("HumanoidRootPart")
            if hrp then
                local remote, rname = GetBestToolRemoteAndName()
                if not remote then
                    local equipName = TryEquipFromBackpack(0.6)
                    remote = equipName and GetToolRemoteByName(equipName) or nil
                    rname = rname or equipName
                end

                if remote then
                    local targets = FindNearestAgentParts(hrp.Position, ShoveAuraRange, ShoveTargets)
                    if #targets > 0 then
                        for _, part in ipairs(targets) do
                            FireShove(remote, part, rname)
                        end
                    end
                end
            end
        end
    end
end)

-- Auto Parry Zapper: spam BraceBlock when a zapper is close (uses ESP detection)
local function FindNearestZapper(pos, maxRange)
    local zombiesFolder = Workspace:FindFirstChild("Zombies")
    if not zombiesFolder or not pos then return nil end
    local nearest = nil
    local nearestDist = math.huge
    for _, z in ipairs(zombiesFolder:GetChildren()) do
        if z and z:IsA("Model") and isZombieOfType and isZombieOfType(z, "Zapper") then
            local part = z:FindFirstChild("HumanoidRootPart") or z:FindFirstChildWhichIsA("BasePart")
            if part then
                local d = (part.Position - pos).Magnitude
                if d <= (maxRange or math.huge) and d < nearestDist then
                    nearestDist = d
                    nearest = part
                end
            end
        end
    end
    return nearest, nearestDist
end

task.spawn(function()
    while true do
        task.wait(0.05)
        if AutoParrySapperEnabled then
            local char = LocalPlayer.Character
            local hrp = char and char:FindFirstChild("HumanoidRootPart")
            if hrp then
                local threshold = ShoveAuraEnabled and 5 or 10
                local zapperPart, dist = FindNearestZapper(hrp.Position, threshold)
                if zapperPart and dist and dist <= threshold then
                    local remote, rname = GetBestToolRemoteAndName()
                    if not remote then
                        local equipName = TryEquipFromBackpack(0.4)
                        remote = equipName and GetToolRemoteByName(equipName) or nil
                        rname = rname or equipName
                    end
                    if remote then
                        pcall(function() remote:FireServer("BraceBlock") end)
                    end
                end
            end
        end
    end
end)

SapperSection:Toggle({
    Title = "Anti Grab",
    Flag = "Classes_AntiGrab",
    Desc = "Will AutoMattically Shove The Zombie Grabbing You.",
    Default = false,
    Callback = function(v)
        AntiGrabEnabled = v
        if not v then shoving = false end
        pcall(function()
            if WindUI then
                WindUI:Notify({
                    Title = "Sapper â€” Anti Grab",
                    Content = v and "Anti Grab Enabled" or "Anti Grab Disabled",
                    Duration = 2,
                    Icon = v and "shield-check" or "shield-off",
                })
            end
        end)
    end
})

SapperSection:Toggle({
    Title = "Shove Aura",
    Flag = "Sapper_ShoveAura",
    Desc = "Auto Shoves Zombies Near You.",
    Default = ShoveAuraEnabled,
    Callback = function(v)
        ShoveAuraEnabled = v
        pcall(function()
            if WindUI and WindUI.Notify then
                WindUI:Notify({
                    Title = "Shove Aura",
                    Content = (v and ("Enabled â€” range: "..tostring(ShoveAuraRange)) ) or "Disabled",
                    Duration = 2,
                    Icon = v and "zap" or "x",
                })
            end
        end)
    end
})

SapperSection:Slider({
    Title = "Shove Range",
    Flag = "ShoveRange",
    Desc = "How Far Shove Aura Will Shove",
    Step = 1,
    Value = {
        Min = 1,
        Max = 30,
        Default = ShoveAuraRange,
    },
    Callback = function(val)
        ShoveAuraRange = math.max(1, math.floor(tonumber(val) or 1))
        pcall(function()
            if WindUI and WindUI.Notify then
                WindUI:Notify({ Title = "Shove Range", Content = tostring(ShoveAuraRange).." studs", Duration = 1 })
            end
        end)
    end
})

SapperSection:Slider({
    Title = "Shove Targets",
    Flag = "ShoveRange2",
    Desc = "How many nearest Zombies to target in 1 shove.",
    Step = 1,
    Value = {
        Min = 1,
        Max = 5,
        Default = ShoveTargets,
    },
    Callback = function(val)
        ShoveTargets = math.max(1, math.floor(tonumber(val) or 1))
    end
})

SapperSection:Slider({
    Title = "Shove Delay",
    Flag = "ShoveRange3",
    Desc = "controls how fast to shove.",
    Step = 0.01,
    Value = {
        Min = 0.02,
        Max = 0.5,
        Default = ShoveAuraCooldown,
    },
    Callback = function(val)
        ShoveAuraCooldown = math.clamp(tonumber(val) or 0.1, 0.02, 0.5)
    end
})

-- ======= Chaplain Section (only acts when Blessing tool is equipped; silent on failures) =======
local ChaplainSection = ClassesTab:Section({
    Title = "Chaplain",
    Icon = "pray",
    Opened = false
})

local PlayersSvc = game:GetService("Players")
local LocalPlayer = PlayersSvc.LocalPlayer

local AutoBlessEnabled = false
local BlessThreshold = 50         -- numeric threshold
local BlessCooldown = 2           -- seconds between blessings to same player
local BlessRange = 15             -- proximity requirement (studs)
local BlessData = {}              -- per-player cooldown storage (keyed by UserId)

-- Only look for the Blessing tool when it's equipped (in Character). If it's not equipped, do nothing silently.
local function GetEquippedBlessRemote()
    local localChar = LocalPlayer and LocalPlayer.Character
    if not localChar then return nil end
    local tool = localChar:FindFirstChild("Blessing")
    if tool and tool:FindFirstChild("RemoteEvent") then
        return tool:FindFirstChild("RemoteEvent")
    end
    -- also accept tools with 'bless' in the name (case-insensitive) when equipped
    for _, child in ipairs(localChar:GetChildren()) do
        if child:IsA("Tool") and child.Name:lower():find("bless") and child:FindFirstChild("RemoteEvent") then
            return child:FindFirstChild("RemoteEvent")
        end
    end
    return nil
end

-- Helper: returns true if target player is within range of local player
local function InRangeOfLocal(player, maxRange)
    local localChar = LocalPlayer and LocalPlayer.Character
    if not (localChar and localChar:FindFirstChild("HumanoidRootPart")) then return false end
    if not (player and player.Character) then return false end
    local targetHRP = player.Character:FindFirstChild("HumanoidRootPart") or player.Character:FindFirstChild("Torso")
    if not targetHRP then return false end
    return (localChar.HumanoidRootPart.Position - targetHRP.Position).Magnitude <= (maxRange or BlessRange)
end

-- Fire bless using the player's humanoid. Fail silently if tool not equipped, out of range, or humanoid missing.
local function FireBlessByPlayer_Silent(player)
    if not player then return false end

    -- require the blessing tool to be equipped (in character)
    local remote = GetEquippedBlessRemote()
    if not remote then
        return false
    end

    -- must be in range
    if not InRangeOfLocal(player, BlessRange) then
        return false
    end

    local humanoid = player.Character and player.Character:FindFirstChildWhichIsA("Humanoid")
    if not humanoid then
        return false
    end

    local ok, err = pcall(function()
        -- match Medic pattern: remote:FireServer("SendRequest", humanoid)
        remote:FireServer("SendRequest", humanoid)
    end)
    if not ok then
        -- fail silently
        return false
    end

    return true
end

-- Try common locations for a player's "Infected" value
local function GetPlayerInfectedValue(player)
    local ok, val = pcall(function()
        local wsPlayers = Workspace:FindFirstChild("Players")
        if wsPlayers then
            local wsP = wsPlayers:FindFirstChild(player.Name)
            if wsP and wsP:FindFirstChild("UserStates") and wsP.UserStates:FindFirstChild("Infected") then
                return wsP.UserStates.Infected.Value
            end
        end
        if player:FindFirstChild("UserStates") and player.UserStates:FindFirstChild("Infected") then
            return player.UserStates.Infected.Value
        end
        if player.Character and player.Character:FindFirstChild("UserStates") and player.Character.UserStates:FindFirstChild("Infected") then
            return player.Character.UserStates.Infected.Value
        end
        return nil
    end)
    if ok then return val end
    return nil
end

-- Main scan loop (silent on failures; only notifies on successful bless)
task.spawn(function()
    while task.wait(0.25) do
        if AutoBlessEnabled then
            for _, player in ipairs(PlayersSvc:GetPlayers()) do
                if player and player ~= LocalPlayer then
                    local infectedVal = nil
                    pcall(function()
                        infectedVal = GetPlayerInfectedValue(player)
                    end)

                    if infectedVal ~= nil then
                        -- normalize infectedVal to number
                        local numeric = nil
                        if type(infectedVal) == "number" then
                            numeric = infectedVal
                        elseif type(infectedVal) == "string" then
                            numeric = tonumber(infectedVal)
                        elseif type(infectedVal) == "boolean" then
                            numeric = infectedVal and 1 or 0
                        end

                        local thresholdNum = tonumber(BlessThreshold) or 0

                        if numeric and numeric >= thresholdNum then
                            local uid = player.UserId or player.Name
                            local last = BlessData[uid] or 0
                            if tick() - last >= (tonumber(BlessCooldown) or 0) then
                                local success = false
                                pcall(function()
                                    success = FireBlessByPlayer_Silent(player)
                                end)
                                if success then
                                    BlessData[uid] = tick()
                                    WindUI:Notify({
                                        Title = "Auto Bless",
                                        Content = "Sent bless to " .. player.Name,
                                        Duration = 2,
                                        Icon = "pray"
                                    })
                                end
                            end
                        end
                    end
                end
            end
        end
    end
end)

-- UI Controls
ChaplainSection:Toggle({
    Title = "Auto Bless Infected Players",
    Flag = "Classes_4",
    Desc = "turns on auto bless",
    Default = false,
    Callback = function(state)
        AutoBlessEnabled = state
        WindUI:Notify({
            Title = "Chaplain",
            Content = state and "Auto Bless Enabled" or "Auto Bless Disabled",
            Duration = 2,
            Icon = state and "pray" or "x"
        })
    end
})

ChaplainSection:Slider({
    Title = "Infected Threshold",
    Flag = "Classes_5",
    Desc = "threshold of auto bless",
    Step = 1,
    Value = {Min = 0, Max = 200, Default = BlessThreshold},
    Callback = function(val)
        BlessThreshold = tonumber(val) or 0
    end
})
-- ======= END Chaplain Section =======
end

do -- // Dracula (New) â€” auto melee remote scanner + robust ESP (Dracula + Silver)
    local Players = game:GetService("Players")
    local Workspace = game:GetService("Workspace")
    local CoreGui = game:GetService("CoreGui")
    local LocalPlayer = Players.LocalPlayer

    -- ===== SETTINGS (defaults) =====
    local DEBUG = false
    local DraculaLoopInterval = 0.1

    HitDraculaEnabled   = HitDraculaEnabled or false
    DraculaSpamCount    = DraculaSpamCount or 5
    DraculaRange        = DraculaRange or 15
    DraculaHitSpacing   = DraculaHitSpacing or 0.01  -- default as requested
    DraculaEspEnabled   = DraculaEspEnabled or false
    SilverEspEnabled    = SilverEspEnabled or false

    -- ===== INTERNALS =====
    local draculaRemotes = {}         -- [RemoteEvent] = true
    local lastDraculaRemoteScan = 0

    local draculaHighlight = nil
    local silverVisuals = {}          -- [Model] = {Highlight = hl, Billboard = bb, Text = txt}

    local ESP_HIGHLIGHT_SUPPORTED = true
    local ESP_GUI_PARENT = CoreGui    -- will fallback to PlayerGui if CoreGui blocked

    -- ===== HELPERS =====
    local function safePcall(fn, ...)
        local ok, a, b, c = pcall(fn, ...)
        return ok, a, b, c
    end

    local function getDracula()
        local trans = Workspace:FindFirstChild("Transylvania")
        if not trans then return nil end
        local modes = trans:FindFirstChild("Modes")
        if not modes then return nil end
        local boss = modes:FindFirstChild("Boss")
        if not boss then return nil end
        return boss:FindFirstChild("Dracula")
    end

    local function getSilverFolder()
        local trans = Workspace:FindFirstChild("Transylvania")
        if not trans then return nil end
        local modes = trans:FindFirstChild("Modes")
        if not modes then return nil end
        local boss = modes:FindFirstChild("Boss")
        if not boss then return nil end
        return boss:FindFirstChild("SilverTrinkets")
    end

    -- Try to determine a usable GUI parent for ESP (CoreGui preferred, fallback to PlayerGui)
    do
        local ok = pcall(function()
            local test = Instance.new("Folder")
            test.Parent = CoreGui
            test:Destroy()
        end)
        if not ok then
            -- fallback to PlayerGui if possible
            local playerGui = (LocalPlayer and LocalPlayer:FindFirstChild("PlayerGui"))
            if playerGui then
                ESP_GUI_PARENT = playerGui
            else
                -- attempt to wait for PlayerGui (if allowed)
                local s, r = pcall(function() return LocalPlayer:WaitForChild("PlayerGui", 2) end)
                if s and r then ESP_GUI_PARENT = r else ESP_HIGHLIGHT_SUPPORTED = false end
        end
        end
    end

    -- ===== Remote scanning (auto, continuous) =====
    local function ScanDraculaRemotes()
        table.clear(draculaRemotes)
        local char = LocalPlayer and LocalPlayer.Character
        if not char then return end
        for _, obj in ipairs(char:GetChildren()) do
            if obj:IsA("Tool") then
                for _, ch in ipairs(obj:GetChildren()) do
                    if ch and ch:IsA("RemoteEvent") then
                        draculaRemotes[ch] = true
                    end
                end
            end
        end
        lastDraculaRemoteScan = tick()
        if DEBUG then
            local c = 0
            for _ in pairs(draculaRemotes) do c = c + 1 end
            print("[Dracula] remotes scanned:", c)
        end
    end

    -- initial scan + hooks
    if LocalPlayer.Character then ScanDraculaRemotes() end
    LocalPlayer.CharacterAdded:Connect(function(char)
        task.wait(0.5)
        ScanDraculaRemotes()
        char.ChildAdded:Connect(function(c)
            if c and c:IsA("Tool") then task.delay(0.05, ScanDraculaRemotes) end
        end)
        char.ChildRemoved:Connect(function(c)
            if c and c:IsA("Tool") then task.delay(0.05, ScanDraculaRemotes) end
        end)
    end)

    -- background auto-scan (always on)
    task.spawn(function()
        while true do
            task.wait(1)
            ScanDraculaRemotes()
        end
    end)

    -- ===== Remote action helpers =====
    local function fireSwingRemote(remote)
        if not (remote and remote:IsA("RemoteEvent")) then return end
        pcall(function() remote:FireServer("Swing", "Side") end)
    end

    local function fireHitAtDracula(remote, dracModel)
        if not (remote and dracModel) then return end
        local ok, pivot = pcall(function() return dracModel:GetPivot().Position end)
        if not ok or not pivot then return end

        local offset = Vector3.new(
            (math.random() - 0.5) * 6,
            (math.random() - 0.5) * 4,
            (math.random() - 0.5) * 6
        )
        local hitPos = pivot + offset

        local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        local hrpPos = (hrp and hrp.Position) or pivot
        local delta = hitPos - hrpPos
        local ok2, dir = pcall(function() return delta.Unit end)
        if not ok2 or not dir then return end
        local normal = -dir
        local velocity = dir * 25

        pcall(function()
            remote:FireServer("HitZombie", dracModel, hitPos, false, velocity, "Collision", normal)
        end)
    end

    -- ===== ESP helpers =====
    local function safeCreateHighlight(parent, adornee, fillColor, outlineColor, fillTransparency)
        if not ESP_HIGHLIGHT_SUPPORTED then return nil, "not_supported" end
        local ok, hl = pcall(function()
            local h = Instance.new("Highlight")
            h.Name = "Katchi_Dracula_HL"
            h.Adornee = adornee
            if fillColor then h.FillColor = fillColor end
            if outlineColor then h.OutlineColor = outlineColor end
            if fillTransparency then h.FillTransparency = fillTransparency end
            h.Parent = parent
            return h
        end)
        if not ok then
            ESP_HIGHLIGHT_SUPPORTED = false
            return nil, "create_failed"
        end
        return hl
    end

    local function safeCreateBillboard(parent, adornee)
        local ok, bb = pcall(function()
            local b = Instance.new("BillboardGui")
            b.Adornee = adornee
            b.Size = UDim2.new(0, 200, 0, 40)
            b.StudsOffset = Vector3.new(0, 3, 0)
            b.AlwaysOnTop = true
            b.Parent = parent
            local txt = Instance.new("TextLabel")
            txt.Size = UDim2.new(1, 0, 1, 0)
            txt.BackgroundTransparency = 1
            txt.TextColor3 = Color3.new(1, 1, 1)
            txt.TextStrokeTransparency = 0
            txt.Font = Enum.Font.GothamBold
            txt.TextScaled = true
            txt.Parent = b
            return b, txt
        end)
        if not ok then return nil, nil, "create_failed" end
        return bb, bb:FindFirstChildOfClass("TextLabel")
    end

    -- update Dracula Highlight state
    local function updateDraculaESP()
        local drac = getDracula()
        if not DraculaEspEnabled or not drac then
            if draculaHighlight then
                pcall(function() draculaHighlight:Destroy() end)
                draculaHighlight = nil
            end
            return
        end

        if draculaHighlight then return end

        -- create highlight (use previously chosen parent)
        local parent = ESP_GUI_PARENT
        local hl, err = safeCreateHighlight(parent, drac, Color3.fromRGB(255,0,0), Color3.fromRGB(255,255,255), 0.6)
        if not hl then
            -- highlight creation failed â€” disable Dracula ESP to avoid spamming errors
            DraculaEspEnabled = false
            if DEBUG then warn("[Dracula] Highlight failed:", err) end
            return
        end
        draculaHighlight = hl
    end

    -- clear all silver visuals
    local function clearSilverESP()
        for model, data in pairs(silverVisuals) do
            pcall(function()
                if data.Highlight then data.Highlight:Destroy() end
                if data.Billboard then data.Billboard:Destroy() end
            end)
            silverVisuals[model] = nil
        end
    end

    -- update Silver ESP (robust: re-resolves folder, auto-assigns PrimaryPart, GUI parent fallback)
    local function updateSilverESP()
        local silverFolderNow = getSilverFolder()
        if not silverFolderNow then
            clearSilverESP()
            return
        end

        if not SilverEspEnabled then
            clearSilverESP()
            return
        end

        local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        local hrpPos = hrp and hrp.Position

        -- choose GUI parent dynamically in case CoreGui got blocked after script start
        local parent = ESP_GUI_PARENT
        if not parent or not parent.Parent then
            -- try fallback
            parent = LocalPlayer:FindFirstChild("PlayerGui") or parent
        end

        for _, trinket in ipairs(silverFolderNow:GetChildren()) do
            if not trinket:IsA("Model") then continue end

            -- ensure PrimaryPart exists (auto-assign first BasePart)
            if not trinket.PrimaryPart then
                local bp = trinket:FindFirstChildWhichIsA("BasePart")
                if bp then
                    pcall(function() trinket.PrimaryPart = bp end)
                else
                    -- can't display without a part
                    continue
                end
            end

            if not silverVisuals[trinket] then
                -- attempt to create highlight & billboard; if fails, disable Silver ESP
                local okHl, hl = pcall(function()
                    return safeCreateHighlight(parent, trinket, Color3.fromRGB(200,200,255), Color3.fromRGB(255,255,255), 0.5)
                end)
                if not okHl or not hl then
                    -- highlight not supported â€” try to fallback to only billboard
                    local okBB, bb, txt = pcall(function() return safeCreateBillboard(parent, trinket.PrimaryPart) end)
                    if okBB and bb and txt then
                        silverVisuals[trinket] = { Highlight = nil, Billboard = bb, Text = txt }
                    else
                        -- GUI creation failing; disable Silver ESP to avoid errors
                        SilverEspEnabled = false
                        clearSilverESP()
                        if DEBUG then warn("[SilverESP] Creation failed; disabling Silver ESP") end
                        return
                    end
                else
                    -- create billboard too
                    local bb, txt = safeCreateBillboard(parent, trinket.PrimaryPart)
                    silverVisuals[trinket] = { Highlight = hl, Billboard = bb, Text = txt }
                end
            end
        end

        -- update distances and cleanup removed trinkets
        for model, data in pairs(silverVisuals) do
            if not model.Parent or not model.PrimaryPart then
                pcall(function()
                    if data.Highlight then data.Highlight:Destroy() end
                    if data.Billboard then data.Billboard:Destroy() end
                end)
                silverVisuals[model] = nil
            else
                if hrpPos and data.Text then
                    local dist = (hrpPos - model.PrimaryPart.Position).Magnitude
                    data.Text.Text = string.format("Silver: %.1f", dist)
                end
            end
        end
    end

    -- background updater for Silver ESP (lightweight)
    task.spawn(function()
        while true do
            task.wait(0.15)
            if SilverEspEnabled then pcall(updateSilverESP) end
        end
    end)

    -- ===== Dracula attack loop (with loop-id cancellation) =====
    local currentDraculaLoopId = 0

    task.spawn(function()
        while true do
            task.wait(DraculaLoopInterval)
            if not HitDraculaEnabled then
                -- keep ESP in sync
                pcall(updateDraculaESP)
                continue
            end

            -- new tick: increment loop id to cancel previous spawned tasks
            currentDraculaLoopId = currentDraculaLoopId + 1
            local loopId = currentDraculaLoopId

            local drac = getDracula()
            local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if not (drac and hrp) then
                pcall(updateDraculaESP)
                continue
            end

            -- distance check (safe)
            local ok, pivot = pcall(function() return drac:GetPivot().Position end)
            if not ok or not pivot then
                pcall(updateDraculaESP)
                continue
            end
            local dist = (pivot - hrp.Position).Magnitude
            if dist > DraculaRange then
                pcall(updateDraculaESP)
                continue
            end

            -- ensure remotes are fresh
            if tick() - lastDraculaRemoteScan > 1 then ScanDraculaRemotes() end

            -- update ESP
            pcall(updateDraculaESP)

            -- 1) Swing spam: spawn cancellable tasks
            local spam = math.clamp(math.floor(DraculaSpamCount or 1), 1, 25)
            for remote in pairs(draculaRemotes) do
                if remote then
                    task.spawn(function()
                        for i = 1, spam do
                            if not HitDraculaEnabled or loopId ~= currentDraculaLoopId then break end
                            fireSwingRemote(remote)
                            task.wait(0.01)
                        end
                    end)
                    -- 2) Hit packets burst (also cancellable inside)
                    task.spawn(function()
                        for i = 1, 3 do
                            if not HitDraculaEnabled or loopId ~= currentDraculaLoopId then break end
                            fireHitAtDracula(remote, drac)
                            task.wait(DraculaHitSpacing)
                        end
                    end)
                end
            end
        end
    end)

    -- ===== UI =====
    local DraculaTab = (typeof(DraculaTab) ~= "nil" and DraculaTab) or Event1Section:Tab({ Title = "Dracula", Icon = "flame" })
    local HitSection = DraculaTab:Section({ Title = "Hit Dracula", Icon = "flame", Opened = false })

    HitSection:Toggle({
        Title = "Hit Dracula",
        Flag = "Dracula_1",
        Desc = "Automatically attack Dracula using any melee.",
        Default = HitDraculaEnabled,
        Callback = function(v)
            HitDraculaEnabled = v
            if not v then
                -- cancel any running tasks
                currentDraculaLoopId = currentDraculaLoopId + 1
            end
            WindUI:Notify({
                Title = "Dracula",
                Content = v and "Hit Dracula Enabled" or "Hit Dracula Disabled",
                Duration = 2,
                Icon = v and "flame" or "x",
            })
            pcall(updateDraculaESP)
        end
    })

    HitSection:Slider({
        Title = "Swing Spam Count",
        Flag = "Dracula_2",
        Desc = "Swings per tick (1â€“25).",
        Step = 1,
        Value = { Min = 1, Max = 25, Default = DraculaSpamCount },
        Callback = function(v) DraculaSpamCount = math.clamp(math.floor(v), 1, 25) end
    })

    HitSection:Slider({
        Title = "Dracula Range",
        Flag = "Dracula_3",
        Desc = "Attack distance (1â€“25 studs).",
        Step = 1,
        Value = { Min = 1, Max = 25, Default = DraculaRange },
        Callback = function(v) DraculaRange = math.clamp(v, 1, 25) end
    })

    local EspSection = DraculaTab:Section({ Title = "ESP", Icon = "eye", Opened = false })

    EspSection:Toggle({
        Title = "Dracula ESP",
        Flag = "Dracula_4",
        Desc = "Highlight Dracula.",
        Default = DraculaEspEnabled,
        Callback = function(v)
            DraculaEspEnabled = v
            if not v and draculaHighlight then
                pcall(function() draculaHighlight:Destroy() end)
                draculaHighlight = nil
            end
            WindUI:Notify({
                Title = "Dracula ESP",
                Content = v and "Enabled" or "Disabled",
                Duration = 2,
                Icon = v and "eye" or "x",
            })
            pcall(updateDraculaESP)
        end
    })

    EspSection:Toggle({
        Title = "Silver ESP",
        Flag = "Dracula_5",
        Desc = "Highlights Silver Trinkets + shows distance.",
        Default = SilverEspEnabled,
        Callback = function(v)
            -- If highlight/GUIs unsupported, we auto-disable and notify
            if v and not ESP_HIGHLIGHT_SUPPORTED then
                WindUI:Notify({
                    Title = "Silver ESP",
                    Content = "ESP features not supported by executor â€” disabled.",
                    Duration = 3,
                    Icon = "x",
                })
                SilverEspEnabled = false
                return
            end

            SilverEspEnabled = v
            if not v then clearSilverESP() end
            WindUI:Notify({
                Title = "Silver ESP",
                Content = v and "Enabled" or "Disabled",
                Duration = 2,
                Icon = v and "eye" or "x",
            })
        end
    })
end

do -- // Players Tab
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local Workspace = game:GetService("Workspace")
    local LocalPlayer = Players.LocalPlayer

    local PlayersTab = Esp1Section:Tab({ Title = "Players", Icon = "users" })

    local PlayerESPSection = PlayersTab:Section({
        Title = "Player ESP",
        Icon = "user-check",
        Opened = false
    })

    -- flags
    local ChamsESPEnabled = false
    local BillboardESPEnabled = false
    local NotifyLowHealthEnabled = false
    local PlayerESPData = {}

    -- New toggles for bars (default OFF)
    local ShowHealthBarEnabled = false
    local ShowInfectionBarEnabled = false

    -- Configuration variables
    local ChamsFillTransparency = 0.45
    local PerformanceModeEnabled = false
    local BillboardShowDistance = 5 -- Slider value for "too close" fade
    local NotifyGrabbedPinnedEnabled = false

    -- CONFIG (tweak to taste)
    local BILLBOARD_MAX_DISTANCE = 150 -- Roblox's native MaxDistance
    -- moved further down so the billboard sits clearly below the player
    local HEALTH_BILLBOARD_OFFSET = Vector3.new(0, -6.5, 0)
    local STUDS_SMOOTH_ALPHA = 0.22

    -- Make the whole billboard smaller per request
    local BILLBOARD_BASE_SIZE = Vector2.new(120, 52)
    local BILLBOARD_ENABLE_DISTANCE = 300 -- Max distance to render billboard
    local BILLBOARD_MIN_SCALE = 0.5
    local BILLBOARD_MAX_SCALE = 1.5
    
    -- Fade animation configuration
    local FADE_DISTANCE_BUFFER = 10 -- Studs for smooth fade transition

    local function RemovePlayerESP(player)
        local data = PlayerESPData[player]
        if not data then return end
        pcall(function()
            if data.Highlight then data.Highlight:Destroy() end
            if data.Billboard then data.Billboard:Destroy() end
        end)
        PlayerESPData[player] = nil
    end

    local function CreatePlayerESP(player)
        local char = player.Character
        if not char then return end
        local hum = char:FindFirstChildWhichIsA("Humanoid")
        if not hum then return end
        local head = char:FindFirstChild("Head")
        if not head then return end

        RemovePlayerESP(player)

        local highlight = nil
        if ChamsESPEnabled then
            highlight = Instance.new("Highlight")
            highlight.Name = "Katchi_Cham_Highlight"
            highlight.Adornee = char
            highlight.FillColor = Color3.fromRGB(0, 255, 0)
            highlight.FillTransparency = ChamsFillTransparency
            highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
            highlight.OutlineTransparency = 0
            highlight.Parent = char
        end

        local billboard = nil
        local espFrame = nil -- Declare outside to ensure it's in scope
        local nameLabel = nil
        local distanceLabel = nil
        local statusBg = nil
        local statusLabel = nil
        
        if BillboardESPEnabled then
            billboard = Instance.new("BillboardGui")
            billboard.Name = "Katchi_ESP_Billboard"
            billboard.Adornee = head
            billboard.Size = UDim2.new(0, BILLBOARD_BASE_SIZE.X, 0, BILLBOARD_BASE_SIZE.Y)
            billboard.StudsOffset = HEALTH_BILLBOARD_OFFSET
            billboard.AlwaysOnTop = true
            billboard.LightInfluence = 0
            billboard.MaxDistance = BILLBOARD_MAX_DISTANCE
            billboard.Parent = char

            espFrame = Instance.new("Frame")
            espFrame.Name = "ESPFrame"
            espFrame.Size = UDim2.new(1, 0, 1, 0)
            espFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            espFrame.BackgroundTransparency = PerformanceModeEnabled and 1 or 0.6
            espFrame.BorderSizePixel = 0
            espFrame.Parent = billboard

            local uiCorner = Instance.new("UICorner")
            uiCorner.CornerRadius = UDim.new(0, 8)
            uiCorner.Parent = espFrame

            -- Status background (semi-transparent rounded box) - used for center MERCY or full-cover grabbed
            statusBg = Instance.new("Frame")
            statusBg.Name = "StatusBg"
            statusBg.Size = UDim2.new(0.9, 0, 0.36, 0)
            statusBg.Position = UDim2.new(0.05, 0, 0.32, 0) -- centered vertically by default
            statusBg.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            statusBg.BorderSizePixel = 0
            statusBg.BackgroundTransparency = 0.45
            statusBg.Visible = false
            statusBg.Parent = espFrame

            local statusBgCorner = Instance.new("UICorner")
            statusBgCorner.CornerRadius = UDim.new(0, 8)
            statusBgCorner.Parent = statusBg

            -- Status label (centered inside statusBg)
            statusLabel = Instance.new("TextLabel")
            statusLabel.Name = "Status"
            statusLabel.Text = ""
            statusLabel.Size = UDim2.new(1, -8, 1, 0)
            statusLabel.Position = UDim2.new(0, 4, 0, 0)
            statusLabel.BackgroundTransparency = 1
            statusLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
            statusLabel.TextStrokeTransparency = 0.3
            statusLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
            statusLabel.TextSize = 16
            statusLabel.Font = Enum.Font.SourceSansBold
            statusLabel.TextWrapped = true
            statusLabel.TextXAlignment = Enum.TextXAlignment.Center
            statusLabel.TextYAlignment = Enum.TextYAlignment.Center
            statusLabel.Visible = false
            statusLabel.Parent = statusBg

            -- Name label (small, above the bars)
            nameLabel = Instance.new("TextLabel")
            nameLabel.Name = "Name"
            nameLabel.Text = player.Name
            nameLabel.Size = UDim2.new(1, 0, 0.14, 0)
            nameLabel.Position = UDim2.new(0, 0, 0.12, 0)
            nameLabel.BackgroundTransparency = 1
            nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
            nameLabel.TextStrokeTransparency = 0.5
            nameLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
            nameLabel.TextSize = 14
            nameLabel.Font = Enum.Font.SourceSansBold
            nameLabel.TextWrapped = true
            nameLabel.TextXAlignment = Enum.TextXAlignment.Center
            nameLabel.Parent = espFrame

            -- Health BAR (outer frame + inner fill + centered label)
            local healthOuter = Instance.new("Frame")
            healthOuter.Name = "HealthOuter"
            healthOuter.Size = UDim2.new(0.9, 0, 0.16, 0) -- relative to billboard
            healthOuter.Position = UDim2.new(0.05, 0, 0.40, 0)
            healthOuter.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
            healthOuter.BorderSizePixel = 0
            healthOuter.Parent = espFrame

            local healthOuterCorner = Instance.new("UICorner")
            healthOuterCorner.CornerRadius = UDim.new(0, 6)
            healthOuterCorner.Parent = healthOuter

            local healthInner = Instance.new("Frame")
            healthInner.Name = "HealthInner"
            healthInner.Size = UDim2.new(0, 0, 1, 0) -- will be set per-health percent
            healthInner.Position = UDim2.new(0, 0, 0, 0)
            healthInner.BorderSizePixel = 0
            healthInner.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
            healthInner.Parent = healthOuter

            local healthInnerCorner = Instance.new("UICorner")
            healthInnerCorner.CornerRadius = UDim.new(0, 6)
            healthInnerCorner.Parent = healthInner

            local healthLabelInside = Instance.new("TextLabel")
            healthLabelInside.Name = "HealthLabelInside"
            healthLabelInside.Text = "100/100"
            healthLabelInside.Size = UDim2.new(1, 0, 1, 0)
            healthLabelInside.Position = UDim2.new(0, 0, 0, 0)
            healthLabelInside.BackgroundTransparency = 1
            healthLabelInside.TextColor3 = Color3.fromRGB(255, 255, 255)
            healthLabelInside.TextStrokeTransparency = 0.6
            healthLabelInside.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
            healthLabelInside.TextSize = 12
            healthLabelInside.Font = Enum.Font.SourceSansBold
            healthLabelInside.TextWrapped = false
            healthLabelInside.TextXAlignment = Enum.TextXAlignment.Center
            healthLabelInside.TextYAlignment = Enum.TextYAlignment.Center
            healthLabelInside.Parent = healthOuter

            -- Infection BAR (outer + inner + label)
            local infectOuter = Instance.new("Frame")
            infectOuter.Name = "InfectOuter"
            infectOuter.Size = UDim2.new(0.9, 0, 0.16, 0)
            infectOuter.Position = UDim2.new(0.05, 0, 0.60, 0)
            infectOuter.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
            infectOuter.BorderSizePixel = 0
            infectOuter.Parent = espFrame

            local infectOuterCorner = Instance.new("UICorner")
            infectOuterCorner.CornerRadius = UDim.new(0, 6)
            infectOuterCorner.Parent = infectOuter

            local infectInner = Instance.new("Frame")
            infectInner.Name = "InfectInner"
            infectInner.Size = UDim2.new(0, 0, 1, 0) -- will be set by infection percent
            infectInner.Position = UDim2.new(0, 0, 0, 0)
            infectInner.BorderSizePixel = 0
            infectInner.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
            infectInner.Parent = infectOuter

            local infectInnerCorner = Instance.new("UICorner")
            infectInnerCorner.CornerRadius = UDim.new(0, 6)
            infectInnerCorner.Parent = infectInner

            local infectLabelInside = Instance.new("TextLabel")
            infectLabelInside.Name = "InfectLabelInside"
            infectLabelInside.Text = "0/100"
            infectLabelInside.Size = UDim2.new(1, 0, 1, 0)
            infectLabelInside.Position = UDim2.new(0, 0, 0, 0)
            infectLabelInside.BackgroundTransparency = 1
            infectLabelInside.TextColor3 = Color3.fromRGB(255, 255, 255)
            infectLabelInside.TextStrokeTransparency = 0.6
            infectLabelInside.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
            infectLabelInside.TextSize = 12
            infectLabelInside.Font = Enum.Font.SourceSansBold
            infectLabelInside.TextWrapped = false
            infectLabelInside.TextXAlignment = Enum.TextXAlignment.Center
            infectLabelInside.TextYAlignment = Enum.TextYAlignment.Center
            infectLabelInside.Parent = infectOuter

            -- Distance label (moved down a bit)
            distanceLabel = Instance.new("TextLabel")
            distanceLabel.Name = "Distance"
            distanceLabel.Text = "0 studs"
            distanceLabel.Size = UDim2.new(1, 0, 0.12, 0)
            distanceLabel.Position = UDim2.new(0, 0, 0.86, 0)
            distanceLabel.BackgroundTransparency = 1
            distanceLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
            distanceLabel.TextStrokeTransparency = 0.5
            distanceLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
            distanceLabel.TextSize = 12
            distanceLabel.Font = Enum.Font.SourceSans
            distanceLabel.TextWrapped = true
            distanceLabel.TextXAlignment = Enum.TextXAlignment.Center
            distanceLabel.Parent = espFrame

            -- Parent other objects to allow easy retrieval
        end

        PlayerESPData[player] = {
            Char = char,
            Humanoid = hum,
            Head = head,
            Highlight = highlight,
            Billboard = billboard,
            ESPFrame = espFrame,
            NameLabel = nameLabel,
            -- bars & labels (may be nil if billboard disabled)
            HealthOuter = espFrame and espFrame:FindFirstChild("HealthOuter") or nil,
            HealthInner = espFrame and espFrame:FindFirstChild("HealthOuter") and espFrame.HealthOuter:FindFirstChild("HealthInner") or nil,
            HealthLabelInside = espFrame and espFrame:FindFirstChild("HealthOuter") and espFrame.HealthOuter:FindFirstChild("HealthLabelInside") or nil,
            InfectOuter = espFrame and espFrame:FindFirstChild("InfectOuter") or nil,
            InfectInner = espFrame and espFrame:FindFirstChild("InfectOuter") and espFrame.InfectOuter:FindFirstChild("InfectInner") or nil,
            InfectLabelInside = espFrame and espFrame:FindFirstChild("InfectOuter") and espFrame.InfectOuter:FindFirstChild("InfectLabelInside") or nil,
            DistanceLabel = distanceLabel,
            StatusBg = espFrame and espFrame:FindFirstChild("StatusBg") or nil,
            StatusLabel = espFrame and espFrame:FindFirstChild("StatusBg") and espFrame.StatusBg:FindFirstChild("Status") or nil,
            NotifState = nil,
            LastNotify = 0,
            CurrentStudsOffset = HEALTH_BILLBOARD_OFFSET,
            DesiredStudsOffset = HEALTH_BILLBOARD_OFFSET
        }

        -- ensure initial visibility respects settings
        if PlayerESPData[player].HealthOuter then
            PlayerESPData[player].HealthOuter.Visible = ShowHealthBarEnabled and BillboardESPEnabled
        end
        if PlayerESPData[player].InfectOuter then
            PlayerESPData[player].InfectOuter.Visible = ShowInfectionBarEnabled and BillboardESPEnabled
        end
    end

    local function UpdateESPLoop()
        if not (ChamsESPEnabled or BillboardESPEnabled) then return end
        local localChar = LocalPlayer and LocalPlayer.Character
        local localRoot = localChar and localChar:FindFirstChild("HumanoidRootPart")
        local camera = Workspace.CurrentCamera
        if not camera then return end

        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer then
                local data = PlayerESPData[player]
                local char = player.Character
                if not char or not char.Parent then
                    if data then RemovePlayerESP(player) end
                    continue
                end
                
                -- Re-create ESP if character changed or components missing
                if not data or data.Char ~= char then
                    CreatePlayerESP(player)
                    data = PlayerESPData[player]
                    if not data then continue end
                end

                if ChamsESPEnabled and (not data.Highlight or not data.Highlight.Parent) then
                    CreatePlayerESP(player)
                    data = PlayerESPData[player]
                    if not data then continue end
                end

                if BillboardESPEnabled and (not data.Billboard or not data.Billboard.Parent) then
                    CreatePlayerESP(player)
                    data = PlayerESPData[player]
                    if not data then continue end
                end

                local hum = data.Humanoid
                if not hum then continue end
                local health = hum.Health
                local max = hum.MaxHealth > 0 and hum.MaxHealth or 1
                local percent = math.clamp(health / max, 0, 1)

                -- Check grabbed/pinned/infected
                local grabbed = false
                local pinned = false
                local infectionLevel = 0
                local wPlayers = Workspace:FindFirstChild("Players")
                if wPlayers then
                    local playerFolder = wPlayers:FindFirstChild(player.Name)
                    if playerFolder then
                        local userStates = playerFolder:FindFirstChild("UserStates")
                        if userStates then
                            local grabbedVal = userStates:FindFirstChild("Grabbed")
                            grabbed = (grabbedVal and tonumber(grabbedVal.Value) or 0) ~= 0
                            local pinVal = userStates:FindFirstChild("Pin")
                            pinned = tostring(pinVal and pinVal.Value or "None") ~= "None"
                            local infectedVal = userStates:FindFirstChild("Infected")
                            infectionLevel = infectedVal and tonumber(infectedVal.Value) or 0
                        end
                    end
                end

                -- distance calculation
                local playerRoot = char:FindFirstChild("HumanoidRootPart")
                local dist = nil
                if localRoot and playerRoot then
                    dist = (localRoot.Position - playerRoot.Position).Magnitude
                end

                -- CRITICAL FIX: Proper distance-based fade logic
                local fadeFactor = 1 -- 1 = fully visible, 0 = fully transparent
                local shouldRender = true

                if dist then
                    -- Disable if beyond max render distance
                    if dist >= BILLBOARD_ENABLE_DISTANCE then
                        shouldRender = false
                    end
                    
                    -- Apply fade effect if within "too close" range (slider)
                    if BillboardShowDistance > 0 and dist < BillboardShowDistance then
                        local fadeStart = math.max(BillboardShowDistance - FADE_DISTANCE_BUFFER, 0)
                        
                        if dist <= fadeStart then
                            fadeFactor = 0 -- Fully faded/transparent
                        else
                            -- Smooth fade from 0 to 1
                            fadeFactor = math.clamp((dist - fadeStart) / (BillboardShowDistance - fadeStart), 0, 1)
                        end
                    end
                end

                ----------------------------------------------------------------
                -- Background vs Bars transparency
                ----------------------------------------------------------------

                -- Determine base transparency just for the main background frame
                local frameTransparency
                do
                    local isGrabbedPinned = grabbed or pinned
                    local shouldBeRed = isGrabbedPinned or infectionLevel >= 70
                    -- if PerformanceModeEnabled => hide only the background frame
                    local baseTransparency = PerformanceModeEnabled and 1 or (shouldBeRed and 0.4 or 0.6)
                    frameTransparency = baseTransparency + (1 - fadeFactor) * 0.5
                end

                -- Apply transparency ONLY to the main background + status box
                if data.ESPFrame then
                    data.ESPFrame.BackgroundTransparency = frameTransparency
                end

                if data.StatusBg then
                    -- status box can stay a bit more solid than the frame
                    data.StatusBg.BackgroundTransparency = math.clamp(
                        (PerformanceModeEnabled and 0.7 or 0.45) + (1 - fadeFactor) * 0.3,
                        0, 1
                    )
                end

                -- === Bars have their own transparency, independent from PerformanceModeEnabled ===
                -- Health bar
                if data.HealthOuter then
                    local healthOuterBase = 0.3         -- solid-ish background for the bar
                    local healthOuterTransp = healthOuterBase + (1 - fadeFactor) * 0.4
                    data.HealthOuter.BackgroundTransparency = math.clamp(healthOuterTransp, 0, 1)
                end
                if data.HealthInner then
                    local healthInnerBase = 0           -- keep fill solid, only a little fade
                    local healthInnerTransp = healthInnerBase + (1 - fadeFactor) * 0.25
                    data.HealthInner.BackgroundTransparency = math.clamp(healthInnerTransp, 0, 1)
                end
                if data.HealthLabelInside then
                    data.HealthLabelInside.TextTransparency = 1 - fadeFactor
                end

                -- Infection bar
                if data.InfectOuter then
                    local infectOuterBase = 0.3
                    local infectOuterTransp = infectOuterBase + (1 - fadeFactor) * 0.4
                    data.InfectOuter.BackgroundTransparency = math.clamp(infectOuterTransp, 0, 1)
                end
                if data.InfectInner then
                    local infectInnerBase = 0
                    local infectInnerTransp = infectInnerBase + (1 - fadeFactor) * 0.25
                    data.InfectInner.BackgroundTransparency = math.clamp(infectInnerTransp, 0, 1)
                end
                if data.InfectLabelInside then
                    data.InfectLabelInside.TextTransparency = 1 - fadeFactor
                end

                ----------------------------------------------------------------
                -- Enhanced grabbed/pinned visuals when monitor is enabled + mercy
                ----------------------------------------------------------------

                local isGrabbedPinned = grabbed or pinned
                local isMercy = infectionLevel >= 100

                -- If infection reached 100 -> show MERCY (centered; infection bar remains visible)
                if isMercy and data.StatusLabel then
                    -- position the status box centered (smaller, so infection bar shows)
                    if data.StatusBg then
                        data.StatusBg.Size = UDim2.new(0.9, 0, 0.36, 0)
                        data.StatusBg.Position = UDim2.new(0.05, 0, 0.30, 0)
                        data.StatusBg.Visible = true
                        -- purple-ish background for mercy
                        local pulse = math.sin(tick() * 6)
                        if pulse > 0 then
                            data.StatusBg.BackgroundColor3 = Color3.fromRGB(120, 0, 120)
                        else
                            data.StatusBg.BackgroundColor3 = Color3.fromRGB(80, 0, 80)
                        end
                    end

                    data.StatusLabel.Text = "MERCY"
                    data.StatusLabel.Visible = true
                    data.StatusLabel.TextSize = 16

                    -- hide name and health bar, but DO NOT hide infection bar
                    if data.NameLabel then data.NameLabel.Visible = false end
                    if data.HealthOuter then data.HealthOuter.Visible = false end
                    if data.InfectOuter then data.InfectOuter.Visible = ShowInfectionBarEnabled end
                    if data.DistanceLabel then data.DistanceLabel.Visible = true end

                    -- ensure health inner is reset
                    if data.HealthInner then data.HealthInner.Size = UDim2.new(0,0,1,0) end
                    -- set infection inner to full or according to infectionLevel
                    if data.InfectInner then
                        local infectPercent = math.clamp(infectionLevel / 100, 0, 1)
                        data.InfectInner.Size = UDim2.new(infectPercent, 0, 1, 0)
                    end

                    -- change chams color to purple pulse when mercy
                    if ChamsESPEnabled and data.Highlight then
                        local pulse = math.sin(tick() * 6)
                        if pulse > 0 then
                            data.Highlight.FillColor = Color3.fromRGB(180, 0, 180)
                        else
                            data.Highlight.FillColor = Color3.fromRGB(110, 0, 110)
                        end
                        data.Highlight.FillTransparency = math.clamp(
                            ChamsFillTransparency + 0.2 * math.abs(math.sin(tick() * 8)),
                            0, 1
                        )
                        data.Highlight.OutlineColor = Color3.fromRGB(255, 200, 255)
                    end

                elseif NotifyGrabbedPinnedEnabled and isGrabbedPinned then
                    -- grabbed/pinned: full-cover status (hide both bars)
                    if data.StatusBg then
                        data.StatusBg.Size = UDim2.new(1, 0, 1, 0)
                        data.StatusBg.Position = UDim2.new(0, 0, 0, 0)
                        data.StatusBg.Visible = true
                        -- red pulsing background for grabbed/pinned
                        local pulse = math.sin(tick() * 10)
                        if pulse > 0 then
                            data.StatusBg.BackgroundColor3 = Color3.fromRGB(200, 30, 30)
                        else
                            data.StatusBg.BackgroundColor3 = Color3.fromRGB(120, 10, 10)
                        end
                    end

                    if data.StatusLabel then
                        data.StatusLabel.Text = grabbed and "GRABBED!" or "PINNED!"
                        data.StatusLabel.Visible = true
                        data.StatusLabel.TextSize = 18
                    end

                    if data.NameLabel then data.NameLabel.Visible = false end
                    if data.HealthOuter then data.HealthOuter.Visible = false end
                    if data.InfectOuter then data.InfectOuter.Visible = false end
                    if data.DistanceLabel then data.DistanceLabel.Visible = false end

                    -- ensure inner fills are reset
                    if data.HealthInner then data.HealthInner.Size = UDim2.new(0,0,1,0) end
                    if data.InfectInner then data.InfectInner.Size = UDim2.new(0,0,1,0) end

                    -- Change chams color to flashing red
                    if ChamsESPEnabled and data.Highlight then
                        local pulse = math.sin(tick() * 10)
                        data.Highlight.FillColor = pulse > 0 and Color3.fromRGB(255, 0, 0) or Color3.fromRGB(200, 0, 0)
                        data.Highlight.FillTransparency = math.clamp(
                            ChamsFillTransparency + 0.2 * math.abs(math.sin(tick() * 8)),
                            0, 1
                        )
                        data.Highlight.OutlineColor = Color3.fromRGB(255, 100, 100)
                    end
                else
                    -- Restore normal view
                    if data.StatusBg then data.StatusBg.Visible = false end
                    if data.StatusLabel then data.StatusLabel.Visible = false end
                    if data.NameLabel then data.NameLabel.Visible = true end
                    if data.HealthOuter then data.HealthOuter.Visible = ShowHealthBarEnabled end
                    if data.InfectOuter then data.InfectOuter.Visible = ShowInfectionBarEnabled end
                    if data.DistanceLabel then data.DistanceLabel.Visible = true end
                    
                    -- Restore background color (actual visibility controlled by BackgroundTransparency)
                    if data.ESPFrame then
                        data.ESPFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
                    end

                    -- Restore normal chams
                    if ChamsESPEnabled and data.Highlight then
                        local r = math.floor(255 * (1 - percent))
                        local g = math.floor(255 * percent)
                        data.Highlight.FillColor = Color3.fromRGB(r, g, 0)
                        data.Highlight.FillTransparency = ChamsFillTransparency
                        data.Highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
                    end
                end  -- âœ… this is the missing one (closes isMercy / elseif / else)

                -- Billboard updates
                if BillboardESPEnabled and data.Billboard then
                    -- Set enabled based on render distance only
                    data.Billboard.Enabled = shouldRender
                    
                    if shouldRender then
                        -- Scale calculation with improved text sizing
                        local scale = 1
                        if dist and dist < BILLBOARD_ENABLE_DISTANCE then
                            scale = math.clamp(30 / math.max(dist, 1), BILLBOARD_MIN_SCALE, BILLBOARD_MAX_SCALE)
                        end

                        -- Apply size with scale
                        local w = math.floor(BILLBOARD_BASE_SIZE.X * scale)
                        local h = math.floor(BILLBOARD_BASE_SIZE.Y * scale)
                        data.Billboard.Size = UDim2.new(0, w, 0, h)

                        -- Better text scaling that scales ALL elements proportionally
                        local baseTextSize = math.floor(12 * scale)
                        local nameTextSize = math.floor(14 * scale)
                        local statusSize = math.floor(16 * scale)
                        local minSize = 8
                        
                        if data.StatusLabel and data.StatusLabel.Visible then
                            data.StatusLabel.TextSize = math.max(statusSize, minSize)
                        end
                        if data.NameLabel then
                            data.NameLabel.TextSize = math.max(nameTextSize, minSize)
                        end
                        if data.DistanceLabel then
                            data.DistanceLabel.TextSize = math.max(baseTextSize, minSize)
                        end

                        -- Update text values
                        if data.NameLabel then
                            data.NameLabel.Text = player.Name
                            -- apply fade to name text too
                            data.NameLabel.TextTransparency = 1 - fadeFactor
                            data.NameLabel.TextStrokeTransparency = 0.5 + (1 - fadeFactor) * 0.5
                        end

                        -- Health bar update (hide when grabbed/pinned or mercy)
                        if data.HealthOuter and data.HealthInner and ShowHealthBarEnabled and (not isGrabbedPinned) and (not isMercy) then
                            -- compute percent from hum values
                            local healthPercent = percent -- already computed earlier as health/max
                            -- Set inner fill width (use UDim2 scale)
                            data.HealthInner.Size = UDim2.new(healthPercent, 0, 1, 0)
                            -- Color gradient (green->red)
                            local healthR = math.floor(255 * (1 - healthPercent))
                            local healthG = math.floor(255 * healthPercent)
                            data.HealthInner.BackgroundColor3 = Color3.fromRGB(healthR, healthG, 0)
                            -- Update label text
                            if data.HealthLabelInside then
                                data.HealthLabelInside.Text = math.floor(health) .. "/" .. math.floor(max)
                                data.HealthLabelInside.TextSize = math.max(baseTextSize - 2, 8)
                                data.HealthLabelInside.TextTransparency = 1 - fadeFactor
                            end
                            data.HealthOuter.Visible = true
                        elseif data.HealthOuter then
                            data.HealthOuter.Visible = false
                            if data.HealthInner then data.HealthInner.Size = UDim2.new(0,0,1,0) end
                        end

                        -- Infection bar update (hide only when grabbed/pinned; show during mercy)
                        if data.InfectOuter and data.InfectInner and ShowInfectionBarEnabled and (not isGrabbedPinned) then
                            local infectPercent = math.clamp((infectionLevel or 0) / 100, 0, 1)
                            data.InfectInner.Size = UDim2.new(infectPercent, 0, 1, 0)
                            local infectR = math.floor(255 * infectPercent)
                            local infectG = math.floor(255 * (1 - infectPercent))
                            data.InfectInner.BackgroundColor3 = Color3.fromRGB(infectR, infectG, 0)
                            if data.InfectLabelInside then
                                data.InfectLabelInside.Text = math.floor(infectionLevel) .. "/100"
                                data.InfectLabelInside.TextSize = math.max(baseTextSize - 2, 8)
                                data.InfectLabelInside.TextTransparency = 1 - fadeFactor
                            end
                            data.InfectOuter.Visible = true
                        elseif data.InfectOuter then
                            data.InfectOuter.Visible = false
                            if data.InfectInner then data.InfectInner.Size = UDim2.new(0,0,1,0) end
                        end

                        if data.DistanceLabel and data.DistanceLabel.Visible then
                            data.DistanceLabel.Text = math.floor(dist or 0) .. " studs"
                            data.DistanceLabel.TextTransparency = 1 - fadeFactor
                            data.DistanceLabel.TextStrokeTransparency = 0.5 + (1 - fadeFactor) * 0.5
                        end
                    end

                    -- Apply fade to status label as well
                    if data.StatusLabel and data.StatusLabel.Visible then
                        data.StatusLabel.TextTransparency = 1 - fadeFactor
                        data.StatusLabel.TextStrokeTransparency = 0.5 + (1 - fadeFactor) * 0.5
                    end

                    -- Studs offset smoothing (we move below the head)
                    data.DesiredStudsOffset = grabbed and Vector3.new(0, -2, 0) or HEALTH_BILLBOARD_OFFSET
                    data.CurrentStudsOffset = data.CurrentStudsOffset:Lerp(data.DesiredStudsOffset, STUDS_SMOOTH_ALPHA)
                    data.Billboard.StudsOffset = data.CurrentStudsOffset
                end

                -- Low health notifications
                if NotifyLowHealthEnabled then
                    if health <= 0 then
                        if data.NotifState ~= "dead" then
                            data.NotifState = "dead"
                            WindUI:Notify({
                                Title = "Player Died",
                                Content = player.Name .. " has Died!",
                                Duration = 3,
                                Icon = "skull",
                            })
                        end
                    elseif percent < 0.25 then
                        if data.NotifState ~= "dying" and tick() - data.LastNotify > 3 then
                            data.NotifState = "dying"
                            data.LastNotify = tick()
                            WindUI:Notify({
                                Title = "Player Dying",
                                Content = player.Name .. " is Dying!",
                                Duration = 3,
                                Icon = "heart",
                            })
                        end
                    elseif percent < 0.45 then
                        if data.NotifState ~= "low" and tick() - data.LastNotify > 3 then
                            data.NotifState = "low"
                            data.LastNotify = tick()
                            WindUI:Notify({
                                Title = "Player Low Health",
                                Content = player.Name .. " has Low Health!",
                                Duration = 3,
                                Icon = "activity",
                            })
                        end
                    else
                        data.NotifState = nil
                    end
                end
            end
        end
    end

    RunService.Heartbeat:Connect(UpdateESPLoop)

    Players.PlayerRemoving:Connect(RemovePlayerESP)
    Players.PlayerAdded:Connect(function(p)
        task.wait(0.4)
        if ChamsESPEnabled or BillboardESPEnabled then 
            task.wait()
            CreatePlayerESP(p) 
        end
    end)

    PlayerESPSection:Toggle({
        Title = "Players Chams ESP",
        Flag = "Players_1",
        Desc = "Show Chams ESP on Players",
        Default = false,
        Callback = function(state)
            ChamsESPEnabled = state
            if state then
                for _, pl in ipairs(Players:GetPlayers()) do
                    if pl ~= LocalPlayer then
                        task.wait()
                        CreatePlayerESP(pl)
                    end
                end
                WindUI:Notify({
                    Title = "Player ESP",
                    Content = "Player Chams ESP enabled",
                    Duration = 2,
                    Icon = "eye",
                })
            else
                for p in pairs(PlayerESPData) do
                    local data = PlayerESPData[p]
                    if data and data.Highlight then 
                        data.Highlight:Destroy() 
                        data.Highlight = nil
                    end
                end
                WindUI:Notify({
                    Title = "Player ESP",
                    Content = "Player Chams ESP disabled",
                    Duration = 2,
                    Icon = "eye-off",
                })
            end
        end
    })

    PlayerESPSection:Toggle({
        Title = "Players Billboard ESP",
        Flag = "Players_2",
        Desc = "Show Billboard Text On Players",
        Default = false,
        Callback = function(state)
            BillboardESPEnabled = state
            if state then
                for _, pl in ipairs(Players:GetPlayers()) do
                    if pl ~= LocalPlayer then
                        task.wait()
                        CreatePlayerESP(pl)
                    end
                end
                -- ensure bars respect current settings
                for _, data in pairs(PlayerESPData) do
                    if data and data.HealthOuter then
                        data.HealthOuter.Visible = ShowHealthBarEnabled and data.Billboard and data.Billboard.Enabled
                    end
                    if data and data.InfectOuter then
                        data.InfectOuter.Visible = ShowInfectionBarEnabled and data.Billboard and data.Billboard.Enabled
                    end
                end
                WindUI:Notify({
                    Title = "Player ESP",
                    Content = "Player Billboard ESP enabled",
                    Duration = 2,
                    Icon = "eye",
                })
            else
                for p in pairs(PlayerESPData) do
                    local data = PlayerESPData[p]
                    if data and data.Billboard then 
                        data.Billboard:Destroy() 
                        data.Billboard = nil
                        data.NameLabel = nil
                        -- destroy bar refs if present
                        if data.HealthOuter then 
                            pcall(function() data.HealthOuter:Destroy() end)
                        end
                        if data.InfectOuter then 
                            pcall(function() data.InfectOuter:Destroy() end)
                        end
                        data.HealthOuter = nil
                        data.HealthInner = nil
                        data.HealthLabelInside = nil
                        data.InfectOuter = nil
                        data.InfectInner = nil
                        data.InfectLabelInside = nil
                        data.DistanceLabel = nil
                        data.StatusLabel = nil
                        data.ESPFrame = nil
                    end
                end
                WindUI:Notify({
                    Title = "Player ESP",
                    Content = "Player Billboard ESP disabled",
                    Duration = 2,
                    Icon = "eye-off",
                })
            end
        end
    })

    -- Settings section (renamed from Grabbed & Pinned)
    local SettingsSection = PlayersTab:Section({
        Title = "Settings",
        Icon = "settings",
        Opened = false
    })

    SettingsSection:Toggle({
        Title = "Notify Grabbed and Pinned Players",
        Flag = "Players_4",
        Desc = "Notifies when a player is grabbed or pinned, and shows in chams and billboard.",
        Default = false,
        Callback = function(state)
            NotifyGrabbedPinnedEnabled = state
            WindUI:Notify({
                Title = "Grabbed/Pinned Monitor",
                Content = "Grabbed/Pinned monitor " .. (state and "ON" or "OFF"),
                Duration = 2,
                Icon = state and "eye" or "eye-off",
            })
        end
    })

    SettingsSection:Toggle({
        Title = "Show Health Bar",
        Flag = "Players_ShowHealthBar",
        Desc = "Shows Health Bar On BillBoard",
        Default = false,
        Callback = function(state)
            ShowHealthBarEnabled = state
            WindUI:Notify({
                Title = "Health Bar",
                Content = state and "Health bar ON" or "Health bar OFF",
                Duration = 2,
                Icon = state and "heart" or "heart-off",
            })
            -- update existing billboards immediately
            for _, data in pairs(PlayerESPData) do
                if data and data.HealthOuter then
                    data.HealthOuter.Visible = state and data.Billboard and data.Billboard.Enabled and (not data.StatusLabel or not data.StatusLabel.Visible)
                end
            end
        end
    })

    SettingsSection:Toggle({
        Title = "Show Infection Bar",
        Flag = "Players_ShowInfectionBar",
        Desc = "Shows Infection Bar In BillBoard",
        Default = false,
        Callback = function(state)
            ShowInfectionBarEnabled = state
            WindUI:Notify({
                Title = "Infection Bar",
                Content = state and "Infection bar ON" or "Infection bar OFF",
                Duration = 2,
                Icon = state and "thermometer" or "thermometer-off",
            })
            for _, data in pairs(PlayerESPData) do
                if data and data.InfectOuter then
                    data.InfectOuter.Visible = state and data.Billboard and data.Billboard.Enabled and (not data.StatusLabel or not data.StatusLabel.Visible)
                end
            end
        end
    })

    SettingsSection:Toggle({
        Title = "Notify Low Health Players",
        Flag = "Players_3",
        Desc = "Notify when players reach Low / Dying health",
        Default = false,
        Callback = function(state)
            NotifyLowHealthEnabled = state
            WindUI:Notify({
                Title = "Low Health Notify",
                Content = state and "Low health notifications ON" or "Low health notifications OFF",
                Duration = 2,
                Icon = state and "bell" or "bell-off",
            })
        end
    })

    -- Performance Mode Toggle
    SettingsSection:Toggle({
        Title = "No billboard Background",
        Flag = "Players_Performance",
        Desc = "Removes billboard background",
        Default = true,
        Callback = function(state)
            PerformanceModeEnabled = state
            -- Update existing billboards immediately (only touch backgrounds, not bars)
            for _, data in pairs(PlayerESPData) do
                if data.ESPFrame then
                    data.ESPFrame.BackgroundTransparency = state and 1 or 0.6
                end
                if data.StatusBg then
                    data.StatusBg.BackgroundTransparency = state and 0.7 or 0.45
                end
            end
            WindUI:Notify({
                Title = "Billboard",
                Content = state and "Billboard Background hidden" or "Billboard Background shown.",
                Duration = 2,
                Icon = state and "zap" or "zap-off",
            })
        end
    })

    -- Billboard Distance Slider
    SettingsSection:Slider({
        Title = "Billboard Showing Distance",
        Flag = "Players_BillboardDist",
        Desc = "Hide billboard when closer than this distance",
        Step = 1,
        Value = {
            Min = 5,
            Max = 50,
            Default = 5,
        },
        Callback = function(value)
            -- Clamp value to avoid edge cases
            BillboardShowDistance = math.clamp(value, 0, 100)
        end
    })

    -- Player Chams Transparency Slider
    SettingsSection:Slider({
        Title = "Chams Transparency",
        Flag = "Players_ChamsTransparency",
        Desc = "Controls the transparency of player chams/highlights",
        Step = 0.05,
        Value = {
            Min = 0,
            Max = 1,
            Default = 0.45,
        },
        Callback = function(value)
            local transparency = math.clamp(value, 0, 1)
            ChamsFillTransparency = transparency  -- <-- update global

            -- Update existing player highlights
            for _, data in pairs(PlayerESPData) do
                if data.Highlight then
                    data.Highlight.FillTransparency = transparency
                end
            end
        end
    })

    SettingsSection:Toggle({
        Title = "Notify Low Health Players",
        Flag = "Players_3_Dupe",
        Desc = "Notify when players reach Low / Dying health",
        Default = false,
        Callback = function(state)
            NotifyLowHealthEnabled = state
            WindUI:Notify({
                Title = "Low Health Notify",
                Content = state and "Low health notifications ON" or "Low health notifications OFF",
                Duration = 2,
                Icon = state and "bell" or "bell-off",
            })
        end
    })

    -- // Headless Tab (rewritten)
    local TweenService = game:GetService("TweenService")
    local UserInputService = game:GetService("UserInputService")
    local RunService = game:GetService("RunService")
    local Players = game:GetService("Players")
    local Workspace = game:GetService("Workspace")

    local LocalPlayer = Players.LocalPlayer
    local Camera = Workspace.CurrentCamera

    local HeadlessTab = Event1Section:Tab({ Title = "Headless Horseman", Icon = "skull" })

    -- Headless Section
    local HeadlessSection = HeadlessTab:Section({
        Title = "Headless Horseman Features",
        Icon = "skull",
        Opened = false
    })

    -- State
    local HeadlessESPEnabled = false
    local HeadlessAimlockEnabled = false
    local AimlockActive = false
    local manualPing = 90
    local aimButtonSize = 90
    local aimKeybind = Enum.KeyCode.B
    local AimGui, AimButton, AimButtonInner = nil, nil, nil

    local AimBtnDragging = false
    local PotentialDrag = false
    local DragInput = nil
    local DragStartPos = nil
    local BtnTargetPos = nil
    local InputStartTick = 0

    local AimConns = {}         -- connections to be cleaned (aim-related)
    local ActiveTweens = {}
    local highlightInstances = {} -- model -> Highlight
    local aimbotConnection = nil
    local inputConn = nil
    local lastBossFound = tick()
    local bossTimeout = 10 -- seconds
    local ListeningForBind = false

    -- separate ESP heartbeat connection so it isn't accidentally disconnected
    local espHeartbeatConn = nil

    -- Helpers
    local function clamp(v, a, b) return math.max(a, math.min(b, v)) end

    local function viewportSize()
        local cam = Workspace.CurrentCamera
        if cam and cam.ViewportSize ~= Vector2.zero then
            return cam.ViewportSize
        end
        return Vector2.new(1280, 720)
    end

    local function ensureOnScreen(positionUDim2, sizePx)
        local vs = viewportSize()
        local x = positionUDim2.X.Offset
        local y = positionUDim2.Y.Offset
        local maxX = math.max(0, vs.X - sizePx)
        local maxY = math.max(0, vs.Y - sizePx)
        x = clamp(x, 0, maxX)
        y = clamp(y, 0, maxY)
        return UDim2.new(0, math.floor(x), 0, math.floor(y))
    end

    local function cancelTweens()
        for _, tween in pairs(ActiveTweens) do
            if tween then
                pcall(function() tween:Cancel() end)
            end
        end
        ActiveTweens = {}
    end

    local function safeDestroy(obj)
        pcall(function() if obj then obj:Destroy() end end)
    end

    -- Robust finder for the HeadlessHorseman model / hitbox
    local function findHeadlessBossModel()
        local rootNames = {"Sleepy Hollow", "SleepyHollow", "Sleepy_Hollow"}
        for _, rn in ipairs(rootNames) do
            local root = Workspace:FindFirstChild(rn)
            if root then
                local modes = root:FindFirstChild("Modes") or root:FindFirstChild("modes")
                if modes then
                    local bossFolder = modes:FindFirstChild("Boss") or modes:FindFirstChild("boss")
                    if bossFolder then
                        local hh = bossFolder:FindFirstChild("HeadlessHorsemanBoss") or bossFolder:FindFirstChild("HeadlessHorseman")
                        if hh then return hh end
                    end
                    local hh2 = modes:FindFirstChild("HeadlessHorsemanBoss") or modes:FindFirstChild("HeadlessHorseman")
                    if hh2 then return hh2 end
                end
                local hh3 = root:FindFirstChild("HeadlessHorsemanBoss") or root:FindFirstChild("HeadlessHorseman")
                if hh3 then return hh3 end
            end
        end

        for _, desc in pairs(Workspace:GetDescendants()) do
            if desc:IsA("Model") and desc:FindFirstChild("ZOMBIE_HITBOX") then
                return desc
            end
        end

        local top = Workspace:FindFirstChild("HeadlessHorsemanBoss") or Workspace:FindFirstChild("HeadlessHorseman")
        if top then return top end
        return nil
    end

    -- Heartbeat: manage ESP highlights (keeps reference to camera updated)
    do
        espHeartbeatConn = RunService.Heartbeat:Connect(function()
            Camera = Workspace.CurrentCamera or Camera

            -- clear any invalid highlights
            for model, h in pairs(highlightInstances) do
                if not model or not model.Parent or (h and not h.Parent) then
                    safeDestroy(h)
                    highlightInstances[model] = nil
                end
            end

            if not HeadlessESPEnabled then
                for model, h in pairs(highlightInstances) do
                    safeDestroy(h)
                    highlightInstances[model] = nil
                end
                return
            end

            local hhModel = findHeadlessBossModel()
            if not hhModel then
                for model, h in pairs(highlightInstances) do
                    safeDestroy(h)
                    highlightInstances[model] = nil
                end
                return
            end

            -- create highlight for this model if missing
            if not highlightInstances[hhModel] then
                local h = Instance.new("Highlight")
                h.Name = "HeadlessHighlight"
                h.FillColor = Color3.fromRGB(255, 100, 100)
                h.OutlineColor = Color3.fromRGB(255, 255, 255)
                h.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                -- Parent the Highlight to the model (model must be descendant of workspace)
                -- this works across model replacements because we key by object reference
                h.Parent = hhModel
                highlightInstances[hhModel] = h
            end
        end)
    end

    -- safe helper to locate hitbox part (ZOMBIE_HITBOX)
    local function getHeadlessHitbox()
        local model = findHeadlessBossModel()
        if not model then return nil end
        local hh = model:FindFirstChild("HeadlessHorseman") or model
        if hh and hh:FindFirstChild("ZOMBIE_HITBOX") then
            return hh:FindFirstChild("ZOMBIE_HITBOX")
        end
        if model:FindFirstChild("ZOMBIE_HITBOX") then
            return model:FindFirstChild("ZOMBIE_HITBOX")
        end
        -- fallback: search children
        for _, child in ipairs(model:GetDescendants()) do
            if child:IsA("BasePart") and child.Name == "ZOMBIE_HITBOX" then
                return child
            end
        end
        return nil
    end

    -- start aimbot (predict + smooth)
    local function startAimbot()
        if aimbotConnection then
            pcall(function() aimbotConnection:Disconnect() end)
            aimbotConnection = nil
        end

        aimbotConnection = RunService.RenderStepped:Connect(function(delta)
            if not AimlockActive or not HeadlessAimlockEnabled then return end
            Camera = Workspace.CurrentCamera or Camera

            local ok, targetPart = pcall(getHeadlessHitbox)
            if not ok or not targetPart or not targetPart:IsA("BasePart") then
                if tick() - lastBossFound > bossTimeout then
                    setButtonActive(false)
                    if WindUI then
                        WindUI:Notify({
                            Title = "Aimlock",
                            Content = "Headless Horseman not found, aimlock disabled.",
                            Duration = 3,
                            Icon = "x"
                        })
                    end
                end
                return
            end

            if not targetPart.Parent then return end
            lastBossFound = tick()

            local predicted = targetPart.Position + (targetPart.Velocity * (manualPing / 1000))

            local cameraPos = Camera.CFrame.Position
            local direction = predicted - cameraPos
            local dist = direction.Magnitude
            if dist == 0 then return end
            if dist > 2000 then return end

            local targetCFrame = CFrame.new(cameraPos, cameraPos + direction.Unit)
            local lerpAlpha = clamp(delta * 10, 0, 1)
            pcall(function() Camera.CFrame = Camera.CFrame:Lerp(targetCFrame, lerpAlpha) end)
        end)

        table.insert(AimConns, aimbotConnection)
    end

    local function stopAimbot()
        if aimbotConnection then
            pcall(function() aimbotConnection:Disconnect() end)
            aimbotConnection = nil
        end
    end

    -- setButtonActive toggles aim state and updates visuals
    function setButtonActive(active)
        AimlockActive = active
        cancelTweens()

        if AimButton and AimButtonInner then
            if active then
                local tween1 = TweenService:Create(AimButton, TweenInfo.new(0.18, Enum.EasingStyle.Sine), {BackgroundColor3 = Color3.fromRGB(60, 200, 100)})
                local tween2 = TweenService:Create(AimButtonInner, TweenInfo.new(0.18, Enum.EasingStyle.Sine), {BackgroundColor3 = Color3.fromRGB(40, 180, 80)})
                pcall(function() tween1:Play(); tween2:Play() end)
                table.insert(ActiveTweens, tween1); table.insert(ActiveTweens, tween2)
                AimButton.Text = "ðŸ”’"
            else
                local tween1 = TweenService:Create(AimButton, TweenInfo.new(0.18, Enum.EasingStyle.Sine), {BackgroundColor3 = Color3.fromRGB(40, 40, 40)})
                local tween2 = TweenService:Create(AimButtonInner, TweenInfo.new(0.18, Enum.EasingStyle.Sine), {BackgroundColor3 = Color3.fromRGB(60, 60, 60)})
                pcall(function() tween1:Play(); tween2:Play() end)
                table.insert(ActiveTweens, tween1); table.insert(ActiveTweens, tween2)
                AimButton.Text = "ðŸŽ¯"
            end
        end

        if active then startAimbot() else stopAimbot() end
    end

    -- Create Aimlock Button (robust + mobile friendly, smooth dragging)
    local function createAimlockButton()
        if AimGui and AimGui.Parent then return AimGui end

        -- cleanup any old UI named AimlockGUI
        local core = game:GetService("CoreGui")
        for _, child in ipairs(core:GetChildren()) do
            if child.Name == "AimlockGUI" then
                safeDestroy(child)
            end
        end

        -- Only disconnect aim-related connections (AimConns). espHeartbeatConn is NOT in AimConns,
        -- so the ESP heartbeat won't be disconnected here anymore.
        for _, c in pairs(AimConns) do
            pcall(function() c:Disconnect() end)
        end
        AimConns = {}

        AimGui = Instance.new("ScreenGui")
        AimGui.Name = "AimlockGUI"
        AimGui.ResetOnSpawn = false
        AimGui.IgnoreGuiInset = true
        AimGui.Parent = core

        local container = Instance.new("Frame")
        container.Name = "AimContainer"
        container.Size = UDim2.new(0, aimButtonSize, 0, aimButtonSize)
        container.Position = UDim2.new(0.5, -aimButtonSize/2, 0.8, -aimButtonSize/2)
        container.BackgroundTransparency = 1
        container.Parent = AimGui

        AimButton = Instance.new("TextButton")
        AimButton.Name = "AimButton"
        AimButton.Size = UDim2.new(1, 0, 1, 0)
        AimButton.Position = UDim2.new(0, 0, 0, 0)
        AimButton.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
        AimButton.Text = "ðŸŽ¯"
        AimButton.Font = Enum.Font.Roboto
        AimButton.TextSize = math.clamp(aimButtonSize * 0.5, 20, 50)
        AimButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        AimButton.AutoButtonColor = false
        AimButton.BorderSizePixel = 0
        AimButton.Parent = container
        AimButton.ZIndex = 10

        local gradient = Instance.new("UIGradient")
        gradient.Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, Color3.fromRGB(100, 100, 255)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(50, 50, 150))
        })
        gradient.Rotation = 45
        gradient.Parent = AimButton

        local shadow = Instance.new("UIStroke")
        shadow.Color = Color3.fromRGB(0, 0, 0)
        shadow.Thickness = 3
        shadow.Transparency = 0.3
        shadow.Parent = AimButton

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 12)
        corner.Parent = AimButton

        AimButtonInner = Instance.new("Frame")
        AimButtonInner.Name = "Inner"
        AimButtonInner.Size = UDim2.new(1, -10, 1, -10)
        AimButtonInner.Position = UDim2.new(0, 5, 0, 5)
        AimButtonInner.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
        AimButtonInner.BorderSizePixel = 0
        AimButtonInner.Parent = AimButton
        AimButtonInner.ZIndex = 9

        local innerGradient = Instance.new("UIGradient")
        innerGradient.Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, Color3.fromRGB(150, 150, 255)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(80, 80, 180))
        })
        innerGradient.Rotation = 45
        innerGradient.Parent = AimButtonInner

        local innerCorner = Instance.new("UICorner")
        innerCorner.CornerRadius = UDim.new(0, 10)
        innerCorner.Parent = AimButtonInner

        container.Position = ensureOnScreen(container.Position, aimButtonSize)

        -- Dragging: small threshold to distinguish tap vs drag, smooth position lerp
        local DRAG_THRESHOLD = 6 -- pixels
        local HOLD_TIME = 0.12    -- seconds before movement counts more reliably

        local function onInputChanged(input)
            if not DragInput or input ~= DragInput then return end
            if not DragStartPos or not BtnTargetPos then return end

            local inputPos = Vector2.new(input.Position.X, input.Position.Y)
            local delta = inputPos - DragStartPos

            -- decide whether this is a drag
            if not AimBtnDragging and PotentialDrag and delta.Magnitude > DRAG_THRESHOLD and (tick() - InputStartTick) > HOLD_TIME then
                AimBtnDragging = true
            end

            if AimBtnDragging then
                local newX = BtnTargetPos.X.Offset + delta.X
                local newY = BtnTargetPos.Y.Offset + delta.Y
                local targetUD = ensureOnScreen(UDim2.new(0, newX, 0, newY), aimButtonSize)
                -- smooth movement using UDim2:Lerp (less jittery than creating many tweens)
                local curr = container.Position
                local lerped = curr:Lerp(targetUD, 0.35)
                container.Position = lerped
            end
        end

        local function onInputEnded(input)
            if input ~= DragInput then return end

            if AimBtnDragging then
                -- finalize drag: snap to on-screen and animate inner back
                AimBtnDragging = false
                DragInput = nil
                DragStartPos = nil
                BtnTargetPos = nil
                PotentialDrag = false

                local snapped = ensureOnScreen(container.Position, aimButtonSize)
                local tween = TweenService:Create(container, TweenInfo.new(0.12, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {Position = snapped})
                pcall(function() tween:Play() end)
                table.insert(ActiveTweens, tween)

                local innerTween = TweenService:Create(AimButtonInner, TweenInfo.new(0.18, Enum.EasingStyle.Sine), {Size = UDim2.new(1, -10, 1, -10)})
                pcall(function() innerTween:Play() end)
                table.insert(ActiveTweens, innerTween)
                return
            end

            -- otherwise it's a tap (short press w/o moving) -> toggle
            DragInput = nil
            DragStartPos = nil
            BtnTargetPos = nil
            PotentialDrag = false

            setButtonActive(not AimlockActive)
            if WindUI then
                WindUI:Notify({
                    Title = "Aimlock",
                    Content = AimlockActive and "Aimlock Engaged" or "Aimlock Released",
                    Duration = 2,
                    Icon = AimlockActive and "target" or "x"
                })
            end
        end

        local beginConn = AimButton.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                if DragInput then return end
                DragInput = input
                DragStartPos = Vector2.new(input.Position.X, input.Position.Y)
                BtnTargetPos = container.Position
                InputStartTick = tick()
                PotentialDrag = true

                local shrink = TweenService:Create(AimButtonInner, TweenInfo.new(0.12, Enum.EasingStyle.Sine), {Size = UDim2.new(1, -14, 1, -14)})
                pcall(function() shrink:Play() end)
                table.insert(ActiveTweens, shrink)
            end
        end)
        table.insert(AimConns, beginConn)

        local inputChangedConn = UserInputService.InputChanged:Connect(onInputChanged)
        table.insert(AimConns, inputChangedConn)

        local inputEndedConn = UserInputService.InputEnded:Connect(onInputEnded)
        table.insert(AimConns, inputEndedConn)

        local viewportConn = Workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
            if not AimBtnDragging and container and container.Parent then
                container.Position = ensureOnScreen(container.Position, aimButtonSize)
            end
        end)
        table.insert(AimConns, viewportConn)

        local function updateButtonSize(sizePx)
            aimButtonSize = clamp(tonumber(sizePx) or aimButtonSize, 40, 200)
            if container and AimButton then
                container.Size = UDim2.new(0, aimButtonSize, 0, aimButtonSize)
                AimButton.Size = UDim2.new(1, 0, 1, 0)
                AimButtonInner.Size = UDim2.new(1, -10, 1, -10)
                AimButton.TextSize = math.clamp(aimButtonSize * 0.5, 20, 50)
                container.Position = ensureOnScreen(container.Position, aimButtonSize)
            end
        end

        AimGui._updateSize = updateButtonSize
        return AimGui
    end

    local function destroyAimlockButton()
        cancelTweens()
        stopAimbot()

        for _, c in pairs(AimConns) do
            pcall(function() c:Disconnect() end)
        end
        AimConns = {}

        if AimGui and AimGui.Parent then
            safeDestroy(AimGui)
        end
        AimGui = nil
        AimButton = nil
        AimButtonInner = nil
        ListeningForBind = false
        AimlockActive = false
        DragInput = nil
        AimBtnDragging = false
        PotentialDrag = false
    end

    -- Keybind Input (WindUI)
    local keybindInput = nil
    if WindUI then
        keybindInput = HeadlessSection:Input({
            Flag = "Headless_1",
            Title = "Aimlock Keybind",
            Desc = "Press a key to set the aimlock keybind",
            Placeholder = aimKeybind and aimKeybind.Name or "(Touch)",
            Callback = function()
                if ListeningForBind then return end
                ListeningForBind = true
                keybindInput:SetValue("Press a key...")
                local captureConn
                captureConn = UserInputService.InputBegan:Connect(function(inp, gpe)
                    if gpe or not ListeningForBind then return end
                    if inp.UserInputType == Enum.UserInputType.Keyboard and inp.KeyCode then
                        aimKeybind = inp.KeyCode
                        keybindInput:SetValue(aimKeybind.Name)
                    elseif inp.UserInputType == Enum.UserInputType.Touch then
                        aimKeybind = nil
                        keybindInput:SetValue("(Touch)")
                    end
                    ListeningForBind = false
                    pcall(function() captureConn:Disconnect() end)
                end)
                table.insert(AimConns, captureConn)
            end
        })
    end

    -- Keybind handler (works even if GUI not created)
    inputConn = UserInputService.InputBegan:Connect(function(input, gpe)
        if gpe or not HeadlessAimlockEnabled then return end
        if aimKeybind and input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == aimKeybind then
            setButtonActive(not AimlockActive)
        end
    end)
    table.insert(AimConns, inputConn)

    -- WindUI Integration (Toggles + Sliders)
    if WindUI then
        HeadlessSection:Toggle({
            Title = "Headless Horseman ESP",
            Flag = "Headless_2",
            Desc = "Highlight the Headless Horseman boss",
            Default = false,
            Callback = function(state)
                HeadlessESPEnabled = state
                WindUI:Notify({
                    Title = "Headless ESP",
                    Content = state and "Headless Horseman ESP Enabled" or "Headless Horseman ESP Disabled",
                    Duration = 2,
                    Icon = state and "eye" or "eye-off",
                })
            end
        })

        HeadlessSection:Toggle({
            Title = "Headless Horseman Aimlock",
            Flag = "Headless_3",
            Desc = "Aimlock onto the Headless Horseman",
            Default = false,
            Callback = function(state)
                HeadlessAimlockEnabled = state

                -- make sure no stale aimbot is running
                setButtonActive(false)

                if state then
                    createAimlockButton()
                    WindUI:Notify({
                        Title = "Headless Aimlock",
                        Content = "Aimlock Enabled",
                        Duration = 3,
                        Icon = "target",
                    })
                else
                    destroyAimlockButton()
                    WindUI:Notify({
                        Title = "Headless Aimlock",
                        Content = "Aimlock Disabled",
                        Duration = 2,
                        Icon = "x",
                    })
                end
            end
        })

        HeadlessSection:Slider({
            Title = "Prediction (Ping in ms)",
            Flag = "Headless_4",
            Desc = "Adjust aimlock prediction based on your ping",
            Step = 1,
            Value = {Min = 30, Max = 300, Default = manualPing},
            Callback = function(val)
                manualPing = val
            end
        })

        HeadlessSection:Slider({
            Title = "Aim Button Size",
            Flag = "Headless_5",
            Desc = "Adjust on-screen aimlock button size",
            Step = 1,
            Value = {Min = 40, Max = 200, Default = aimButtonSize},
            Callback = function(val)
                aimButtonSize = val
                if AimGui and AimGui._updateSize then
                    AimGui._updateSize(val)
                end
            end
        })
    end

    -- Auto-disable on death
    local function handleDeath()
        if AimlockActive then
            setButtonActive(false)
            if WindUI then
                WindUI:Notify({
                    Title = "Aimlock",
                    Content = "Aimlock Disabled On Death.",
                    Duration = 3,
                    Icon = "x"
                })
            end
        end
    end

    -- Hook into character if present
    local currentChar = LocalPlayer and LocalPlayer.Character
    if currentChar then
        local currentHum = currentChar:FindFirstChildOfClass("Humanoid")
        if currentHum then
            currentHum.Died:Connect(handleDeath)
            local camera = Workspace.CurrentCamera
            if camera then
                camera.CameraSubject = currentHum
            end
        end
    end

    LocalPlayer.CharacterAdded:Connect(function(newChar)
        local newHum = newChar:WaitForChild("Humanoid")
        newHum.Died:Connect(handleDeath)

        task.wait(0.1)
        local camera = Workspace.CurrentCamera
        if camera then
            camera.CameraSubject = newHum
            camera.CameraType = Enum.CameraType.Custom
        end
    end)

    -- Cleanup entrypoint
    local function cleanup()
        destroyAimlockButton()
        stopAimbot()

        -- disconnect aim-related connections
        for _, c in pairs(AimConns) do
            pcall(function() c:Disconnect() end)
        end
        AimConns = {}

        if espHeartbeatConn then
            pcall(function() espHeartbeatConn:Disconnect() end)
            espHeartbeatConn = nil
        end

        if inputConn then
            pcall(function() inputConn:Disconnect() end)
            inputConn = nil
        end

        for model, h in pairs(highlightInstances) do
            safeDestroy(h)
            highlightInstances[model] = nil
        end
    end

    _G.KatchiHeadlessAimlockCleanup = cleanup
end

-- ====== WindUI multi-config UI (paste after Window + DashboardTab exist) ======
-- ===== Configs UI (with Overwrite option) =====
local skibiTab = Others1Section:Tab({
    Title = "Profiles",
    Icon = "save", -- optional
    Locked = false,
})

local ConfigManager = Window.ConfigManager
local ConfigSection = skibiTab:Section({
    Title = "Configs",
    Icon = "file-plus",
    Opened = true
})

local profileName = "default"
local selectedProfile = nil
local ConfigDropdown = nil
local overwriteExisting = true -- new default

local function notify(title, content, icon, dur)
    if WindUI then
        pcall(function() WindUI:Notify({ Title = title or "Config", Content = content or "", Icon = icon or "save", Duration = dur or 2 }) end)
    else
        pcall(function() print(("[%s] %s"):format(title or "Config", content or "")) end)
    end
end

local function GetAllConfigsSafe()
    local ok, list = pcall(function() return ConfigManager:AllConfigs() end)
    if not ok or type(list) ~= "table" then return {} end
    local out = {}
    for _, v in ipairs(list) do table.insert(out, tostring(v)) end
    return out
end

local function RefreshConfigsDropdown()
    local list = GetAllConfigsSafe()
    if selectedProfile and not table.find(list, selectedProfile) then selectedProfile = nil end
    
    local newValue = selectedProfile or list[1] or ""

    if ConfigDropdown then
        local success = pcall(function()
            -- Try multiple update methods for different executor compatibility
            if ConfigDropdown.SetValues then 
                ConfigDropdown:SetValues(list)
                ConfigDropdown.Value = newValue
                return true
            end
            
            if ConfigDropdown.SetOptions then 
                ConfigDropdown:SetOptions(list)
                ConfigDropdown.Value = newValue
                return true
            end
            
            if ConfigDropdown.Update then 
                ConfigDropdown:Update(list)
                ConfigDropdown.Value = newValue
                return true
            end
            
            if ConfigDropdown.Refresh then 
                ConfigDropdown:Refresh(list)
                ConfigDropdown.Value = newValue
                return true
            end
            
            -- Final fallback: Direct property manipulation
            ConfigDropdown.Values = list
            ConfigDropdown.Value = newValue
            
            -- Try to force UI update
            if ConfigDropdown.SetValue then
                ConfigDropdown:SetValue(newValue)
            end
        end)
        
        if not success then
            notify("Config", "Dropdown refresh failed try manual refresh", "alert-triangle", 2)
        end
    end
end

-- textbox for entering profile name
ConfigSection:Input({
    Title = "Profile Name",
    Desc = "Enter a name for the config (example: 'Ambatukam' or 'SuhDih')",
    Placeholder = "default",
    Callback = function(val)
        if val and tostring(val):match("%S") then
            profileName = tostring(val)
        end
    end
})

-- Toggle for overwrite option (was missing from UI)
ConfigSection:Toggle({
    Title = "Allow Overwrite",
    Desc = "If enabled, saving will overwrite existing profiles",
    Default = true,
    Callback = function(state)
        overwriteExisting = state
    end
})

-- Save button
ConfigSection:Button({
    Title = "Save Profile",
    Desc = "Save Config Of Current Session",
    Callback = function()
        local name = tostring(profileName or ""):gsub("^%s+", ""):gsub("%s+$", "")
        if name == "" then notify("Config", "Enter a profile name first", "alert-circle", 2); return end

        local existing = GetAllConfigsSafe()
        local exists = table.find(existing, name) ~= nil

        if exists and not overwriteExisting then
            notify("Config", ("Profile '%s' already exists. Enable Overwrite to replace it."):format(name), "alert-circle", 2)
            return
        end

        -- attempt to create config object
        local ok, cfg = pcall(function() return ConfigManager:CreateConfig(name) end)
        if not ok or not cfg then notify("Config", "Failed to create config object", "x", 2); return end

        -- If exists, try delete then recreate for clean save
        if exists and overwriteExisting then
            pcall(function() cfg:Delete() end)
            local ok2, cfg2 = pcall(function() return ConfigManager:CreateConfig(name) end)
            if ok2 and cfg2 then cfg = cfg2 end
        end

        local suc = pcall(function() cfg:Save() end)
        if suc then
            notify("Config", ("Saved '%s'"):format(name), "check", 2)
            selectedProfile = name
            
            -- Add small delay before refreshing for better compatibility
            task.wait(0.1)
            RefreshConfigsDropdown()
        else
            notify("Config", ("Failed to save '%s'"):format(name), "x", 2)
        end
    end
})

-- Dropdown for selecting profiles
ConfigDropdown = ConfigSection:Dropdown({
    Title = "Saved Profiles",
    Desc = "Select a saved profile to load or delete",
    Values = GetAllConfigsSafe(),
    Value = GetAllConfigsSafe()[1] or "",
    Callback = function(option)
        selectedProfile = option
    end
})

-- Load button
ConfigSection:Button({
    Title = "Load Selected",
    Desc = "Load The Selected Config",
    Callback = function()
        if not selectedProfile or tostring(selectedProfile) == "" then notify("Config", "Select a profile first", "alert-circle", 2); return end
        local ok, cfg = pcall(function() return ConfigManager:CreateConfig(selectedProfile) end)
        if not ok or not cfg then notify("Config", "Failed to create config object", "x", 2); return end
        local suc = pcall(function() cfg:Load() end)
        if suc then
            notify("Config", ("Loaded '%s'"):format(selectedProfile), "download", 2)
            RefreshConfigsDropdown()
        else
            notify("Config", ("Failed to load '%s'"):format(selectedProfile), "x", 2)
        end
    end
})

-- Delete button (duplicate removed)
ConfigSection:Button({
    Title = "Delete Selected",
    Desc = "Delete the selected Config",
    Callback = function()
        if not selectedProfile or tostring(selectedProfile) == "" then notify("Config", "Select a profile first", "alert-circle", 2); return end
        local ok, cfg = pcall(function() return ConfigManager:CreateConfig(selectedProfile) end)
        if not ok or not cfg then notify("Config", "Failed to create config object", "x", 2); return end
        local suc = pcall(function() cfg:Delete() end)
        if suc then
            notify("Config", ("Deleted '%s'"):format(selectedProfile), "trash", 2)
            selectedProfile = nil
            RefreshConfigsDropdown()
        else
            notify("Config", ("Failed to delete '%s'"):format(selectedProfile), "x", 2)
        end
    end
})

-- Manual refresh button
ConfigSection:Button({
    Title = "Refresh List",
    Desc = "Refresh the dropdown of saved Configs",
    Callback = function()
        RefreshConfigsDropdown()
        notify("Config", "Refreshed list", "refresh-cw", 1.3)
    end
})

-- Initial population
RefreshConfigsDropdown()

-- === Fixed Theme Tab (use this in place of the previous snippet) ===
local ThemeTab = Others1Section:Tab({
    Title = "Theme",
    Icon  = "sun",
})

local ThemeSection = ThemeTab:Section({
    Title = "Themes",
    Icon  = "paintbrush",
    Opened = true,
})

-- Normalize a single theme entry -> string
local function NormalizeThemeEntry(e)
    if type(e) == "string" then return e end
    if type(e) == "table" then
        if e.Name and type(e.Name) == "string" then return e.Name end
        if e.name and type(e.name) == "string" then return e.name end
        if e.Title and type(e.Title) == "string" then return e.Title end
        -- fallback to tostring
        return tostring(e)
    end
    return tostring(e)
end

-- Normalize a list (returns array of strings)
local function NormalizeList(list)
    local out = {}
    if not list then return out end
    -- handle dictionary (pairs) vs array (ipairs)
    local seen = {}
    for k, v in pairs(list) do
        local s = NormalizeThemeEntry(v)
        if s and s ~= "" and not seen[s] then
            table.insert(out, s)
            seen[s] = true
        end
    end
    table.sort(out)
    return out
end

-- gather theme names (defensive)
local function GetAvailableThemes()
    local raw = {}
    pcall(function()
        if WindUI and type(WindUI) == "table" then
            -- WindUI.Themes might be a map name->table
            if type(WindUI.Themes) == "table" then
                for name, _ in pairs(WindUI.Themes) do table.insert(raw, name) end
            end
            -- WindUI.GetThemes() might return list of names or tables
            if type(WindUI.GetThemes) == "function" then
                local ok, res = pcall(WindUI.GetThemes)
                if ok and res then
                    if type(res) == "table" then
                        for _, v in ipairs(res) do table.insert(raw, v) end
                        -- also check pairs in case it's a map
                        for k, v in pairs(res) do
                            if tonumber(k) == nil then table.insert(raw, k) end
                        end
                    end
                end
            end
        end
        -- Window-level fallback
        if Window and type(Window.Themes) == "table" then
            for name, _ in pairs(Window.Themes) do table.insert(raw, name) end
        end
    end)
    return NormalizeList(raw)
end

local function GetCurrentThemeName()
    local cur = nil
    pcall(function()
        cur = (Window and Window.Theme) or (WindUI and WindUI.Theme) or (WindUI and WindUI.CurrentTheme)
    end)
    if type(cur) == "table" then
        return NormalizeThemeEntry(cur)
    end
    if cur == nil or cur == "" then
        return nil
    end
    return tostring(cur)
end

-- create/dropdown reference
local ThemeDropdown

local function SafeSetDropdownValues(dropdown, vals)
    if not dropdown then return end
    local normalized = NormalizeList(vals)
    pcall(function()
        if dropdown.SetValues and type(dropdown.SetValues) == "function" then
            dropdown:SetValues(normalized)
            return
        end
        if dropdown.SetOptions and type(dropdown.SetOptions) == "function" then
            dropdown:SetOptions(normalized)
            return
        end
        -- fallback: directly assign
        dropdown.Values = normalized
    end)
end

local function SafeSetDropdownValue(dropdown, val)
    if not dropdown then return end
    local s = NormalizeThemeEntry(val)
    pcall(function()
        if dropdown.SetValue and type(dropdown.SetValue) == "function" then
            dropdown:SetValue(s)
            return
        end
        if dropdown.Set and type(dropdown.Set) == "function" then
            dropdown:Set(s)
            return
        end
        -- fallback
        dropdown.Value = s
    end)
end

-- Create dropdown (initial)
local themes = GetAvailableThemes()
local initial = GetCurrentThemeName() or (themes[1] or "Default")

ThemeDropdown = ThemeSection:Dropdown({
    Title = "Available Themes",
    Flag = "Theme",
    Desc  = "Select a UI theme",
    Values = themes,
    Value  = red,
    Callback = function(selection)
        if not selection then return end
        -- normalize selection (could be table/string)
        local sel = NormalizeThemeEntry(selection)
        local ok, err = pcall(function()
            if WindUI and type(WindUI.SetTheme) == "function" then
                WindUI:SetTheme(sel)
            elseif Window and type(Window.SetTheme) == "function" then
                Window:SetTheme(sel)
            else
                error("No SetTheme function found on WindUI/Window")
            end
        end)
        if ok then
            pcall(function() if WindUI and WindUI.Notify then WindUI:Notify({ Title = "Theme", Content = ("Theme set to %s"):format(sel), Duration = 2, Icon = "sun" }) end end)
            -- reflect change on dropdown
            SafeSetDropdownValue(ThemeDropdown, sel)
        else
            pcall(function() if WindUI and WindUI.Notify then WindUI:Notify({ Title = "Theme", Content = ("Failed to set theme: %s"):format(tostring(err)), Duration = 4, Icon = "alert-triangle" }) end end)
        end
    end
})

-- small refresh button
ThemeSection:Button({
    Title = "Refresh Themes",
    Desc  = "Scan for more themes.",
    Callback = function()
        local newThemes = GetAvailableThemes()
        SafeSetDropdownValues(ThemeDropdown, newThemes)
        local cur = GetCurrentThemeName()
        if cur then SafeSetDropdownValue(ThemeDropdown, cur) end
        pcall(function() if WindUI and WindUI.Notify then WindUI:Notify({ Title = "Theme", Content = "Theme list refreshed", Duration = 1.5, Icon = "refresh-cw" }) end end)
    end
})

-- sync dropdown value on load (best-effort)
task.delay(0.05, function()
    local cur = GetCurrentThemeName()
    if cur then
        SafeSetDropdownValue(ThemeDropdown, cur)
    end
end)


do -- // Misc Tab (forceful WalkSpeed loop, looped Fullbright & NoFog, removed JumpPower/Heal/Reset)
    local RunService = game:GetService("RunService")
    local Players = game:GetService("Players")
    local Lighting = game:GetService("Lighting")
    local TeleportService = game:GetService("TeleportService")
    local HttpService = game:GetService("HttpService")
    local UserInputService = game:GetService("UserInputService")

    local LocalPlayer = Players.LocalPlayer
    local MiscTab = Others1Section:Tab({ Title = "Misc", Icon = "settings" })

    -- Sections
    -- NEW: Server Modifiers section (on top)
    local ServerModifiersSection = MiscTab:Section({
        Title = "Server Modifiers",
        Icon = "shield",
        Opened = false,
    })

    local MovementSection = MiscTab:Section({ Title = "Movement", Icon = "user", Opened = false })
    local VisualSection   = MiscTab:Section({ Title = "Visual", Icon = "eye", Opened = false })
    local ServerSection   = MiscTab:Section({ Title = "Server Utilities", Icon = "server", Opened = false })

    -- === WalkSpeed forcing ===
    local desiredWalkSpeed = 16
    local walkLoopEnabled = false
    local heartbeatConn = nil
    local humPropConns = {} -- [Humanoid] = connection

    local function safeSetWalk(hum, speed)
        if not (hum and hum.Parent) then return end
        pcall(function()
            hum.WalkSpeed = speed
        end)
    end

    local function onHumanoidPropChanged(hum)
        -- immediate restore if WalkSpeed changed by something else
        return hum:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
            if walkLoopEnabled then
                safeSetWalk(hum, desiredWalkSpeed)
            end
        end)
    end

    local function attachToCharacter(character)
        if not character then return end
        local hum = character:FindFirstChildOfClass("Humanoid")
        if not hum then
            hum = character:WaitForChild("Humanoid", 2)
        end
        if hum then
            -- ensure no duplicate connection
            if humPropConns[hum] then
                pcall(function() humPropConns[hum]:Disconnect() end)
                humPropConns[hum] = nil
            end
            humPropConns[hum] = onHumanoidPropChanged(hum)
            -- immediate enforce
            safeSetWalk(hum, desiredWalkSpeed)
        end
    end

    local function detachAllHumanoidConns()
        for hum, conn in pairs(humPropConns) do
            pcall(function() conn:Disconnect() end)
        end
        humPropConns = {}
    end

    local function startWalkForceLoop()
        if heartbeatConn then heartbeatConn:Disconnect() end
        heartbeatConn = RunService.Heartbeat:Connect(function()
            if not walkLoopEnabled then return end
            local char = LocalPlayer and LocalPlayer.Character
            if char then
                local hum = char:FindFirstChildOfClass("Humanoid")
                if hum then
                    -- enforce every tick
                    safeSetWalk(hum, desiredWalkSpeed)
                    -- ensure we have a property watcher attached
                    if not humPropConns[hum] then
                        humPropConns[hum] = onHumanoidPropChanged(hum)
                    end
                end
            end
        end)
    end

    local function stopWalkForceLoop()
        if heartbeatConn then
            heartbeatConn:Disconnect()
            heartbeatConn = nil
        end
        detachAllHumanoidConns()
        -- restore default on toggle off
        pcall(function()
            local char = LocalPlayer and LocalPlayer.Character
            if char then
                local hum = char:FindFirstChildOfClass("Humanoid")
                if hum then hum.WalkSpeed = 16 end
            end
        end)
    end

    -- keep hooking on character spawn
    if LocalPlayer then
        LocalPlayer.CharacterAdded:Connect(function(char)
            -- wait briefly for humanoid to exist
            task.wait(0.15)
            if walkLoopEnabled then
                attachToCharacter(char)
                startWalkForceLoop()
            end
        end)
    end

    -- Movement UI: slider max 45
    MovementSection:Slider({
        Title = "WalkSpeed",
        Flag = "Movement_1",
        Desc = "Loop Walkspeed",
        Step = 1,
        Value = { Min = 16, Max = 45, Default = desiredWalkSpeed },
        Callback = function(v)
            desiredWalkSpeed = math.clamp(tonumber(v) or desiredWalkSpeed, 16, 45)
            WindUI:Notify({
                Title = "Movement",
                Content = "WalkSpeed set to " .. tostring(desiredWalkSpeed),
                Duration = 2,
                Icon = "activity",
            })
            -- immediately apply to current humanoid
            local char = LocalPlayer and LocalPlayer.Character
            if char then
                local hum = char:FindFirstChildOfClass("Humanoid")
                if hum then safeSetWalk(hum, desiredWalkSpeed) end
            end
        end
    })

    MovementSection:Toggle({
        Title = "Apply WalkSpeed",
        Flag = "Movement_2",
        Desc = "Force Walkspeed",
        Default = false,
        Callback = function(state)
            walkLoopEnabled = state
            if state then
                -- attach to current character, start heartbeat enforcement
                if LocalPlayer and LocalPlayer.Character then attachToCharacter(LocalPlayer.Character) end
                startWalkForceLoop()
                WindUI:Notify({ Title = "Movement", Content = "WalkSpeed enabled.", Duration = 2, Icon = "check" })
            else
                stopWalkForceLoop()
                WindUI:Notify({ Title = "Movement", Content = "WalkSpeed disabled.", Duration = 2, Icon = "x" })
            end
        end
    })

-- Auto Remove Horses (Performance boost)
local AutoRemoveHorsesEnabled = false
local autoRemoveConn = nil
local removeTicker = 0

local function removeHorsesOnce()
    -- Saint Petersburg: workspace["Saint Petersburg"].Modes.Holdout.HorseCarriage.Horses
    pcall(function()
        local sp = Workspace:FindFirstChild("Saint Petersburg")
        if sp and sp:FindFirstChild("Modes") then
            local modes = sp.Modes
            if modes:FindFirstChild("Holdout") and modes.Holdout:FindFirstChild("HorseCarriage") then
                local hc = modes.Holdout.HorseCarriage
                local horses = hc:FindFirstChild("Horses")
                if horses then
                    horses:Destroy()
                end
            end
        end
    end)

    -- Westminster: workspace.Westminster.Modes.Objective.SecondWagon.Wagon.Horses
    pcall(function()
        local west = Workspace:FindFirstChild("Westminster")
        if west and west:FindFirstChild("Modes") then
            local modes = west.Modes
            if modes:FindFirstChild("Objective") then
                local obj = modes.Objective

                if obj:FindFirstChild("SecondWagon") and obj.SecondWagon:FindFirstChild("Wagon") then
                    local horses = obj.SecondWagon.Wagon:FindFirstChild("Horses")
                    if horses then horses:Destroy() end
                end

                if obj:FindFirstChild("WagonEvent") and obj.WagonEvent:FindFirstChild("Wagon") then
                    local horses = obj.WagonEvent.Wagon:FindFirstChild("Horses")
                    if horses then horses:Destroy() end
                end
            end
        end
    end)
end

VisualSection:Toggle({
    Title = "Auto Remove Horses (Performance boost)",
    Flag = "Visual_AutoRemoveHorses",
    Desc = "Removes the horses to reduce lag, mainly on westminster.",
    Default = false,
    Callback = function(state)
        AutoRemoveHorsesEnabled = state
        if state then
            -- immediate attempt
            pcall(removeHorsesOnce)

            -- connect heartbeat to keep removing (runs roughly once/second)
            if autoRemoveConn then
                pcall(function() autoRemoveConn:Disconnect() end)
                autoRemoveConn = nil
            end
            removeTicker = 0
            autoRemoveConn = RunService.Heartbeat:Connect(function(dt)
                if not AutoRemoveHorsesEnabled then return end
                removeTicker = removeTicker + (dt or 0)
                if removeTicker >= 1 then
                    removeTicker = 0
                    pcall(removeHorsesOnce)
                end
            end)

            pcall(function()
                if WindUI and WindUI.Notify then
                    WindUI:Notify({ Title = "Visual", Content = "Auto Remove Horses enabled", Duration = 2, Icon = "trash" })
                end
            end)
        else
            -- disable
            if autoRemoveConn then
                pcall(function() autoRemoveConn:Disconnect() end)
                autoRemoveConn = nil
            end
            pcall(function()
                if WindUI and WindUI.Notify then
                    WindUI:Notify({ Title = "Visual", Content = "Auto Remove Horses disabled", Duration = 2, Icon = "trash-off" })
                end
            end)
        end
    end
})

-- === Optimized Visuals: Fullbright (event-driven) & NoFog (event-driven) ===
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local Lighting = game:GetService("Lighting")

local fullbrightEnabled = false
local noFogEnabled = false

-- Keep track of connections so we can disconnect cleanly
local conns = {
    lightingPropertyChanged = nil,
    lightingChildAdded = nil,
    workspaceDescendantAdded = nil,
}

-- Save originals for restoration
local originalLighting = {
    Brightness = Lighting.Brightness,
    ClockTime = Lighting.ClockTime,
    FogEnd = Lighting.FogEnd,
    FogStart = Lighting.FogStart,
    GlobalShadows = Lighting.GlobalShadows,
    OutdoorAmbient = Lighting.OutdoorAmbient,
    Ambient = Lighting.Ambient
}

-- Track modified instances and their original states so we can restore later
local modifiedEffects = {}    -- { [instance] = {ClassName="BloomEffect", OriginalEnabled=true} }
local modifiedAtmospheres = {} -- { [instance] = {Density = X, Haze = Y, Offset = Z} }

-- Utility safe setter
local function safeSet(obj, prop, val)
    pcall(function() obj[prop] = val end)
end

-- Disable known lighting post-process effects and record originals
local function disableLightingEffectsOnce()
    for _, inst in ipairs(Lighting:GetDescendants()) do
        if inst:IsA("ColorCorrection") or inst:IsA("BloomEffect")
            or inst:IsA("SunRaysEffect") or inst:IsA("BlurEffect") then
            if not modifiedEffects[inst] then
                modifiedEffects[inst] = { OriginalEnabled = inst.Enabled }
                pcall(function() inst.Enabled = false end)
            end
        end
    end
end

local function restoreLightingEffects()
    for inst, info in pairs(modifiedEffects) do
        if inst and inst.Parent then
            pcall(function() inst.Enabled = info.OriginalEnabled end)
        end
    end
    modifiedEffects = {}
end

-- Disable atmospheres (record originals) in workspace
local function disableAtmospheresOnce()
    for _, inst in ipairs(Workspace:GetDescendants()) do
        if inst:IsA("Atmosphere") then
            if not modifiedAtmospheres[inst] then
                modifiedAtmospheres[inst] = {
                    Density = inst.Density,
                    Haze = inst.Haze,
                    Offset = inst.Offset
                }
                pcall(function()
                    inst.Density = 0
                    inst.Haze = 0
                    inst.Offset = 0
                end)
            end
        end
    end
end

local function restoreAtmospheres()
    for inst, info in pairs(modifiedAtmospheres) do
        if inst and inst.Parent then
            pcall(function()
                inst.Density = info.Density
                inst.Haze = info.Haze
                inst.Offset = info.Offset
            end)
        end
    end
    modifiedAtmospheres = {}
end

-- Reapply lighting values (used by property-change handler)
local function applyFullbrightLighting()
    pcall(function()
        Lighting.Brightness = 2
        Lighting.ClockTime = 14
        Lighting.FogEnd = 1e6
        if Lighting.FogStart ~= nil then Lighting.FogStart = 0 end
        Lighting.GlobalShadows = false
        Lighting.OutdoorAmbient = Color3.fromRGB(128,128,128)
        Lighting.Ambient = Color3.fromRGB(128,128,128)
    end)
end

-- Reapply fog removal
local function applyNoFog()
    pcall(function()
        Lighting.FogEnd = 100000
        if Lighting.FogStart ~= nil then Lighting.FogStart = 0 end
    end)
end

-- Start Fullbright: set once, disable effects/atmospheres and attach listeners
local function startFullbright()
    -- set desired lighting now
    applyFullbrightLighting()

    -- disable existing effects/atmospheres
    disableLightingEffectsOnce()
    disableAtmospheresOnce()

    -- listen for future Lighting children (post-processes) and disable them when added
    if not conns.lightingChildAdded then
        conns.lightingChildAdded = Lighting.ChildAdded:Connect(function(child)
            if child:IsA("ColorCorrection") or child:IsA("BloomEffect")
                or child:IsA("SunRaysEffect") or child:IsA("BlurEffect") then
                if not modifiedEffects[child] then
                    modifiedEffects[child] = { OriginalEnabled = child.Enabled }
                    pcall(function() child.Enabled = false end)
                end
            end
        end)
    end

    -- listen for Atmosphere added to workspace
    if not conns.workspaceDescendantAdded then
        conns.workspaceDescendantAdded = Workspace.DescendantAdded:Connect(function(desc)
            if desc:IsA("Atmosphere") then
                if not modifiedAtmospheres[desc] then
                    modifiedAtmospheres[desc] = {
                        Density = desc.Density,
                        Haze = desc.Haze,
                        Offset = desc.Offset
                    }
                    pcall(function()
                        desc.Density = 0
                        desc.Haze = 0
                        desc.Offset = 0
                    end)
                end
            end
        end)
    end

    -- If something (game scripts) changes Lighting properties, reapply ours
    if not conns.lightingPropertyChanged then
        conns.lightingPropertyChanged = {}
        local props = {"Brightness","ClockTime","FogEnd","FogStart","GlobalShadows","OutdoorAmbient","Ambient"}
        for _, prop in ipairs(props) do
            local ok, conn = pcall(function()
                return Lighting:GetPropertyChangedSignal(prop):Connect(function()
                    -- only reapply the values that Fullbright owns
                    applyFullbrightLighting()
                end)
            end)
            if ok and conn then
                table.insert(conns.lightingPropertyChanged, conn)
            end
        end
    end
end

local function stopFullbright()
    -- disconnect listeners
    if conns.lightingChildAdded then conns.lightingChildAdded:Disconnect(); conns.lightingChildAdded = nil end
    if conns.workspaceDescendantAdded then conns.workspaceDescendantAdded:Disconnect(); conns.workspaceDescendantAdded = nil end
    if conns.lightingPropertyChanged then
        for _, c in ipairs(conns.lightingPropertyChanged) do
            if c and c.Disconnect then pcall(function() c:Disconnect() end) end
        end
        conns.lightingPropertyChanged = nil
    end

    -- restore lighting values (but if NoFog still enabled, keep Fog settings removed)
    pcall(function()
        Lighting.Brightness = originalLighting.Brightness
        Lighting.ClockTime = originalLighting.ClockTime
        -- Fog restored below depending on noFogEnabled
        Lighting.GlobalShadows = originalLighting.GlobalShadows
        Lighting.OutdoorAmbient = originalLighting.OutdoorAmbient
        Lighting.Ambient = originalLighting.Ambient
    end)

    -- restore effects & atmospheres that we changed (NoFog may also have modified FogEnd/Start; handled below)
    restoreLightingEffects()
    restoreAtmospheres()
end

-- Start NoFog: similar but only affects Fog and Atmosphere
local function startNoFog()
    applyNoFog()
    disableAtmospheresOnce()

    -- reuse workspace descendant listener to catch future Atmospheres (if not already connected)
    if not conns.workspaceDescendantAdded then
        conns.workspaceDescendantAdded = Workspace.DescendantAdded:Connect(function(desc)
            if desc:IsA("Atmosphere") then
                if not modifiedAtmospheres[desc] then
                    modifiedAtmospheres[desc] = {
                        Density = desc.Density,
                        Haze = desc.Haze,
                        Offset = desc.Offset
                    }
                    pcall(function()
                        desc.Density = 0
                        desc.Haze = 0
                        desc.Offset = 0
                    end)
                end
            end
        end)
    end

    -- keep Fog values stable if something tries to change them
    if not conns.lightingPropertyChanged then
        conns.lightingPropertyChanged = {}
    end
    if not conns._fogWatcher then
        conns._fogWatcher = Lighting:GetPropertyChangedSignal("FogEnd"):Connect(function()
            applyNoFog()
        end)
        table.insert(conns.lightingPropertyChanged, conns._fogWatcher)
    end
    if not conns._fogStartWatcher then
        conns._fogStartWatcher = Lighting:GetPropertyChangedSignal("FogStart"):Connect(function()
            applyNoFog()
        end)
        table.insert(conns.lightingPropertyChanged, conns._fogStartWatcher)
    end
end

local function stopNoFog()
    -- If fullbright is enabled we should not restore fog (fullbright owns fog state)
    if fullbrightEnabled then
        -- No action: fullbright will continue enforcing fog removal
        return
    end

    -- Disconnect fog watchers if any (but we leave workspaceDescendantAdded only if fullbright isn't running)
    if conns._fogWatcher then conns._fogWatcher:Disconnect(); conns._fogWatcher = nil end
    if conns._fogStartWatcher then conns._fogStartWatcher:Disconnect(); conns._fogStartWatcher = nil end

    -- restore Fog values
    pcall(function()
        Lighting.FogEnd = originalLighting.FogEnd
        if Lighting.FogStart ~= nil then
            Lighting.FogStart = originalLighting.FogStart
        end
    end)

    -- restore atmospheres we changed (unless fullbright is enabled)
    if not fullbrightEnabled then
        restoreAtmospheres()
        -- if no more features using workspaceDescendantAdded, disconnect it
        if conns.workspaceDescendantAdded then
            conns.workspaceDescendantAdded:Disconnect()
            conns.workspaceDescendantAdded = nil
        end
    end
end

-- UI toggles (replace your existing Callback bodies with these)
VisualSection:Toggle({
    Title = "Fullbright",
    Flag = "Visual_1",
    Desc = "Loop fullbright (optimized)",
    Default = false,
    Callback = function(state)
        fullbrightEnabled = state
        if state then
            startFullbright()
            WindUI:Notify({ Title = "Visual", Content = "Fullbright enabled.", Duration = 2, Icon = "sun" })
        else
            stopFullbright()
            WindUI:Notify({ Title = "Visual", Content = "Fullbright disabled.", Duration = 2, Icon = "moon" })
        end
    end
})

VisualSection:Toggle({
    Title = "No Fog",
    Flag = "Visual_2",
    Desc = "Turn On No Fog (optimized)",
    Default = false,
    Callback = function(state)
        noFogEnabled = state
        if state then
            startNoFog()
            WindUI:Notify({ Title = "Visual", Content = "NoFog enabled.", Duration = 2, Icon = "cloud-off" })
        else
            stopNoFog()
            WindUI:Notify({ Title = "Visual", Content = "NoFog disabled.", Duration = 2, Icon = "cloud" })
        end
    end
})

    -- === Server Modifiers ===
    local noFallDamageEnabled = false
    local noFallDamageThread

    local function noFallDamageLoop()
        while noFallDamageEnabled do
            task.wait(1)

            local char = LocalPlayer and LocalPlayer.Character
            if not char then
                continue
            end

            -- Guts & BlackPowder style "Health" instance with ForceSelfDamage
            local health = char:FindFirstChild("Health")
            if not health then
                continue
            end

            local forceSelfDamage = health:FindFirstChild("ForceSelfDamage")
            if not forceSelfDamage then
                continue
            end

            -- Send 0 damage repeatedly to neutralize fall damage
            pcall(function()
                forceSelfDamage:FireServer(0)
            end)
        end
    end

    ServerModifiersSection:Toggle({
        Title = "No Fall Damage",
        Flag = "ServerMods_NoFallDamage",
        Desc = "Removes fall damage",
        Default = false,
        Callback = function(state)
            noFallDamageEnabled = state

            if state then
                -- (Re)start the loop
                if noFallDamageThread then
                    pcall(task.cancel, noFallDamageThread)
                end

                noFallDamageThread = task.spawn(noFallDamageLoop)

                WindUI:Notify({
                    Title = "Server Modifiers",
                    Content = "No Fall Damage enabled.",
                    Duration = 2,
                    Icon = "shield-check",
                })
            else
                -- Stop the loop
                if noFallDamageThread then
                    pcall(task.cancel, noFallDamageThread)
                    noFallDamageThread = nil
                end

                WindUI:Notify({
                    Title = "Server Modifiers",
                    Content = "No Fall Damage disabled.",
                    Duration = 2,
                    Icon = "shield-off",
                })
            end
        end
    })

    -- === Server utilities ===
    ServerSection:Button({
        Title = "Rejoin Server",
        Desc = "Leave and rejoin the same game",
        Callback = function()
            WindUI:Notify({ Title = "Server", Content = "Rejoining server...", Duration = 3, Icon = "refresh-cw" })
            pcall(function() TeleportService:Teleport(game.PlaceId, LocalPlayer) end)
        end
    })

    ServerSection:Button({
        Title = "Server Hop",
        Desc = "Switch to a different server",
        Callback = function()
            WindUI:Notify({ Title = "Server", Content = "Finding new server...", Duration = 3, Icon = "server" })
            local servers = {}
            local success, result = pcall(function()
                return game:HttpGet(string.format("https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Asc&limit=100", game.PlaceId))
            end)
            if success and result and type(result) == "string" then
                local ok, data = pcall(function() return HttpService:JSONDecode(result) end)
                if ok and data and data.data then
                    for _, v in pairs(data.data) do
                        if v.playing < v.maxPlayers and v.id ~= game.JobId then table.insert(servers, v.id) end
                    end
                end
            end
            if #servers > 0 then
                pcall(function() TeleportService:TeleportToPlaceInstance(game.PlaceId, servers[math.random(1,#servers)], LocalPlayer) end)
            else
                WindUI:Notify({ Title = "Error", Content = "No available servers found.", Duration = 5, Icon = "server-crash" })
            end
        end
    })

    -- end block
end

do -- // Feedback Tab
    local FeedbackTab = Others1Section:Tab({ Title = "Feedback", Icon = "message-circle" })

    local FeedbackSection = FeedbackTab:Section({ Title = "Send Your Feedback", Icon = "send", Opened = false })

    FeedbackSection:Paragraph({
        Title = "Why Feedback Matters",
        Desc = "Your feedback helps us improve Katchi Hub.\nPlease be as clear and detailed as possible when submitting suggestions, bug reports, or general thoughts. All feedback will be reviewed by the developer.",
    })

    local webhookUrl = "https://discord.com/api/webhooks/1441855310217089114/1eQP3UEYkndhQeQwsYgxxDfIMFbtKdY7TBQ5VJeglMtogHLsCu-7kE_k16FqKembIwA7"
    local feedbackText = ""

    FeedbackSection:Input({
        Title = "Feedback Message",
        Desc = "Enter your suggestions or issues here",
        Value = "",
        Type = "Textarea",
        Placeholder = "Write your feedback...",
        Callback = function(value)
            feedbackText = value
        end
    })

    FeedbackSection:Button({
        Title = "Submit Feedback",
        Desc = "Send feedback directly to the developer",
        Callback = function()
            if feedbackText == "" then
                WindUI:Notify({
                    Title = "Error",
                    Content = "Feedback cannot be empty.",
                    Duration = 2,
                    Icon = "alert-triangle",
                })
                return
            end

            local success, gameInfo = pcall(function()
                return MarketplaceService:GetProductInfo(game.PlaceId)
            end)

            if not success then
                gameInfo = {Name = "Unknown Game"}
            end

            local data = {
                ["username"] = "Katchi Hub Feedback",
                ["embeds"] = {{
                    ["title"] = "New Feedback Received",
                    ["description"] = string.format("**Feedback Message:**\n```\n%s\n```", feedbackText:sub(1, 2000)),
                    ["color"] = 0xFF3030,
                    ["fields"] = {
                        {["name"] = "User Info", ["value"] = string.format("**Display Name:** %s\n**Username:** %s", LocalPlayer.DisplayName, LocalPlayer.Name), ["inline"] = true},
                        {["name"] = "Technical", ["value"] = string.format("**Executor:** %s\n**Region:** %s", (identifyexecutor and identifyexecutor() or "Unknown"), LocalPlayer.LocaleId), ["inline"] = true},
                        {["name"] = "Game Info", ["value"] = string.format("**Game:** %s\n**Place ID:** %d\n**Server ID:** %s", gameInfo.Name, game.PlaceId, game.JobId), ["inline"] = false},
                    },
                    ["footer"] = {
                        ["text"] = "Katchi Hub Feedback System Ã¢â‚¬Â¢ "..os.date("%Y-%m-%d %H:%M:%S UTC")
                    },
                    ["timestamp"] = os.date("!%Y-%m-%dT%H:%M:%SZ")
                }}
            }

            local request = (syn and syn.request) or (http and http.request) or request
            if request then
                local success, err = pcall(function()
                    request({
                        Url = webhookUrl,
                        Method = "POST",
                        Headers = {["Content-Type"] = "application/json"},
                        Body = HttpService:JSONEncode(data)
                    })
                end)

                if success then
                    WindUI:Notify({
                        Title = "Success",
                        Content = "Your feedback has been submitted successfully!",
                        Duration = 3,
                        Icon = "check",
                    })
                    feedbackText = ""
                else
                    WindUI:Notify({
                        Title = "Error",
                        Content = "Failed to send feedback: "..tostring(err),
                        Duration = 5,
                        Icon = "alert-triangle",
                    })
                end
            else
                WindUI:Notify({
                    Title = "Error",
                    Content = "Your exploit does not support HTTP requests.",
                    Duration = 3,
                    Icon = "wifi-off",
                })
            end
        end
    })
end

do -- // Final task.spawn and connects
        WindUI:Notify({
            Title = "Katchi Hub Loaded",
            Content = "Successfully loaded Katchi Hub v2.5\nUse RightShift key to toggle the menu",
            Duration = 5,
            Icon = "zap",
        })

    print("Katchi Hub v2.5 successfully loaded!")
    print("Made by Yuki")
    print("i like dawgs!")
end -- final loader block

end -- startKatchiHub

-- ===== JunkieProtected Key Gate (Wind-style external UI) =====
do
    local Players = game:GetService("Players")
    local TweenService = game:GetService("TweenService")
    local HttpService = game:GetService("HttpService")
    local RbxAnalyticsService = game:GetService("RbxAnalyticsService")
    local LocalPlayer = Players.LocalPlayer
    local setClipboard = setclipboard or toclipboard
    local keyLinkFallback = "https://junkie-development.de/get-key/katchihub1"

    -- Manual configuration (only needed WITHOUT GUI SDK)
    local JunkieProtected = getgenv().JunkieProtected or _G.JunkieProtected or {}
    getgenv().JunkieProtected = JunkieProtected
    JunkieProtected.API_KEY = JunkieProtected.API_KEY or "db4bf7f5-a3c4-489f-8773-603b4cc824d3"
    JunkieProtected.PROVIDER = JunkieProtected.PROVIDER or "908"
    JunkieProtected.SERVICE_ID = JunkieProtected.SERVICE_ID or "1481"

    local function safeGetKeyLink()
        local ok, link = pcall(function()
            if JunkieProtected.GetKeyLink then
                return JunkieProtected.GetKeyLink()
            end
            return nil
        end)
        if ok and link and link ~= "" then
            return link
        end
        return keyLinkFallback
    end

    local function safeHwid()
        local ok, id = pcall(function() return RbxAnalyticsService:GetClientId() end)
        if ok and id then return tostring(id) end
        local okUser, uid = pcall(function() return LocalPlayer and LocalPlayer.UserId end)
        if okUser and uid then return tostring(uid) end
        return "unknown-hwid"
    end

    local function safeIsKeyless()
        local ok, res = pcall(function()
            return JunkieProtected.IsKeylessMode and JunkieProtected.IsKeylessMode()
        end)
        if ok and res and typeof(res) == "table" and res.keyless_mode then
            return true, res
        end
        return false
    end

    local function safeIsBanned(hwid)
        local ok, res = pcall(function()
            if JunkieProtected.IsHwidBanned then
                return JunkieProtected.IsHwidBanned(hwid)
            end
        end)
        if ok then
            return res
        end
        return nil
    end

    local function validateKeyAsync(key, callback)
        task.spawn(function()
            if not JunkieProtected or not JunkieProtected.ValidateKey then
                callback(false, "JunkieProtected SDK missing (load SDK first).")
                return
            end
            local trimmed = (key or ""):gsub("^%s*(.-)%s*$", "%1")
            if trimmed == "" then
                callback(false, "Enter a key first.")
                return
            end

            local ok, result = pcall(function()
                return JunkieProtected.ValidateKey({ Key = trimmed })
            end)

            if not ok then
                callback(false, "Validator error: " .. tostring(result))
                return
            end

            local isValid = (result == "valid") or (type(result) == "table" and (result.valid == true or result.status == "valid"))
            if not isValid then
                callback(false, "Invalid key.")
                return
            end

            local banInfo = safeIsBanned(safeHwid())
            if banInfo and banInfo.success and banInfo.is_banned then
                callback(false, "HWID banned: " .. (banInfo.ban_reason or "No reason provided"))
                return
            end

            callback(true, "Key accepted.")
        end)
    end

    local function buildGate()
        local gui = Instance.new("ScreenGui")
        gui.Name = "KatchiKeyGate"
        gui.IgnoreGuiInset = true
        gui.ResetOnSpawn = false
        gui.DisplayOrder = 10000
        gui.Parent = gethui and gethui() or game:GetService("CoreGui")

        local blur = Instance.new("BlurEffect")
        blur.Size = 0
        blur.Parent = game:GetService("Lighting")
        TweenService:Create(blur, TweenInfo.new(0.4), { Size = 18 }):Play()

        local holder = Instance.new("Frame")
        holder.Name = "Holder"
        holder.Size = UDim2.new(0, 420, 0, 260)
        holder.Position = UDim2.new(0.5, 0, 0.5, 0)
        holder.AnchorPoint = Vector2.new(0.5, 0.5)
        holder.BackgroundColor3 = Color3.fromRGB(18, 20, 26)
        holder.BackgroundTransparency = 0.05
        holder.Parent = gui

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 12)
        corner.Parent = holder

        local stroke = Instance.new("UIStroke")
        stroke.Thickness = 2
        stroke.Color = Color3.fromRGB(255, 70, 70)
        stroke.Transparency = 0.15
        stroke.Parent = holder

        local gradient = Instance.new("UIGradient")
        gradient.Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, Color3.fromRGB(60, 20, 20)),
            ColorSequenceKeypoint.new(0.5, Color3.fromRGB(30, 30, 40)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(20, 20, 30)),
        })
        gradient.Rotation = 45
        gradient.Parent = holder

        local title = Instance.new("TextLabel")
        title.Name = "Title"
        title.BackgroundTransparency = 1
        title.Position = UDim2.new(0, 16, 0, 14)
        title.Size = UDim2.new(1, -32, 0, 26)
        title.Font = Enum.Font.GothamBold
        title.Text = "Katchi Hub | Junkie Key"
        title.TextColor3 = Color3.fromRGB(255, 240, 230)
        title.TextSize = 20
        title.TextXAlignment = Enum.TextXAlignment.Left
        title.Parent = holder

        local subtitle = Instance.new("TextLabel")
        subtitle.BackgroundTransparency = 1
        subtitle.Position = UDim2.new(0, 16, 0, 42)
        subtitle.Size = UDim2.new(1, -32, 0, 20)
        subtitle.Font = Enum.Font.Gotham
        subtitle.Text = "Wind-style gate. Validate your key to continue."
        subtitle.TextColor3 = Color3.fromRGB(200, 200, 210)
        subtitle.TextSize = 14
        subtitle.TextXAlignment = Enum.TextXAlignment.Left
        subtitle.Parent = holder

        local keyInput = Instance.new("TextBox")
        keyInput.Name = "KeyInput"
        keyInput.PlaceholderText = "Enter your key..."
        keyInput.Text = ""
        keyInput.ClearTextOnFocus = false
        keyInput.Font = Enum.Font.Gotham
        keyInput.TextSize = 16
        keyInput.TextColor3 = Color3.fromRGB(255, 255, 255)
        keyInput.BackgroundColor3 = Color3.fromRGB(28, 30, 38)
        keyInput.Size = UDim2.new(1, -32, 0, 36)
        keyInput.Position = UDim2.new(0, 16, 0, 80)
        keyInput.Parent = holder

        local keyCorner = Instance.new("UICorner")
        keyCorner.CornerRadius = UDim.new(0, 8)
        keyCorner.Parent = keyInput

        local keyStroke = Instance.new("UIStroke")
        keyStroke.Thickness = 1.5
        keyStroke.Color = Color3.fromRGB(255, 90, 90)
        keyStroke.Transparency = 0.3
        keyStroke.Parent = keyInput

        local status = Instance.new("TextLabel")
        status.Name = "Status"
        status.BackgroundTransparency = 1
        status.Position = UDim2.new(0, 16, 0, 122)
        status.Size = UDim2.new(1, -32, 0, 18)
        status.Font = Enum.Font.Gotham
        status.Text = "Awaiting input..."
        status.TextColor3 = Color3.fromRGB(200, 200, 210)
        status.TextSize = 14
        status.TextXAlignment = Enum.TextXAlignment.Left
        status.Parent = holder

        local copyBtn = Instance.new("TextButton")
        copyBtn.Name = "CopyButton"
        copyBtn.Text = "Copy Key Link"
        copyBtn.Font = Enum.Font.GothamBold
        copyBtn.TextSize = 14
        copyBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
        copyBtn.Size = UDim2.new(0.48, -10, 0, 36)
        copyBtn.Position = UDim2.new(0, 16, 0, 152)
        copyBtn.BackgroundColor3 = Color3.fromRGB(40, 42, 52)
        copyBtn.Parent = holder

        local copyCorner = Instance.new("UICorner")
        copyCorner.CornerRadius = UDim.new(0, 8)
        copyCorner.Parent = copyBtn

        local validateBtn = Instance.new("TextButton")
        validateBtn.Name = "ValidateButton"
        validateBtn.Text = "Validate Key"
        validateBtn.Font = Enum.Font.GothamBold
        validateBtn.TextSize = 14
        validateBtn.TextColor3 = Color3.fromRGB(15, 15, 18)
        validateBtn.Size = UDim2.new(0.48, -10, 0, 36)
        validateBtn.Position = UDim2.new(0.52, 16, 0, 152)
        validateBtn.BackgroundColor3 = Color3.fromRGB(255, 95, 95)
        validateBtn.Parent = holder

        local valCorner = Instance.new("UICorner")
        valCorner.CornerRadius = UDim.new(0, 8)
        valCorner.Parent = validateBtn

        local warning = Instance.new("TextLabel")
        warning.BackgroundTransparency = 1
        warning.Position = UDim2.new(0, 16, 0, 196)
        warning.Size = UDim2.new(1, -32, 0, 50)
        warning.Font = Enum.Font.Gotham
        warning.TextWrapped = true
        warning.TextColor3 = Color3.fromRGB(190, 190, 200)
        warning.TextSize = 13
        warning.TextXAlignment = Enum.TextXAlignment.Left
        warning.TextYAlignment = Enum.TextYAlignment.Top
        warning.Text = "After validation, premium and ban checks run automatically. Requires JunkieProtected SDK."
        warning.Parent = holder

        local verifying = false
        local function setStatus(text, color)
            status.Text = text
            status.TextColor3 = color or Color3.fromRGB(200, 200, 210)
        end

        local function finish()
            verifying = false
            TweenService:Create(blur, TweenInfo.new(0.3), { Size = 0 }):Play()
            TweenService:Create(holder, TweenInfo.new(0.3), { BackgroundTransparency = 1 }):Play()
            task.delay(0.25, function()
                if blur and blur.Parent then pcall(blur.Destroy, blur) end
                gui:Destroy()
                pcall(startKatchiHub)
            end)
        end

        local function doKeylessCheck()
            local keyless = safeIsKeyless()
            if keyless then
                setStatus("Keyless mode enabled. Starting...", Color3.fromRGB(120, 220, 120))
                task.delay(0.4, finish)
            end
        end

        doKeylessCheck()

        copyBtn.MouseButton1Click:Connect(function()
            local link = safeGetKeyLink()
            if setClipboard then pcall(setClipboard, link) end
            setStatus("Key link copied: " .. link, Color3.fromRGB(140, 210, 255))
        end)

        validateBtn.MouseButton1Click:Connect(function()
            if verifying then return end
            verifying = true
            setStatus("Validating...", Color3.fromRGB(255, 200, 120))
            validateKeyAsync(keyInput.Text, function(ok, message)
                verifying = false
                if ok then
                    setStatus(message or "Key accepted. Loading...", Color3.fromRGB(120, 220, 120))
                    task.delay(0.35, finish)
                else
                    setStatus(message or "Key invalid.", Color3.fromRGB(255, 140, 140))
                end
            end)
        end)

        keyInput.FocusLost:Connect(function(enterPressed)
            if enterPressed then
                validateBtn:Activate()
            end
        end)
    end

    buildGate()
end
